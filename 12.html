<!DOCTYPE html>
<!-- paulirish.com/2008/conditional-stylesheets-vs-css-hacks-answer-neither/ -->
<!--[if lt IE 7]><html class="ie ie6 ie-lte9 ie-lte8 ie-lte7 no-js" lang="en-us"> <![endif]-->
<!--[if IE 7]><html class="ie ie7 ie-lte9 ie-lte8 ie-lte7 no-js" lang="en-us"> <![endif]-->
<!--[if IE 8]><html class="ie ie8 ie-lte9 ie-lte8 no-js" lang="en-us"> <![endif]-->
<!--[if IE 9]><html class="ie9 ie-lte9 no-js" lang="en-us"> <![endif]-->
<!--[if (gt IE 9)|!(IE)]><!--> <html class="no-js" lang="en-us"> <!--<![endif]-->
<head>
  <meta charset="utf-8" />
  <!-- www.phpied.com/conditional-comments-block-downloads/ -->
  <!-- Always force latest IE rendering engine
       (even in intranet) & Chrome Frame
       Remove this if you use the .htaccess -->
  <!--[if IE]>
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <![endif]-->

  <title>Diffbook</title>

  <!-- http://dev.w3.org/html5/markup/meta.name.html -->
  <meta name="application-name" content="diffbook" />

  <!-- Speaking of Google, don't forget to set your site up:
       http://google.com/webmasters -->
  <meta name="google-site-verification" content="" />

  <!--  Mobile Viewport Fix
        j.mp/mobileviewport & davidbcalhoun.com/2010/viewport-metatag
        device-width: Occupy full width of the screen in its current orientation
        initial-scale = 1.0 retains dimensions instead of zooming out if page height > device height
        user-scalable = yes allows the user to zoom in -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <link rel="shortcut icon" href="static/images/favicon.ico" type="image/x-icon">
  <link rel="apple-touch-icon" href="static/images/favicon.png">

  <!-- All JavaScript at the bottom, except for Modernizr which enables
       HTML5 elements & feature detects -->
  <script src="static/js/modernizr.custom.js"></script>

  <!-- include stylesheets -->
  

  <script type="text/javascript"><!--
    // These variables are used by the web2py_ajax_init function in web2py_ajax.js (which is loaded below).
    var w2p_ajax_confirm_message = "Are you sure you want to delete this object?";
    var w2p_ajax_date_format = "%Y-%m-%d";
    var w2p_ajax_datetime_format = "%Y-%m-%d %H:%M:%S";
    //--></script>
<meta name="keywords" content="web2py, python, framework" />

<meta name="description" content="a cool new app" />

<meta name="generator" content="Web2py Web Framework" />

<meta name="author" content="Your Name &lt;you@example.com&gt;" />
<script src="static/js/jquery.js" type="text/javascript"></script><link href="static/css/calendar.css" rel="stylesheet" type="text/css" /><script src="static/js/calendar.js" type="text/javascript"></script><script src="static/js/web2py.js" type="text/javascript"></script><link href="static/css/web2py.css" rel="stylesheet" type="text/css" /><link href="static/css/bootstrap.min.css" rel="stylesheet" type="text/css" /><link href="static/css/bootstrap-responsive.min.css" rel="stylesheet" type="text/css" /><link href="static/css/web2py_bootstrap.css" rel="stylesheet" type="text/css" />


  

  <!-- uncomment here to load jquery-ui
       <link rel="stylesheet" href="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8.16/themes/base/jquery-ui.css" type="text/css" media="all" />
       <script src="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8.16/jquery-ui.min.js" type="text/javascript"></script>
       uncomment to load jquery-ui //-->
  <noscript><link href="static/css/web2py_bootstrap_nojs.css" rel="stylesheet" type="text/css" /></noscript>
  
  <style type="text/css">

      /* Sticky footer styles
      -------------------------------------------------- */

      html,
      body {
        height: 100%;
        /* The html and body elements cannot have any padding or margin. */
      }

      /* Wrapper for page content to push down footer */
      #wrap {
        min-height: 100%;
        height: auto !important;
        height: 100%;
        /* Negative indent footer by it's height */
        margin: 0 auto -60px;
      }

      /* Set the fixed height of the footer here */
      #push,
      #footer {
        height: 60px;
      }
      #footer {
        background-color: #f5f5f5;
      }

      /* Lastly, apply responsive CSS fixes as necessary */
      @media (max-width: 767px) {
        #footer {
          margin-left: -20px;
          margin-right: -20px;
          padding-left: 20px;
          padding-right: 20px;
        }
      }



      /* Custom page CSS
      -------------------------------------------------- */
      /* Not required for template or sticky footer method. */

      .container {
        width: auto;
        max-width: 680px;
      }
      .container .credit {
        margin: 20px 0;
      }

    </style>
</head>

<body>
  
  <body>


    <!-- Part 1: Wrap all page content here -->
    <div id="wrap">

      <!-- Begin page content -->
      <div class="container-fluid">
        <div class="page-header">
          	<h1>
              Diffbook
              <small>easy? diffbook</small>
            </h1>
        </div>
        
        

<div class="pagination">
  <ul>    

      <li><a href="/diffbook/0.html">Chapter 0</a></li>

      <li><a href="/diffbook/1.html">Chapter 1</a></li>

      <li><a href="/diffbook/2.html">Chapter 2</a></li>

      <li><a href="/diffbook/3.html">Chapter 3</a></li>

      <li><a href="/diffbook/4.html">Chapter 4</a></li>

      <li><a href="/diffbook/5.html">Chapter 5</a></li>

      <li><a href="/diffbook/6.html">Chapter 6</a></li>

      <li><a href="/diffbook/7.html">Chapter 7</a></li>

      <li><a href="/diffbook/8.html">Chapter 8</a></li>

      <li><a href="/diffbook/9.html">Chapter 9</a></li>

      <li><a href="/diffbook/10.html">Chapter 10</a></li>

      <li><a href="/diffbook/11.html">Chapter 11</a></li>

      <li><a href="/diffbook/12.html">Chapter 12</a></li>

  </ul>
</div>

<div class="pagination">
  <ul>    

      <li><a href="#com_7bce1473ce90f4e60f49d72bf1b61d32f430cb54">7bce147</a></li>

      <li><a href="#com_df4ca32e45895ff30b9ff2465b997c895a46d525">df4ca32</a></li>

      <li><a href="#com_097d699dc16179206ccb7e4aee863d6523cd471c">097d699</a></li>

      <li><a href="#com_010aa0543ab690b5d1930c4b7d8584b4eb0fa73f">010aa05</a></li>

      <li><a href="#com_77e0846262922b8d1f776f23ca079114677b4048">77e0846</a></li>

      <li><a href="#com_ac4003f4349f9ee22c67309ceeb48de5539b0308">ac4003f</a></li>

  </ul>
</div>



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/7bce1473ce90f4e60f49d72bf1b61d32f430cb54">7bce147</a><ul><li>Date : 2012-12-22</li><li>scheduler.queue_task</li></ul></li></ul>
<div class="row-fluid" id="com_7bce1473ce90f4e60f49d72bf1b61d32f430cb54">
    <div class="span6"><pre style="background-color: #DFF0D8;">``
@auth.requires_login()
def post():
    return dict(form=SQLFORM(db.comment).process(),
                comments=db(db.comment).select())
``:code

and the corresponding &quot;views/comments/post.html&quot;

``
{{extend &#x27;layout.html&#x27;}}
{{for comment in comments:}}
&lt;div class=&quot;comment&quot;&gt;
  on {{=comment.posted_on}} {{=comment.posted_by.first_name}}
  says &lt;span class=&quot;comment_body&quot;&gt;{{=comment.body}}&lt;/span&gt;
&lt;/div&gt;
{{pass}}
{{=form}}
``:code

You can access it as usual at:

``
http://127.0.0.1:8000/test/comments/post
``:code

[[image @///image/en7900.png center 480px]]

So far there is nothing special in this action, but we can turn it into a component by defining a new view with extension &quot;.load&quot; that does not extend the layout.

Hence we create a &quot;views/comments/post.load&quot;:

``
{{#extend &#x27;layout.html&#x27; &lt;- notice this is commented out!}}
The rules above do not solve the problem of plugin versions and dependencies. Th
#### Component plugins
``component plugin``:inxx

Component plugins are plugins that define components. Components usually access the database and define with their own models.

Here we turn the previous ``comments`` component into a ``comments_plugin`` by using the same code we wrote before, but following all of the previous rules.

First, we create a model called &quot;models/plugin_comments.py&quot;:

``
db.define_table(&#x27;plugin_comments_comment&#x27;,
   Field(&#x27;body&#x27;,&#x27;text&#x27;, label=&#x27;Your comment&#x27;),
   Field(&#x27;posted_on&#x27;, &#x27;datetime&#x27;, default=request.now),
   Field(&#x27;posted_by&#x27;, db.auth_user, default=auth.user_id))
db.plugin_comments_comment.posted_on.writable=False
db.plugin_comments_comment.posted_on.readable=False
db.plugin_comments_comment.posted_by.writable=False
db.plugin_comments_comment.posted_by.readable=False

def plugin_comments():
    return LOAD(&#x27;plugin_comments&#x27;,&#x27;post&#x27;,ajax=True)
``:code
(notice the last two lines define a function that will simplify the embedding of the plugin)

Second, we define a &quot;controllers/plugin_comments.py&quot;

``
@auth.requires_login()
def post():
    comment = db.plugin_comments_comment
    return dict(form=SQLFORM(comment).process(),
                comments=db(comment).select())
``:code

Third, we create a view called &quot;views/plugin_comments/post.load&quot;:

``
{{for comment in comments:}}
&lt;div class=&quot;comment&quot;&gt;
  on {{=comment.posted_on}} {{=comment.posted_by.first_name}}
  says &lt;span class=&quot;comment_body&quot;&gt;{{=comment.body}}&lt;/span&gt;
&lt;/div&gt;
{{pass}}
{{=form}}
``:code

Now we can use **admin** to pack the plugin for distribution. Admin will save this plugin as:

``
web2py.plugin.comments.w2p
``:code

We can use the plugin in any view by simply installing the plugin via the **edit** page in **admin** and adding this to our own views

``
{{=plugin_comments()}}
``:code

Of course we can make the plugin more sophisticated by having components that take parameters and configuration options. The more complex the components, the more difficult it becomes to avoid name collisions. The Plugin Manager described below is designed to avoid this problem.

#### Plugin manager
When the plugin is defined, the PluginManager must take arguments: the plugin na
Layout plugins are simpler than component plugins because usually they do not contain code, but only views and static files. Yet you should still follow  good practice:

First, create a folder called &quot;static/plugin_layout_&#x27;&#x27;name&#x27;&#x27;/&quot; (where name is the name of your layout) and place all your static files there.

Second, create a layout file called &quot;views/plugin_layout_&#x27;&#x27;name&#x27;&#x27;/layout.html&quot; that contains your layout and links the images, CSS and JavaScript files in &quot;static/plugin_layout_&#x27;&#x27;name&#x27;&#x27;/&quot;

Third, modify the &quot;views/layout.html&quot; so that it simply reads:

``
{{extend &#x27;plugin_layout_name/layout.html&#x27;}}
{{include}}
``:code

The benefit of this design is that users of this plugin can install multiple layouts and choose which one to apply simply by editing &quot;views/layout.html&quot;. Moreover, &quot;views/layout.html&quot; will not be packed by **admin** together with the plugin, so there is no risk that the plugin will override the user&#x27;s code in the previously installed layout.

### ``plugin_wiki``
``plugin_wiki``:inxx ``wiki``:inxx

-----
DISCLAIMER: plugin_wiki is still very much under development and therefore we do not promise backward compatibility to the same level as for web2py core functions.
-----

**plugin_wiki** is a plugin on steroids.  What we mean is that it defines multiple useful components and it may change the way you develop your applications:

You can download it from

``
http://web2py.com/examples/static/web2py.plugin.wiki.w2p
``:code

The idea behind **plugin_wiki** is that most applications include pages that are semi-static. These are pages that do not include complex custom logic. They contain structured text (think of a help page), images, audio, video, forms, or a set of standard components (comments, tags, charts, maps), etc. These pages may be public, require login or have other authorization restrictions. These pages may be linked by a menu or only be reachable via wizard form. **plugin_wiki** provides an easy way to add pages that fit in this category to your regular web2py applications.

In particular **plugin_wiki** provides:
``widget in plugin_wiki``:inxx

- A wiki-like interface that allows to add pages to your app and reference them by a slug. These pages (which we will refer to as wiki pages) have versions and are stored in the database.
- Public and private pages (require login). If a page requires login, it may also require that the user have a particular group membership.
- Three levels: 1,2,3. At level 1, pages can only include text, images, audio and video. At level 2, pages can also include widgets (these are components as defined in the previous section that can be embedded in wiki pages). At level 3, pages can also include web2py template code.
- A choice of editing pages with the markmin syntax or in HTML using a WYSIWYG editor.
- A collection of widgets: implemented as components. They are self documenting and they can be embedded as regular components in normal web2py views or, using a simplified syntax, into wiki pages.
- A set of special pages (``meta-code``, ``meta-menu``, etc.) that can be used to customize the plugin (for example define code the plugin should run, customize the menu, etc.)

------
The **welcome** app plus the **plugin_wiki** can be thought of as a development environment in itself that is suitable for building simple web applications such as a blog.
------

From here on we will assume the **plugin_wiki** is applied to a copy of the **welcome** scaffolding app.

The first thing you notice after installing the plugin is that it adds a new menu item called &#x27;&#x27;pages&#x27;&#x27;.

Click on the &#x27;&#x27;pages&#x27;&#x27; menu item and you will be redirected to the plugin action:

``
http://127.0.0.1:8000/myapp/plugin_wiki/index
``:code

[[image @///image/en8400.png center 480px]]

The plugin index page lists the pages created using the plugin itself and allows you to create new ones by choosing a &#x27;&#x27;slug&#x27;&#x27;. Try creating a ``home`` page. You will be redirected to

``
Item 2 Name http://link1.com

where the indentation determines the submenu structure. Each item is composed of the text of the menu item followed by a link. A link can be ``page:``&#x27;&#x27;slug&#x27;&#x27;. A link ``None`` does not link to any page. Extra spaces are ignored.

Here is another example:

``
Home             page:home
Search Engines   None
   Yahoo         http://yahoo.com
   Google        http://google.com
   Bing          http://bing.com
Help             page:help
``:code

This renders as follows:

[[image @///image/en8800.png center 480px]]

``meta-menu``:inxx ``meta-code``:inxx ``meta-header``:inxx ``meta-sidebar``:inxx ``meta-footer``:inxx
**meta-code** is another special page and it must contain web2py code. This is an extension of your models, and in fact you can put model code here. It is executed when &quot;models/plugin_wiki.py&quot; code is executed.

You can define tables in ``meta-code``.

For example, you can create a simple table &quot;friends&quot; by placing this in ``meta-code``:

``
db.define_table(&#x27;friend&#x27;,Field(&#x27;name&#x27;,requires=IS_NOT_EMPTY()))
``:code

and you can create a friend-management interface by embedding in a page of your choice the following code:
``jqGrid``:inxx

``
## List of friends
!`!!`!
name: jqgrid
table: friend
!`!!`!:widget

## New friend
!`!!`!
name: create
table: friend
!`!!`!:widget

``:code

The page has two headers (starting with #): &quot;List of friends&quot; and &quot;New friend&quot;. The page contains two widgets (under the corresponding headers): a jqgrid widget that lists friends and a create widget to add a new friend.
</pre></div>
    <div class="span6"><pre style="background-color: #F2DEDE;">``
@auth.requires_login()
def post():
    return dict(form=crud.create(db.comment),
                comments=db(db.comment).select())
``:code

and the corresponding &quot;views/comments/post.html&quot;

``
{{extend &#x27;layout.html&#x27;}}
{{for comment in comments:}}
&lt;div class=&quot;comment&quot;&gt;
  on {{=comment.posted_on}} {{=comment.posted_by.first_name}}
  says &lt;span class=&quot;comment_body&quot;&gt;{{=comment.body}}&lt;/span&gt;
&lt;/div&gt;
{{pass}}
{{=form}}
``:code

You can access it as usual at:

``
http://127.0.0.1:8000/test/comments/post
``:code

[[image @///image/en7900.png center 480px]]

So far there is nothing special in this action, but we can turn it into a component by defining a new view with extension &quot;.load&quot; that does not extend the layout.

Hence we create a &quot;views/comments/post.load&quot;:

``
{{#extend &#x27;layout.html&#x27; &lt;- notice this is commented out!}}
The rules above do not solve the problem of plugin versions and dependencies. Th
#### Component plugins
``component plugin``:inxx

Component plugins are plugins that define components. Components usually access the database and define with their own models.

Here we turn the previous ``comments`` component into a ``comments_plugin`` by using the same code we wrote before, but following all of the previous rules.

First, we create a model called &quot;models/plugin_comments.py&quot;:

``
db.define_table(&#x27;plugin_comments_comment&#x27;,
   Field(&#x27;body&#x27;,&#x27;text&#x27;, label=&#x27;Your comment&#x27;),
   Field(&#x27;posted_on&#x27;, &#x27;datetime&#x27;, default=request.now),
   Field(&#x27;posted_by&#x27;, db.auth_user, default=auth.user_id))
db.plugin_comments_comment.posted_on.writable=False
db.plugin_comments_comment.posted_on.readable=False
db.plugin_comments_comment.posted_by.writable=False
db.plugin_comments_comment.posted_by.readable=False

def plugin_comments():
    return LOAD(&#x27;plugin_comments&#x27;,&#x27;post&#x27;,ajax=True)
``:code
(notice the last two lines define a function that will simplify the embedding of the plugin)

Second, we define a &quot;controllers/plugin_comments.py&quot;

``
@auth.requires_login()
def post():
    comment = db.plugin_comments_comment
    return dict(form=crud.create(comment),
                comments=db(comment).select())
``:code

Third, we create a view called &quot;views/plugin_comments/post.load&quot;:

``
{{for comment in comments:}}
&lt;div class=&quot;comment&quot;&gt;
  on {{=comment.posted_on}} {{=comment.posted_by.first_name}}
  says &lt;span class=&quot;comment_body&quot;&gt;{{=comment.body}}&lt;/span&gt;
&lt;/div&gt;
{{pass}}
{{=form}}
``:code

Now we can use **admin** to pack the plugin for distribution. Admin will save this plugin as:

``
web2py.plugin.comments.w2p
``:code

We can use the plugin in any view by simply installing the plugin via the **edit** page in **admin** and adding this to our own views

``
{{=plugin_comments()}}
``:code

Of course we can make the plugin more sophisticated by having components that take parameters and configuration options. The more complex the components, the more difficult it becomes to avoid name collisions. The Plugin Manager described below is designed to avoid this problem.

#### Plugin manager
When the plugin is defined, the PluginManager must take arguments: the plugin na
Layout plugins are simpler than component plugins because usually they do not contain code, but only views and static files. Yet you should still follow  good practice:

First, create a folder called &quot;static/plugin_layout_&#x27;&#x27;name&#x27;&#x27;/&quot; (where name is the name of your layout) and place all your static files there.

Second, create a layout file called &quot;views/plugin_layout_&#x27;&#x27;name&#x27;&#x27;/layout.html&quot; that contains your layout and links the images, CSS and JavaScript files in &quot;static/plugin_layout_&#x27;&#x27;name&#x27;&#x27;/&quot;

Third, modify the &quot;views/layout.html&quot; so that it simply reads:

``
{{extend &#x27;plugin_layout_name/layout.html&#x27;}}
{{include}}
``:code

The benefit of this design is that users of this plugin can install multiple layouts and choose which one to apply simply by editing &quot;views/layout.html&quot;. Moreover, &quot;views/layout.html&quot; will not be packed by **admin** together with the plugin, so there is no risk that the plugin will override the user&#x27;s code in the previously installed layout.

### ``plugin_wiki``
``plugin_wiki``:inxx ``wiki``:inxx

-----
DISCLAIMER: plugin_wiki is still very much under development and therefore we do not promise backward compatibility to the same level as for web2py core functions.
-----

**plugin_wiki** is a plugin on steroids.  What we mean is that it defines multiple useful components and it may change the way you develop your applications:

You can download it from

``
http://web2py.com/examples/static/web2py.plugin.wiki.w2p
``:code

The idea behind **plugin_wiki** is that most applications include pages that are semi-static. These are pages that do not include complex custom logic. They contain structured text (think of a help page), images, audio, video, crud forms, or a set of standard components (comments, tags, charts, maps), etc. These pages may be public, require login or have other authorization restrictions. These pages may be linked by a menu or only be reachable via wizard form. **plugin_wiki** provides an easy way to add pages that fit in this category to your regular web2py applications.

In particular **plugin_wiki** provides:
``widget in plugin_wiki``:inxx

- A wiki-like interface that allows to add pages to your app and reference them by a slug. These pages (which we will refer to as wiki pages) have versions and are stored in the database.
- Public and private pages (require login). If a page requires login, it may also require that the user have a particular group membership.
- Three levels: 1,2,3. At level 1, pages can only include text, images, audio and video. At level 2, pages can also include widgets (these are components as defined in the previous section that can be embedded in wiki pages). At level 3, pages can also include web2py template code.
- A choice of editing pages with the markmin syntax or in HTML using a WYSIWYG editor.
- A collection of widgets: implemented as components. They are self documenting and they can be embedded as regular components in normal web2py views or, using a simplified syntax, into wiki pages.
- A set of special pages (``meta-code``, ``meta-menu``, etc.) that can be used to customize the plugin (for example define code the plugin should run, customize the menu, etc.)

------
The **welcome** app plus the **plugin_wiki** can be thought of as a development environment in itself that is suitable for building simple web applications such as a blog.
------

From here on we will assume the **plugin_wiki** is applied to a copy of the **welcome** scaffolding app.

The first thing you notice after installing the plugin is that it adds a new menu item called &#x27;&#x27;pages&#x27;&#x27;.

Click on the &#x27;&#x27;pages&#x27;&#x27; menu item and you will be redirected to the plugin action:

``
http://127.0.0.1:8000/myapp/plugin_wiki/index
``:code

[[image @///image/en8400.png center 480px]]

The plugin index page lists the pages created using the plugin itself and allows you to create new ones by choosing a &#x27;&#x27;slug&#x27;&#x27;. Try creating a ``home`` page. You will be redirected to

``
Item 2 Name http://link1.com

where the indentation determines the submenu structure. Each item is composed of the text of the menu item followed by a link. A link can be ``page:``&#x27;&#x27;slug&#x27;&#x27;. A link ``None`` does not link to any page. Extra spaces are ignored.

Here is another example:

``
Home             page:home
Search Engines   None
   Yahoo         http://yahoo.com
   Google        http://google.com
   Bing          http://bing.com
Help             page:help
``:code

This renders as follows:

[[image @///image/en8800.png center 480px]]

``meta-menu``:inxx ``meta-code``:inxx ``meta-header``:inxx ``meta-sidebar``:inxx ``meta-footer``:inxx
**meta-code** is another special page and it must contain web2py code. This is an extension of your models, and in fact you can put model code here. It is executed when &quot;models/plugin_wiki.py&quot; code is executed.

You can define tables in ``meta-code``.

For example, you can create a simple table &quot;friends&quot; by placing this in ``meta-code``:

``
db.define_table(&#x27;friend&#x27;,Field(&#x27;name&#x27;,requires=IS_NOT_EMPTY()))
``:code

and you can create a friend-management interface by embedding in a page of your choice the following code:
``jqGrid``:inxx ``CRUD``:inxx

``
## List of friends
!`!!`!
name: jqgrid
table: friend
!`!!`!:widget

## New friend
!`!!`!
name: create
table: friend
!`!!`!:widget

``:code

The page has two headers (starting with #): &quot;List of friends&quot; and &quot;New friend&quot;. The page contains two widgets (under the corresponding headers): a jqgrid widget that lists friends and a crud create widget to add a new friend.
</pre></div>
</div>
<hr />

<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/df4ca32e45895ff30b9ff2465b997c895a46d525">df4ca32</a><ul><li>Date : 2013-01-01</li><li>fixed plugin_comments shots</li></ul></li></ul>
<div class="row-fluid" id="com_df4ca32e45895ff30b9ff2465b997c895a46d525">
    <div class="span6"><pre style="background-color: #DFF0D8;">``
db.define_table(&#x27;comment_post&#x27;,
   Field(&#x27;body&#x27;,&#x27;text&#x27;,label=&#x27;Your comment&#x27;),
   auth.signature)
``:code

one action in &quot;controllers/comments.py&quot;

``
@auth.requires_login()
def post():
    return dict(form=SQLFORM(db.comment_post).process(),
                comments=db(db.comment_post).select())
``:code

and the corresponding &quot;views/comments/post.html&quot;

``
{{extend &#x27;layout.html&#x27;}}
{{for post in comments:}}
&lt;div class=&quot;post&quot;&gt;
  On {{=post.created_on}} {{=post.created_by.first_name}}
  says &lt;span class=&quot;post_body&quot;&gt;{{=post.body}}&lt;/span&gt;
&lt;/div&gt;
{{pass}}
{{=form}}
``:code

You can access it as usual at:

``
http://127.0.0.1:8000/test/comments/post
``:code

So far there is nothing special in this action, but we can turn it into a component by defining a new view with extension &quot;.load&quot; that does not extend the layout.

Hence we create a &quot;views/comments/post.load&quot;:

``
{{for post in comments:}}
&lt;div class=&quot;post&quot;&gt;
  On {{=post.created_on}} {{=post.created_by.first_name}}
  says &lt;blockquote class=&quot;post_body&quot;&gt;{{=post.body}}&lt;/blockquote&gt;
&lt;/div&gt;
{{pass}}
{{=form}}
``:code

We can access it at the URL

``
http://127.0.0.1:8000/test/comments/post.load
``:code

This is a component that we can embed into any other page by simply doing

``
{{=LOAD(&#x27;comments&#x27;,&#x27;post.load&#x27;,ajax=True)}}
``:code

For example in &quot;controllers/default.py&quot; we can edit

``
def index():
    return dict()
``:code

and in the corresponding view add the component:

``
{{extend &#x27;layout.html&#x27;}}
{{=LOAD(&#x27;comments&#x27;,&#x27;post.load&#x27;,ajax=True)}}
``:code

Visiting the page

``
http://127.0.0.1:8000/test/default/index
``:code

will show the normal content and the comments component:

[[image @///image/en8100.png center 480px]]

The ``{{=LOAD(...)}}`` component is rendered as follows:

``
&lt;script type=&quot;text/javascript&quot;&gt;&lt;!--
web2py_component(&quot;/test/comment/post.load&quot;,&quot;c282718984176&quot;)
//--&gt;&lt;/script&gt;&lt;div id=&quot;c282718984176&quot;&gt;loading...&lt;/div&gt;
``:code

(the actual generated code depends on the options passed to the LOAD function).

The ``web2py_component(url,id)`` function is defined in &quot;web2py_ajax.html&quot; and it performs all the magic: it calls the ``url`` via Ajax and embeds the response into the DIV with corresponding ``id``; it traps every form submission into the DIV and submits those forms via Ajax. The Ajax target is always the DIV itself.

The full signature of the LOAD helper is the following:

``
LOAD(c=None, f=&#x27;index&#x27;, args=[], vars={},
     extension=None, target=None,
Plugin models can only define objects with names that start with
**Rule 3**:
Plugin models can only define session variables with names that start with
- ``session.plugin_``&#x27;&#x27;name&#x27;&#x27;
- ``session.Plugin``&#x27;&#x27;Name&#x27;&#x27;

**Rule 4**:
Plugins should include license and documentation. These should be placed in:
- ``static/plugin_``&#x27;&#x27;name&#x27;&#x27;``/license.html``
- ``static/plugin_``&#x27;&#x27;name&#x27;&#x27;``/about.html``

**Rule 5**:
The plugin can only rely on the existence of the global objects defined in scaffolding &quot;db.py&quot;, i.e.

- a database connection called ``db``
- an ``Auth`` instance called ``auth``
- a ``Crud`` instance called ``crud``
- a ``Service`` instance called ``service``

Some plugins may be more sophisticated and have a configuration parameter in case more than one db instance exists.

**Rule 6**:
If a plugin needs configuration parameters, these should be set via a PluginManager as described below.
``PluginManager``:inxx

By following the above rules we can make sure that:
- **admin** recognizes all the ``plugin_``&#x27;&#x27;name&#x27;&#x27; files and folder as part of a single entity.
- plugins do not interfere with each other.

The rules above do not solve the problem of plugin versions and dependencies. That is beyond our scope.


#### Component plugins
``component plugin``:inxx

Component plugins are plugins that define components. Components usually access the database and define with their own models.

Here we turn the previous ``comments`` component into a ``comments_plugin`` by using the same code we wrote before, but following all of the previous rules.

First, we create a model called &quot;models/plugin_comments.py&quot;:

``
db.define_table(&#x27;plugin_comments_comment&#x27;,
   Field(&#x27;body&#x27;,&#x27;text&#x27;, label=&#x27;Your comment&#x27;),
   auth.signature)

def plugin_comments():
    return LOAD(&#x27;plugin_comments&#x27;,&#x27;post&#x27;,ajax=True)
``:code
(notice the last two lines define a function that will simplify the embedding of the plugin)

Second, we define a &quot;controllers/plugin_comments.py&quot;

``
def post():
    if not auth.user:
        return A(&#x27;login to comment&#x27;,_href=URL(&#x27;default&#x27;,&#x27;user/login&#x27;))
    comment = db.plugin_comments_comment
    return dict(form=SQLFORM(comment).process(),
                comments=db(comment).select())
``:code

Third, we create a view called &quot;views/plugin_comments/post.load&quot;:

``
{{for comment in comments:}}
&lt;div class=&quot;comment&quot;&gt;
  on {{=comment.created_on}} {{=comment.created_by.first_name}}
  says &lt;span class=&quot;comment_body&quot;&gt;{{=comment.body}}&lt;/span&gt;
&lt;/div&gt;
{{pass}}
{{=form}}
``:code

Now we can use **admin** to pack the plugin for distribution. Admin will save this plugin as:

``
web2py.plugin.comments.w2p
``:code

We can use the plugin in any view by simply installing the plugin via the **edit** page in **admin** and adding this to our own views

``
{{=plugin_comments()}}
``:code

Of course we can make the plugin more sophisticated by having components that take parameters and configuration options. The more complex the components, the more difficult it becomes to avoid name collisions. The Plugin Manager described below is designed to avoid this problem.

#### Plugin manager

The ``PluginManager`` is a class defined in ``gluon.tools``. Before we explain how it works inside, we will explain how to use it.

Here we consider the previous ``comments_plugin`` and we make it better. We want to be able to customize:

``
db.plugin_comments_comment.body.label
``:code

without having to edit the plugin code itself.

Here is how we can do it:

First, rewrite the plugin &quot;models/plugin_comments.py&quot; in this way:

``
def _():
    from gluon.tools import PluginManager
    plugins = PluginManager(&#x27;comments&#x27;, body_label=&#x27;Your comment&#x27;)

    db.define_table(&#x27;plugin_comments_comment&#x27;,
        Field(&#x27;body&#x27;,&#x27;text&#x27;,label=plugins.comments.body_label),
        auth.signature)
    return lambda: LOAD(&#x27;plugin_comments&#x27;,&#x27;post.load&#x27;,ajax=True)
plugin_comments = _()
``:code

Notice how all the code except the table definition is encapsulated in a single function called ``_`` so that it does not pollute the global namespace. Also notice how the function creates an instance of a ``PluginManager``.

Now in any other model in your app, for example in &quot;models/db.py&quot;, you can configure this plugin as follows:

``
from gluon.tools import PluginManager
plugins = PluginManager()
plugins.comments.body_label = T(&#x27;Post a comment&#x27;)
``:code

-----
The ``plugins`` object is already instantiated in the default scaffolding app in &quot;models/db.py&quot;
-----

The PluginManager object is a thread-level singleton Storage object of Storage objects. That means you can instantiate as many as you like within the same application but (whether they have the same name or not) they act as if there were a single PluginManager instance.

In particular each plugin file can make its own PluginManager object and register itself and its default parameters with it:

``
plugins = PluginManager(&#x27;name&#x27;, param1=&#x27;value&#x27;, param2=&#x27;value&#x27;)
``:code

You can override these parameters elsewhere (for example in &quot;models/db.py&quot;) with the code:

``
plugins = PluginManager()
plugins.name.param1 = &#x27;other value&#x27;
``:code

You can configure multiple plugins in one place.

``
plugins = PluginManager()
plugins.name.param1 = &#x27;...&#x27;
plugins.name.param2 = &#x27;...&#x27;
plugins.name1.param3 = &#x27;...&#x27;
plugins.name2.param4 = &#x27;...&#x27;
plugins.name3.param5 = &#x27;...&#x27;
``:code

-----
When the plugin is defined, the PluginManager must take arguments: the plugin name and optional named arguments which are default parameters. However, when the plugins are configured, the PluginManager constructor must take no arguments. The configuration must precede the definition of the plugin (i.e. it must be in a model file that comes first alphabetically).
-----

#### Layout plugins
``layout plugin``:inxx

Layout plugins are simpler than component plugins because usually they do not contain code, but only views and static files. Yet you should still follow  good practice:

First, create a folder called &quot;static/plugin_layout_&#x27;&#x27;name&#x27;&#x27;/&quot; (where name is the name of your layout) and place all your static files there.

Second, create a layout file called &quot;views/plugin_layout_&#x27;&#x27;name&#x27;&#x27;/layout.html&quot; that contains your layout and links the images, CSS and JavaScript files in &quot;static/plugin_layout_&#x27;&#x27;name&#x27;&#x27;/&quot;

Third, modify the &quot;views/layout.html&quot; so that it simply reads:

``
{{extend &#x27;plugin_layout_name/layout.html&#x27;}}
{{include}}
``:code

The benefit of this design is that users of this plugin can install multiple layouts and choose which one to apply simply by editing &quot;views/layout.html&quot;. Moreover, &quot;views/layout.html&quot; will not be packed by **admin** together with the plugin, so there is no risk that the plugin will override the user&#x27;s code in the previously installed layout.

#### Plugins repositories

While there is no single repository of web2py plugins you can find many of them at one of the following to URLs:

``
http://dev.s-cubism.com/web2py_plugins
http://web2py.com/plugins
http://web2py.com/layouts
``:code

Here is a screenshot from the s-cubism repository:

[[image @///image/plugins.png center 480px]]

</pre></div>
    <div class="span6"><pre style="background-color: #F2DEDE;">``
db.define_table(&#x27;post&#x27;,
   Field(&#x27;body&#x27;,&#x27;text&#x27;,label=&#x27;Your comment&#x27;),
   Field(&#x27;posted_on&#x27;,&#x27;datetime&#x27;,default=request.now),
   Field(&#x27;posted_by&#x27;,db.auth_user,default=auth.user_id))
db.post.posted_on.writable = db.post.posted_on.readable = False
db.post.posted_by.writable = db.post.posted_by.readable = False
``:code

one action in &quot;controllers/comments.py&quot;

``
@auth.requires_login()
def post():
    return dict(form=SQLFORM(db.post).process(),
                comments=db(db.post).select())
``:code

and the corresponding &quot;views/comments/post.html&quot;

``
{{extend &#x27;layout.html&#x27;}}
{{for post in comments:}}
&lt;div class=&quot;post&quot;&gt;
  on {{=post.posted_on}} {{=post.posted_by.first_name}}
  says &lt;span class=&quot;post_body&quot;&gt;{{=post.body}}&lt;/span&gt;
&lt;/div&gt;
{{pass}}
{{=form}}
``:code

You can access it as usual at:

``
http://127.0.0.1:8000/test/comments/post
``:code

[[image @///image/en7900.png center 480px]]

So far there is nothing special in this action, but we can turn it into a component by defining a new view with extension &quot;.load&quot; that does not extend the layout.

Hence we create a &quot;views/comments/post.load&quot;:

``
{{#extend &#x27;layout.html&#x27; &lt;- notice this is commented out!}}
{{for post in comments:}}
&lt;div class=&quot;post&quot;&gt;
  on {{=post.posted_on}} {{=post.posted_by.first_name}}
  says &lt;span class=&quot;post_body&quot;&gt;{{=post.body}}&lt;/span&gt;
&lt;/div&gt;
{{pass}}
{{=form}}
``:code

We can access it at the URL

``
http://127.0.0.1:8000/test/comments/post.load
``:code

and it will look like this:

[[image @///image/en8000.png center 480px]]

This is a component that we can embed into any other page by simply doing

``
{{=LOAD(&#x27;comments&#x27;,&#x27;post.load&#x27;,ajax=True)}}
``:code

For example in &quot;controllers/default.py&quot; we can edit

``
def index():
    return dict()
``:code

and in the corresponding view add the component:

``
{{extend &#x27;layout.html&#x27;}}
&lt;p&gt;{{=&#x27;bla &#x27;*100}}&lt;/p&gt;
{{=LOAD(&#x27;comments&#x27;,&#x27;post.load&#x27;,ajax=True)}}
``:code

Visiting the page

``
http://127.0.0.1:8000/test/default/index
``:code

will show the normal content and the comments component:

[[image @///image/en8100.png center 480px]]

The ``{{=LOAD(...)}}`` component is rendered as follows:

``
&lt;script type=&quot;text/javascript&quot;&gt;&lt;!--
web2py_component(&quot;/test/comment/post.load&quot;,&quot;c282718984176&quot;)
//--&gt;&lt;/script&gt;&lt;div id=&quot;c282718984176&quot;&gt;loading...&lt;/div&gt;
``:code

(the actual generated code depends on the options passed to the LOAD function).

The ``web2py_component(url,id)`` function is defined in &quot;web2py_ajax.html&quot; and it performs all the magic: it calls the ``url`` via Ajax and embeds the response into the DIV with corresponding ``id``; it traps every form submission into the DIV and submits those forms via Ajax. The Ajax target is always the DIV itself.

The full signature of the LOAD helper is the following:

``
LOAD(c=None, f=&#x27;index&#x27;, args=[], vars={},
     extension=None, target=None,
Plugin models can only define objects with names that start with
**Rule 3**:
Plugin models can only define session variables with names that start with
- ``session.plugin_``&#x27;&#x27;name&#x27;&#x27;
- ``session.Plugin``&#x27;&#x27;Name&#x27;&#x27;

**Rule 4**:
Plugins should include license and documentation. These should be placed in:
- ``static/plugin_``&#x27;&#x27;name&#x27;&#x27;``/license.html``
- ``static/plugin_``&#x27;&#x27;name&#x27;&#x27;``/about.html``

**Rule 5**:
The plugin can only rely on the existence of the global objects defined in scaffolding &quot;db.py&quot;, i.e.

- a database connection called ``db``
- an ``Auth`` instance called ``auth``
- a ``Crud`` instance called ``crud``
- a ``Service`` instance called ``service``

Some plugins may be more sophisticated and have a configuration parameter in case more than one db instance exists.

**Rule 6**:
If a plugin needs configuration parameters, these should be set via a PluginManager as described below.
``PluginManager``:inxx

By following the above rules we can make sure that:
- **admin** recognizes all the ``plugin_``&#x27;&#x27;name&#x27;&#x27; files and folder as part of a single entity.
- plugins do not interfere with each other.

The rules above do not solve the problem of plugin versions and dependencies. That is beyond our scope.

#### Component plugins
``component plugin``:inxx

Component plugins are plugins that define components. Components usually access the database and define with their own models.

Here we turn the previous ``comments`` component into a ``comments_plugin`` by using the same code we wrote before, but following all of the previous rules.

First, we create a model called &quot;models/plugin_comments.py&quot;:

``
db.define_table(&#x27;plugin_comments_comment&#x27;,
   Field(&#x27;body&#x27;,&#x27;text&#x27;, label=&#x27;Your comment&#x27;),
   Field(&#x27;posted_on&#x27;, &#x27;datetime&#x27;, default=request.now),
   Field(&#x27;posted_by&#x27;, db.auth_user, default=auth.user_id))
db.plugin_comments_comment.posted_on.writable=False
db.plugin_comments_comment.posted_on.readable=False
db.plugin_comments_comment.posted_by.writable=False
db.plugin_comments_comment.posted_by.readable=False

def plugin_comments():
    return LOAD(&#x27;plugin_comments&#x27;,&#x27;post&#x27;,ajax=True)
``:code
(notice the last two lines define a function that will simplify the embedding of the plugin)

Second, we define a &quot;controllers/plugin_comments.py&quot;

``
@auth.requires_login()
def post():
    comment = db.plugin_comments_comment
    return dict(form=SQLFORM(comment).process(),
                comments=db(comment).select())
``:code

Third, we create a view called &quot;views/plugin_comments/post.load&quot;:

``
{{for comment in comments:}}
&lt;div class=&quot;comment&quot;&gt;
  on {{=comment.posted_on}} {{=comment.posted_by.first_name}}
  says &lt;span class=&quot;comment_body&quot;&gt;{{=comment.body}}&lt;/span&gt;
&lt;/div&gt;
{{pass}}
{{=form}}
``:code

Now we can use **admin** to pack the plugin for distribution. Admin will save this plugin as:

``
web2py.plugin.comments.w2p
``:code

We can use the plugin in any view by simply installing the plugin via the **edit** page in **admin** and adding this to our own views

``
{{=plugin_comments()}}
``:code

Of course we can make the plugin more sophisticated by having components that take parameters and configuration options. The more complex the components, the more difficult it becomes to avoid name collisions. The Plugin Manager described below is designed to avoid this problem.

#### Plugin manager

The ``PluginManager`` is a class defined in ``gluon.tools``. Before we explain how it works inside, we will explain how to use it.

Here we consider the previous ``comments_plugin`` and we make it better. We want to be able to customize:

``
db.plugin_comments_comment.body.label
``:code

without having to edit the plugin code itself.

Here is how we can do it:

First, rewrite the plugin &quot;models/plugin_comments.py&quot; in this way:

``
db.define_table(&#x27;plugin_comments_comment&#x27;,
   Field(&#x27;body&#x27;,&#x27;text&#x27;,label=plugin_comments.comments.body_label),
   Field(&#x27;posted_on&#x27;, &#x27;datetime&#x27;, default=request.now),
   Field(&#x27;posted_by&#x27;, db.auth_user, default=auth.user_id))

def plugin_comments()
    from gluon.tools import PluginManager
    plugins = PluginManager(&#x27;comments&#x27;, body_label=&#x27;Your comment&#x27;)

    comment = db.plugin_comments_comment
    comment.label=plugins.comments.body_label
    comment.posted_on.writable=False
    comment.posted_on.readable=False
    comment.posted_by.writable=False
    comment.posted_by.readable=False
    return LOAD(&#x27;plugin_comments&#x27;,&#x27;post.load&#x27;,ajax=True)
``:code

Notice how all the code except the table definition is encapsulated in a single function. Also notice how the function creates an instance of a ``PluginManager``.

Now in any other model in your app, for example in &quot;models/db.py&quot;, you can configure this plugin as follows:

``
from gluon.tools import PluginManager
plugins = PluginManager()
plugins.comments.body_label = T(&#x27;Post a comment&#x27;)
``:code

-----
The ``plugins`` object is already instantiated in the default scaffolding app in &quot;models/db.py&quot;
-----

The PluginManager object is a thread-level singleton Storage object of Storage objects. That means you can instantiate as many as you like within the same application but (whether they have the same name or not) they act as if there were a single PluginManager instance.

In particular each plugin file can make its own PluginManager object and register itself and its default parameters with it:

``
plugins = PluginManager(&#x27;name&#x27;, param1=&#x27;value&#x27;, param2=&#x27;value&#x27;)
``:code

You can override these parameters elsewhere (for example in &quot;models/db.py&quot;) with the code:

``
plugins = PluginManager()
plugins.name.param1 = &#x27;other value&#x27;
``:code

You can configure multiple plugins in one place.

``
plugins = PluginManager()
plugins.name.param1 = &#x27;...&#x27;
plugins.name.param2 = &#x27;...&#x27;
plugins.name1.param3 = &#x27;...&#x27;
plugins.name2.param4 = &#x27;...&#x27;
plugins.name3.param5 = &#x27;...&#x27;
``:code

-----
When the plugin is defined, the PluginManager must take arguments: the plugin name and optional named arguments which are default parameters. However, when the plugins are configured, the PluginManager constructor must take no arguments. The configuration must precede the definition of the plugin (i.e. it must be in a model file that comes first alphabetically).
-----

#### Layout plugins
``layout plugin``:inxx

Layout plugins are simpler than component plugins because usually they do not contain code, but only views and static files. Yet you should still follow  good practice:

First, create a folder called &quot;static/plugin_layout_&#x27;&#x27;name&#x27;&#x27;/&quot; (where name is the name of your layout) and place all your static files there.

Second, create a layout file called &quot;views/plugin_layout_&#x27;&#x27;name&#x27;&#x27;/layout.html&quot; that contains your layout and links the images, CSS and JavaScript files in &quot;static/plugin_layout_&#x27;&#x27;name&#x27;&#x27;/&quot;

Third, modify the &quot;views/layout.html&quot; so that it simply reads:

``
{{extend &#x27;plugin_layout_name/layout.html&#x27;}}
{{include}}
``:code

The benefit of this design is that users of this plugin can install multiple layouts and choose which one to apply simply by editing &quot;views/layout.html&quot;. Moreover, &quot;views/layout.html&quot; will not be packed by **admin** together with the plugin, so there is no risk that the plugin will override the user&#x27;s code in the previously installed layout.
</pre></div>
</div>
<hr />

<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/097d699dc16179206ccb7e4aee863d6523cd471c">097d699</a><ul><li>Date : 2012-12-27</li><li>fixed typo, thanks Andrew</li></ul></li></ul>
<div class="row-fluid" id="com_097d699dc16179206ccb7e4aee863d6523cd471c">
    <div class="span6"><pre style="background-color: #DFF0D8;">The benefit of this design is that users of this plugin can install multiple layouts and choose which one to apply simply by editing &quot;views/layout.html&quot;. Moreover, &quot;views/layout.html&quot; will not be packed by **admin** together with the plugin, so there is no risk that the plugin will override the user&#x27;s code in the previously installed layout.
</pre></div>
    <div class="span6"><pre style="background-color: #F2DEDE;">The benefit of this design is that users of this plugin can install multiple layouts and choose which one to apply simply by editing &quot;views/layout.html&quot;. Moreover, &quot;views/layout.html&quot; will not be packed by **admin** together with the plugin, so there is no risk that the plugin will override the user&#x27;s code in the previously installed layout.

</pre></div>
</div>
<hr />

<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/010aa0543ab690b5d1930c4b7d8584b4eb0fa73f">010aa05</a><ul><li>Date : 2012-10-08</li><li>timeout and times LOAD options</li></ul></li></ul>
<div class="row-fluid" id="com_010aa0543ab690b5d1930c4b7d8584b4eb0fa73f">
    <div class="span6"><pre style="background-color: #DFF0D8;">## Components and plugins
``component``:inxx
``plugin``:inxx

Components and plugins are relatively new features of web2py, and there is some disagreement between developers about what they are and what they should be. Most of the confusion stems from the different uses of these terms in other software projects and from the fact that developers are still working to finalize the specifications.

However, plugin support is an important feature and we need to provide some definitions. These definitions are not meant to be final, just consistent with the programming patterns we want to discuss in this chapter.

We will try to address two issues here:

- How can we build modular applications that minimize server load and maximize code reuse?
- How can we distribute pieces of code in a more or less plugin-and-play fashion?

&#x27;&#x27;Components&#x27;&#x27; address the first issue; &#x27;&#x27;plugins&#x27;&#x27; address the second.

### Components
``load``:inxx
``LOAD``:inxx
``Ajax``:inxx

------
A **component** is a functionally autonomous part of a web page.
------

A component may be composed of modules, controllers and views, but there is no strict requirement other than, when embedded in a web page, it must be localized within an html tag (for example a DIV, a SPAN, or an IFRAME) and it must perform its task independently of the rest of the page. We are specifically interested in components that are loaded in the page and communicate with the component controller function via Ajax.

An example of a component is a &quot;comments component&quot; that is contained into a DIV and shows users&#x27; comments and a post-new-comment form. When the form is submitted, it is sent to the server via Ajax, the list is updated, and the comment is stored server-side in the database. The DIV content is refreshed without reloading the rest of the page.

The web2py LOAD function makes this easy to do without explicit JavaScript/Ajax knowledge or programming.

and in the corresponding view add the component:

Visiting the page

``
http://127.0.0.1:8000/test/default/index
``:code

will show the normal content and the comments component:

[[image @///image/en8100.png center 480px]]

The ``{{=LOAD(...)}}`` component is rendered as follows:

``
&lt;script type=&quot;text/javascript&quot;&gt;&lt;!--
web2py_component(&quot;/test/comment/post.load&quot;,&quot;c282718984176&quot;)
//--&gt;&lt;/script&gt;&lt;div id=&quot;c282718984176&quot;&gt;loading...&lt;/div&gt;
``:code

(the actual generated code depends on the options passed to the LOAD function).

The ``web2py_component(url,id)`` function is defined in &quot;web2py_ajax.html&quot; and it performs all the magic: it calls the ``url`` via Ajax and embeds the response into the DIV with corresponding ``id``; it traps every form submission into the DIV and submits those forms via Ajax. The Ajax target is always the DIV itself.

The full signature of the LOAD helper is the following:

``
LOAD(c=None, f=&#x27;index&#x27;, args=[], vars={},
     extension=None, target=None,
     ajax=False, ajax_trap=False,
     url=None,user_signature=False,
     timeout=None, times=1,
     content=&#x27;loading...&#x27;,**attr):
``:code

Here:
- the first two arguments ``c`` and ``f`` are the controller and the function that we want to call respectively.
- ``args`` and ``vars`` are the arguments and variables that we want to pass to the function. The former is a list, the latter is a dictionary.
- ``extension`` is an optional extension. Notice that the extension can also be passed as part of the function as in ``f=&#x27;index.load&#x27;``.
- ``target`` is the ``id`` of the target DIV. If it is not specified a random target ``id`` is generated.
- ``ajax`` should be set to ``True`` if the DIV has to be filled via Ajax and to ``False`` if the DIV has to be filled before the current page is returned (thus avoiding the Ajax call).
- ``ajax_trap=True`` means that any form submission in the DIV must be captured and submitted via Ajax, and the response must be rendered inside the DIV. ``ajax_trap=False`` indicates that forms must be submitted normally, thus reloading the entire page. ``ajax_trap`` is ignored and assumed to be ``True`` if ``ajax=True``.
- ``url``, if specified, overrides the values of ``c``, ``f``, ``args``, ``vars``, and ``extension`` and loads the component at the ``url``. It is used to load as components pages served by other applications (which my or may not be created with web2py).
- ``user_signature`` defaults to False but, if you are logged in, it should be set to True. This will make sure the ajax callback is digitally signed. This is documented in chapter 4.
- ``times`` specifies how many times the component is to be requested. Use &quot;infinity&quot; to keep loading the component continuously. This option is useful for triggering regular routines for a given document request.
- ``timeout`` sets the time to wait in milliseconds before starting the request or the frequency if ``times`` is greater than 1.
- ``content`` is the content to be displayed while performing the ajax call. It can be a helper as in ``content=IMG(..)``.
- optional ``**attr`` (attributes) can be passed to the contained ``DIV``.
</pre></div>
    <div class="span6"><pre style="background-color: #F2DEDE;">
## Components and plugins
``component``:inxx
``plugin``:inxx

Components and plugins are relatively new features of web2py, and there is some disagreement between developers about what they are and what they should be. Most of the confusion stems from the different uses of these terms in other software projects and from the fact that developers are still working to finalize the specifications.

However, plugin support is an important feature and we need to provide some definitions. These definitions are not meant to be final, just consistent with the programming patterns we want to discuss in this chapter.

We will try to address two issues here:

- How can we build modular applications that minimize server load and maximize code reuse?
- How can we distribute pieces of code in a more or less plugin-and-play fashion?

&#x27;&#x27;Components&#x27;&#x27; address the first issue; &#x27;&#x27;plugins&#x27;&#x27; address the second.

### Components
``load``:inxx
``LOAD``:inxx
``Ajax``:inxx

------
A **component** is a functionally autonomous part of a web page.
------

A component may be composed of modules, controllers and views, but there is no strict requirement other than, when embedded in a web page, it must be localized within an html tag (for example a DIV, a SPAN, or an IFRAME) and it must perform its task independently of the rest of the page. We are specifically interested in components that are loaded in the page and communicate with the component controller function via Ajax.

An example of a component is a &quot;comments component&quot; that is contained into a DIV and shows users&#x27; comments and a post-new-comment form. When the form is submitted, it is sent to the server via Ajax, the list is updated, and the comment is stored server-side in the database. The DIV content is refreshed without reloading the rest of the page.

The web2py LOAD function makes this easy to do without explicit JavaScript/Ajax knowledge or programming.

and in the corresponding view add the component:

Visiting the page

``
http://127.0.0.1:8000/test/default/index
``:code

will show the normal content and the comments component:

[[image @///image/en8100.png center 480px]]

The ``{{=LOAD(...)}}`` component is rendered as follows:

``
&lt;script type=&quot;text/javascript&quot;&gt;&lt;!--
web2py_component(&quot;/test/comment/post.load&quot;,&quot;c282718984176&quot;)
//--&gt;&lt;/script&gt;&lt;div id=&quot;c282718984176&quot;&gt;loading...&lt;/div&gt;
``:code

(the actual generated code depends on the options passed to the LOAD function).

The ``web2py_component(url,id)`` function is defined in &quot;web2py_ajax.html&quot; and it performs all the magic: it calls the ``url`` via Ajax and embeds the response into the DIV with corresponding ``id``; it traps every form submission into the DIV and submits those forms via Ajax. The Ajax target is always the DIV itself.

The full signature of the LOAD helper is the following:

``
LOAD(c=None, f=&#x27;index&#x27;, args=[], vars={},
     extension=None, target=None,
     ajax=False, ajax_trap=False,
     url=None,user_signature=False,
     content=&#x27;loading...&#x27;,**attr):
``:code

Here:
- the first two arguments ``c`` and ``f`` are the controller and the function that we want to call respectively.
- ``args`` and ``vars`` are the arguments and variables that we want to pass to the function. The former is a list, the latter is a dictionary.
- ``extension`` is an optional extension. Notice that the extension can also be passed as part of the function as in ``f=&#x27;index.load&#x27;``.
- ``target`` is the ``id`` of the target DIV. If it is not specified a random target ``id`` is generated.
- ``ajax`` should be set to ``True`` if the DIV has to be filled via Ajax and to ``False`` if the DIV has to be filled before the current page is returned (thus avoiding the Ajax call).
- ``ajax_trap=True`` means that any form submission in the DIV must be captured and submitted via Ajax, and the response must be rendered inside the DIV. ``ajax_trap=False`` indicates that forms must be submitted normally, thus reloading the entire page. ``ajax_trap`` is ignored and assumed to be ``True`` if ``ajax=True``.
- ``url``, if specified, overrides the values of ``c``, ``f``, ``args``, ``vars``, and ``extension`` and loads the component at the ``url``. It is used to load as components pages served by other applications (which my or may not be created with web2py).
- ``user_signature`` defaults to False but, if you are logged in, it should be set to True. This will make sure the ajax callback is digitally signed. This is documented in chapter 4.
- ``content`` is the content to be displayed while performing the ajax call. It can be a helper as in ``content=IMG(..)``.
- optional ``**attr`` (attributes) can be passed to the contained ``DIV``.
</pre></div>
</div>
<hr />

<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/77e0846262922b8d1f776f23ca079114677b4048">77e0846</a><ul><li>Date : 2012-12-28</li><li>fixed comment-&gt;post</li></ul></li></ul>
<div class="row-fluid" id="com_77e0846262922b8d1f776f23ca079114677b4048">
    <div class="span6"><pre style="background-color: #DFF0D8;">``
db.define_table(&#x27;post&#x27;,
   Field(&#x27;body&#x27;,&#x27;text&#x27;,label=&#x27;Your comment&#x27;),
   Field(&#x27;posted_on&#x27;,&#x27;datetime&#x27;,default=request.now),
   Field(&#x27;posted_by&#x27;,db.auth_user,default=auth.user_id))
db.post.posted_on.writable = db.post.posted_on.readable = False
db.post.posted_by.writable = db.post.posted_by.readable = False
``:code

one action in &quot;controllers/comments.py&quot;

``
@auth.requires_login()
def post():
    return dict(form=SQLFORM(db.post).process(),
                comments=db(db.post).select())
``:code

and the corresponding &quot;views/comments/post.html&quot;

``
{{extend &#x27;layout.html&#x27;}}
{{for post in comments:}}
&lt;div class=&quot;post&quot;&gt;
  on {{=post.posted_on}} {{=post.posted_by.first_name}}
  says &lt;span class=&quot;post_body&quot;&gt;{{=post.body}}&lt;/span&gt;
&lt;/div&gt;
{{pass}}
{{=form}}
``:code

You can access it as usual at:

``
http://127.0.0.1:8000/test/comments/post
``:code

[[image @///image/en7900.png center 480px]]

So far there is nothing special in this action, but we can turn it into a component by defining a new view with extension &quot;.load&quot; that does not extend the layout.

Hence we create a &quot;views/comments/post.load&quot;:

``
{{#extend &#x27;layout.html&#x27; &lt;- notice this is commented out!}}
{{for post in comments:}}
&lt;div class=&quot;post&quot;&gt;
  on {{=post.posted_on}} {{=post.posted_by.first_name}}
  says &lt;span class=&quot;post_body&quot;&gt;{{=post.body}}&lt;/span&gt;
&lt;/div&gt;
{{pass}}
{{=form}}
``:code
</pre></div>
    <div class="span6"><pre style="background-color: #F2DEDE;">``
db.define_table(&#x27;comment&#x27;,
   Field(&#x27;body&#x27;,&#x27;text&#x27;,label=&#x27;Your comment&#x27;),
   Field(&#x27;posted_on&#x27;,&#x27;datetime&#x27;,default=request.now),
   Field(&#x27;posted_by&#x27;,db.auth_user,default=auth.user_id))
db.comment.posted_on.writable=db.comment.posted_on.readable=False
db.comment.posted_by.writable=db.comment.posted_by.readable=False
``:code

one action in &quot;controllers/comments.py&quot;

``
@auth.requires_login()
def post():
    return dict(form=SQLFORM(db.comment).process(),
                comments=db(db.comment).select())
``:code

and the corresponding &quot;views/comments/post.html&quot;

``
{{extend &#x27;layout.html&#x27;}}
{{for comment in comments:}}
&lt;div class=&quot;comment&quot;&gt;
  on {{=comment.posted_on}} {{=comment.posted_by.first_name}}
  says &lt;span class=&quot;comment_body&quot;&gt;{{=comment.body}}&lt;/span&gt;
&lt;/div&gt;
{{pass}}
{{=form}}
``:code

You can access it as usual at:

``
http://127.0.0.1:8000/test/comments/post
``:code

[[image @///image/en7900.png center 480px]]

So far there is nothing special in this action, but we can turn it into a component by defining a new view with extension &quot;.load&quot; that does not extend the layout.

Hence we create a &quot;views/comments/post.load&quot;:

``
{{#extend &#x27;layout.html&#x27; &lt;- notice this is commented out!}}
{{for comment in comments:}}
&lt;div class=&quot;comment&quot;&gt;
  on {{=comment.posted_on}} {{=comment.posted_by.first_name}}
  says &lt;span class=&quot;comment_body&quot;&gt;{{=comment.body}}&lt;/span&gt;
&lt;/div&gt;
{{pass}}
{{=form}}
``:code
</pre></div>
</div>
<hr />

<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/ac4003f4349f9ee22c67309ceeb48de5539b0308">ac4003f</a><ul><li>Date : 2012-09-01</li><li>added lots of new features to book</li></ul></li></ul>
<div class="row-fluid" id="com_ac4003f4349f9ee22c67309ceeb48de5539b0308">
    <div class="span6"><pre style="background-color: #DFF0D8;">If you call an action via Ajax and you want the action to force a redirect of the parent page you can do it with

``
redirect(url,type=&#x27;auto&#x27;)
``:code

Because Ajax post does not support multipart forms, i.e. file uploads, upload fields will not work with the LOAD component. You could be fooled into thinking it would work because upload fields will function normally if POST is done from the individual component&#x27;s .load view. Instead, uploads are done with ajax-compatible 3rd-party widgets and web2py manual upload store commands.
</pre></div>
    <div class="span6"><pre style="background-color: #F2DEDE;">*Please note:*
Because Ajax post does not support multipart forms, i.e. file uploads, upload fields will not work with the LOAD component. You could be fooled into thinking it would work because upload fields will function normally if POST is done from the individual component&#x27;s .load view. Instead, uploads are done with ajax-compatible 3rd-party widgets and web2py manual upload store commands.
</pre></div>
</div>
<hr />


        
      </div>

      <div id="push"></div>
    </div>

    <div id="footer">
      <div class="container-fluid">
          <div class="copyright pull-left">Copyright &#169; 2013</div>
          <div id="poweredBy" class="pull-right">
              Powered by
              <a href="http://www.web2py.com/">web2py</a>
          </div>
      </div>
    </div>
<script src="static/js/bootstrap.min.js"></script>
<script src="static/js/web2py_bootstrap.js"></script>
</body>
</html>
