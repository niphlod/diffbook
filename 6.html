<!DOCTYPE html>
<!-- paulirish.com/2008/conditional-stylesheets-vs-css-hacks-answer-neither/ -->
<!--[if lt IE 7]><html class="ie ie6 ie-lte9 ie-lte8 ie-lte7 no-js" lang="en-us"> <![endif]-->
<!--[if IE 7]><html class="ie ie7 ie-lte9 ie-lte8 ie-lte7 no-js" lang="en-us"> <![endif]-->
<!--[if IE 8]><html class="ie ie8 ie-lte9 ie-lte8 no-js" lang="en-us"> <![endif]-->
<!--[if IE 9]><html class="ie9 ie-lte9 no-js" lang="en-us"> <![endif]-->
<!--[if (gt IE 9)|!(IE)]><!--> <html class="no-js" lang="en-us"> <!--<![endif]-->
<head>
  <meta charset="utf-8" />
  <!-- www.phpied.com/conditional-comments-block-downloads/ -->
  <!-- Always force latest IE rendering engine
       (even in intranet) & Chrome Frame
       Remove this if you use the .htaccess -->
  <!--[if IE]>
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <![endif]-->

  <title>Diffbook</title>

  <!-- http://dev.w3.org/html5/markup/meta.name.html -->
  <meta name="application-name" content="diffbook" />

  <!-- Speaking of Google, don't forget to set your site up:
       http://google.com/webmasters -->
  <meta name="google-site-verification" content="" />

  <!--  Mobile Viewport Fix
        j.mp/mobileviewport & davidbcalhoun.com/2010/viewport-metatag
        device-width: Occupy full width of the screen in its current orientation
        initial-scale = 1.0 retains dimensions instead of zooming out if page height > device height
        user-scalable = yes allows the user to zoom in -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <link rel="shortcut icon" href="static/images/favicon.ico" type="image/x-icon">
  <link rel="apple-touch-icon" href="static/images/favicon.png">

  <!-- All JavaScript at the bottom, except for Modernizr which enables
       HTML5 elements & feature detects -->
  <script src="static/js/modernizr.custom.js"></script>

  <!-- include stylesheets -->
  

  <script type="text/javascript"><!--
    // These variables are used by the web2py_ajax_init function in web2py_ajax.js (which is loaded below).
    var w2p_ajax_confirm_message = "Are you sure you want to delete this object?";
    var w2p_ajax_date_format = "%Y-%m-%d";
    var w2p_ajax_datetime_format = "%Y-%m-%d %H:%M:%S";
    //--></script>
<meta name="keywords" content="web2py, python, framework" />

<meta name="description" content="a cool new app" />

<meta name="generator" content="Web2py Web Framework" />

<meta name="author" content="Your Name &lt;you@example.com&gt;" />
<script src="static/js/jquery.js" type="text/javascript"></script><link href="static/css/calendar.css" rel="stylesheet" type="text/css" /><script src="static/js/calendar.js" type="text/javascript"></script><script src="static/js/web2py.js" type="text/javascript"></script><link href="static/css/web2py.css" rel="stylesheet" type="text/css" /><link href="static/css/bootstrap.min.css" rel="stylesheet" type="text/css" /><link href="static/css/bootstrap-responsive.min.css" rel="stylesheet" type="text/css" /><link href="static/css/web2py_bootstrap.css" rel="stylesheet" type="text/css" />


  

  <!-- uncomment here to load jquery-ui
       <link rel="stylesheet" href="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8.16/themes/base/jquery-ui.css" type="text/css" media="all" />
       <script src="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8.16/jquery-ui.min.js" type="text/javascript"></script>
       uncomment to load jquery-ui //-->
  <noscript><link href="static/css/web2py_bootstrap_nojs.css" rel="stylesheet" type="text/css" /></noscript>
  
  <style type="text/css">

      /* Sticky footer styles
      -------------------------------------------------- */

      html,
      body {
        height: 100%;
        /* The html and body elements cannot have any padding or margin. */
      }

      /* Wrapper for page content to push down footer */
      #wrap {
        min-height: 100%;
        height: auto !important;
        height: 100%;
        /* Negative indent footer by it's height */
        margin: 0 auto -60px;
      }

      /* Set the fixed height of the footer here */
      #push,
      #footer {
        height: 60px;
      }
      #footer {
        background-color: #f5f5f5;
      }

      /* Lastly, apply responsive CSS fixes as necessary */
      @media (max-width: 767px) {
        #footer {
          margin-left: -20px;
          margin-right: -20px;
          padding-left: 20px;
          padding-right: 20px;
        }
      }



      /* Custom page CSS
      -------------------------------------------------- */
      /* Not required for template or sticky footer method. */

      .container {
        width: auto;
        max-width: 680px;
      }
      .container .credit {
        margin: 20px 0;
      }

    </style>
</head>

<body>
  
  <body>


    <!-- Part 1: Wrap all page content here -->
    <div id="wrap">

      <!-- Begin page content -->
      <div class="container-fluid">
        <div class="page-header">
          	<h1>
              Diffbook
              <small>easy? diffbook</small>
            </h1>
        </div>
        
        


<div class="pagination">
  <ul>

      <li><a href="/diffbook/0.html">Chapter 0</a></li>

      <li><a href="/diffbook/1.html">Chapter 1</a></li>

      <li><a href="/diffbook/2.html">Chapter 2</a></li>

      <li><a href="/diffbook/3.html">Chapter 3</a></li>

      <li><a href="/diffbook/4.html">Chapter 4</a></li>

      <li><a href="/diffbook/5.html">Chapter 5</a></li>

      <li><a href="/diffbook/6.html">Chapter 6</a></li>

      <li><a href="/diffbook/7.html">Chapter 7</a></li>

      <li><a href="/diffbook/8.html">Chapter 8</a></li>

      <li><a href="/diffbook/9.html">Chapter 9</a></li>

      <li><a href="/diffbook/10.html">Chapter 10</a></li>

      <li><a href="/diffbook/11.html">Chapter 11</a></li>

      <li><a href="/diffbook/12.html">Chapter 12</a></li>

  </ul>
</div>

<div class="pagination">
  <ul>

      
      <li><a href="#com_f3c10cf02153cedddf5c841856308cf814aef34a">f3c10cf</a></li>
      

      
      <li><a href="#com_c9fa00ae972e76ce27f229701206602dff736a8a">c9fa00a</a></li>
      

      
      <li><a href="#com_847b1e97e19d2e8a0b30b4c3f22ebe4f8ad77ef9">847b1e9</a></li>
      

      
      <li><a href="#com_856633c656c161d28dca165dca637bd554f4ba10">856633c</a></li>
      

      
      <li><a href="#com_ad37241aa4b4e64711dff1659027331eae1d9ddd">ad37241</a></li>
      

      
      <li><a href="#com_dc4a99c7818e7510595150a5c7a4a5d204f5c092">dc4a99c</a></li>
      

      
      <li><a href="#com_25b48e10519bf6be1fcf7dd853f642da5a7524b8">25b48e1</a></li>
      

      
      <li><a href="#com_67961abf844c1076bc877583cf42b9720d89eeed">67961ab</a></li>
      

      
      <li><a href="#com_5ebcc42a6693401b956821b9bcae4a94afa3f869">5ebcc42</a></li>
      

      
      <li><a href="#com_7a446d89ebb85821e59f8370cf12fdfda11fc300">7a446d8</a></li>
      

      
      <li><a href="#com_60e4c9465c6bef7f187d805ffe813ff6ae76e35c">60e4c94</a></li>
      

      
      <li><a href="#com_1970e6f5596a96358cbcba2202bc1fa69211a389">1970e6f</a></li>
      

      
      <li><a href="#com_9ea182b85a74864c21b9b17b703c8af4d071e274">9ea182b</a></li>
      

      
      <li><a href="#com_6a1aeae64591ab64e493ae1a24bca312a01dabca">6a1aeae</a></li>
      

      
      <li><a href="#com_739a4c66c06a1aa5de5f4bd07b49e2f04ec30290">739a4c6</a></li>
      

      
      <li><a href="#com_d5b786168d913e831aedb847c3eae42b87d49f1d">d5b7861</a></li>
      

      
      <li><a href="#com_068e4f02f4612cfdd764a910dcc633691b508de8">068e4f0</a></li>
      

      
      <li><a href="#com_9f8f7358720ecddc06a79b90a68cc94ae5b28603">9f8f735</a></li>
      

      
      <li><a href="#com_83521b165c2d34b0f5904766b5cf9d6f9cf3660a">83521b1</a></li>
      

      
      <li><a href="#com_952ca92844a2c9638b9a652f0d0e536f391e9fe1">952ca92</a></li>
      

      
      <li><a href="#com_61df3d2ca87986edb19cb65ecd11696c82ad913a">61df3d2</a></li>
      

      
      <li><a href="#com_e706d40e67287f56741ecf730ef44a7e3ac66054">e706d40</a></li>
      

      
      <li><a href="#com_c8d32ea975d0ab9fd251f1eb7b72313744e31ad5">c8d32ea</a></li>
      

      
      <li><a href="#com_06e7da447e109c9d4b50fdcb1d7c2e1b55850375">06e7da4</a></li>
      

      
      <li><a href="#com_8fe4c65f991a23ce43305114e46fb6cf8e96a386">8fe4c65</a></li>
      

      
      <li><a href="#com_6feb49d47e68077713b316da11a6533e1d639add">6feb49d</a></li>
      

      
      <li><a href="#com_6b98100d18209c817980078fba78b5d511a8d299">6b98100</a></li>
      

      
      <li><a href="#com_dfb272c5b97441b4e2bc1177c97177ecf83b1d0f">dfb272c</a></li>
      

      
      <li><a href="#com_f2fd41dd2a0d4bf68f5cd4f0989fb32bdc35eac5">f2fd41d</a></li>
      

      
      <li><a href="#com_ae63889d5e5f406babdda11f1b0123978eb4603f">ae63889</a></li>
      

      
      <li><a href="#com_c482e34c27660c375ad9174f7c87d3df40a6eb62">c482e34</a></li>
      

      
      <li><a href="#com_95763bdcd5e83fb4b924ac8f71b00c67b2661dc7">95763bd</a></li>
      

      
      <li><a href="#com_097d699dc16179206ccb7e4aee863d6523cd471c">097d699</a></li>
      

      
      <li><a href="#com_49f38ab7ef56de1eb4ef48f68427ebf8a46b505d">49f38ab</a></li>
      

      
      <li><a href="#com_eaaa0e14bf17cdc4d0edd2ea9daa9af5f3484c09">eaaa0e1</a></li>
      

      
      <li><a href="#com_28816a98948c4a6577f73bdeb2b7424dc55d2582">28816a9</a></li>
      

      
      <li><a href="#com_7bce1473ce90f4e60f49d72bf1b61d32f430cb54">7bce147</a></li>
      

      
      <li><a href="#com_e234f6edf67361b3ba718ea10184ba8e7c2f773d">e234f6e</a></li>
      

      
      <li><a href="#com_82dc64e7baa231edd3896ca7a0d41393e426f123">82dc64e</a></li>
      

      
      <li><a href="#com_b0baf2e1e67f2011176a7cdd13861bb2c7504551">b0baf2e</a></li>
      

      
      <li><a href="#com_4d53788f2d863d91713a5f41b0bb589d6fd18162">4d53788</a></li>
      

      
      <li><a href="#com_b1e25b8418671e7607065dd8a0b7dbddf306791a">b1e25b8</a></li>
      

      
      <li><a href="#com_11e58b1472eca0f2d66fa2b9bc3bef1cad1981f7">11e58b1</a></li>
      

      
      <li><a href="#com_c0da1a23055a3368a1a4b20f5e90fcd6ef18f4f8">c0da1a2</a></li>
      

      
      <li><a href="#com_189c12f17f3e21b5a8782723a2e75a89c8342098">189c12f</a></li>
      

      
      <li><a href="#com_7f182418fe4935588e8d4183dcf4fd351c6ca92b">7f18241</a></li>
      

      
      <li><a href="#com_fe2d532209d3ced4b9b5d8b72c52e588b4338d9e">fe2d532</a></li>
      

      
      <li><a href="#com_be8da74855713dabb0c2a0a05a7d67002ace209b">be8da74</a></li>
      

      
      <li><a href="#com_9e10b63ca42973fcccba175ef95076d74f292d1b">9e10b63</a></li>
      

      
      <li><a href="#com_1964e274f1b0a0a41db2aeb76ac294b0bfbb212b">1964e27</a></li>
      

      
      <li><a href="#com_ac4003f4349f9ee22c67309ceeb48de5539b0308">ac4003f</a></li>
      

      
      <li><a href="#com_93539678ed5ee942c5bd09736516134b7abd95fd">9353967</a></li>
      

      

  </ul>
</div>




<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/f3c10cf02153cedddf5c841856308cf814aef34a">f3c10cf</a><ul><li>Date : 2014-01-12</li><li>Update 06.markmin</li></ul></li></ul>
<div class="row-fluid" id="com_f3c10cf02153cedddf5c841856308cf814aef34a">
    <div class="span6"><div class="diff"><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.item.total_price = Field.Virtual(</div><div class="insert">+    &#x27;total_price&#x27;,</div><div class="">     lambda row: row.item.unit_price*row.item.quantity)</div><div class=""> ``:code</div></div></div>
    <div class="span6"><div class="diff"><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.item.total_price = Field.Virtual(</div><div class="">     lambda row: row.item.unit_price*row.item.quantity)</div><div class=""> ``:code</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/c9fa00ae972e76ce27f229701206602dff736a8a">c9fa00a</a><ul><li>Date : 2013-10-17</li><li>improved the layout of the DAL gotchas section, added a boolean gotcha for SQLite</li></ul></li></ul>
<div class="row-fluid" id="com_c9fa00ae972e76ce27f229701206602dff736a8a">
    <div class="span6"><div class="diff"><div class="insert">+The Gotchas section at the end of this chapter has some more information about specific databases.</div><div class="insert">+</div><div class=""> The Windows binary distribution works out of the box with SQLite and MySQL. The Mac binary distribution works out of the box with SQLite.</div><div class=""> To use any other database back-end, run from the source distribution and install the appropriate driver for the required back end.</div><div class=""> ``database drivers``:inxx</div><div class=""> </div><div class=""> Once the proper driver is installed, start web2py from source, and it will find the driver. Here is a list of drivers:</div><div class=""> </div><div class=""> ``DAL``:inxx ``SQLite``:inxx ``MySQL``:inxx ``PostgresSQL``:inxx ``Oracle``:inxx ``MSSQL``:inxx ``FireBird``:inxx ``DB2``:inxx ``Informix``:inxx ``Sybase``:inxx ``Teradata``:inxx ``MongoDB``:inxx ``CouchDB``:inxx ``SAPDB``:inxx ``Cubrid``:inxx</div><div class=""> </div><div class=""> ----------</div><div class=""> database | drivers (source)</div><div class=""> SQLite | sqlite3 or pysqlite2 or zxJDBC ``zxjdbc``:cite  (on Jython)</div><div class=""> PostgreSQL | psycopg2 ``psycopg2``:cite  or pg8000 ``pg8000``:cite or zxJDBC ``zxjdbc``:cite  (on Jython)</div><div class=""> MySQL | pymysql ``pymysql``:cite or MySQLdb ``mysqldb``:cite</div><div class=""> Oracle | cx_Oracle ``cxoracle``:cite</div><div class=""> MSSQL | pyodbc ``pyodbc``:cite</div><div class=""> FireBird | kinterbasdb ``kinterbasdb``:cite or fdb or pyodbc</div><div class=""> DB2 | pyodbc ``pyodbc``:cite</div><div class=""> Informix | informixdb ``informixdb``:cite</div><div class=""> Ingres | ingresdbi ``ingresdbi``:cite</div><div class=""> Cubrid | cubriddb ``cubridb``:cite ``cubridb``:cite</div><div class=""> ADAPTERS = {</div><div class=""> }</div><div class=""> ``:code</div><div class=""> </div><div class=""> the uri string is then parsed in more detail by the adapter itself.</div><div class=""> </div><div class=""> For any adapter you can replace the driver with a different one:</div><div class=""> </div><div class=""> ``</div><div class=""> import MySQLdb as mysqldb</div><div class=""> from gluon.dal import MySQLAdapter</div><div class=""> MySQLAdapter.driver = mysqldb</div><div class=""> ``</div><div class=""> i.e. ``mysqldb`` has to be &#x27;&#x27;that module&#x27;&#x27; with a .connect() method.</div><div class=""> You can specify optional driver arguments and adapter arguments:</div><div class=""> </div><div class=""> ``</div><div class=""> db =DAL(..., driver_args={}, adapter_args={})</div><div class=""> ``</div><div class=""> </div><div class=""> </div><div class="insert">+### Gotchas</div><div class="insert">+</div><div class="insert">+#### SQLite</div><div class="insert">+SQLite does not support dropping and altering columns. That means that web2py migrations will work up to a point. If you delete a field from a table, the column will remain in the database but will be invisible to web2py. If you decide to reinstate the column, web2py will try re-create it and fail. In this case you must set ``fake_migrate=True`` so that metadata is rebuilt without attempting to add the column again. Also, for the same reason, **SQLite** is not aware of any change of column type. If you insert a number in a string field, it will be stored as string. If you later change the model and replace the type &quot;string&quot; with type &quot;integer&quot;, SQLite will continue to keep the number as a string and this may cause problem when you try to extract the data.</div><div class="insert">+</div><div class="insert">+SQLite doesn&#x27;t have a boolean type. web2py internally maps booleans to a 1 character string, with &#x27;T&#x27; and &#x27;F&#x27; representing True and False. The DAL handles this completely; the abstraction of a true boolean value works well. </div><div class="insert">+But if you are updating the SQLite table with SQL directly, be aware of the web2py implementation, and avoid using 0 and 1 values.</div><div class="insert">+</div><div class="insert">+#### MySQL</div><div class=""> </div><div class="insert"><span class="highlight">My</span>SQL<span class="highlight"> does not support multiple ALTER TABLE within a single transaction</span>. Th<span class="highlight">is means that an</span>y migration<span class="highlight"> process is bro</span>k<span class="highlight">en into multiple commits</span>. If <span class="highlight">something happens that causes a failure it is possible to break a migration (the web2p</span>y<span class="highlight"> metadata are no longer in sync with the actual table structure in the database). This is un</span>f<span class="highlight">ortunate but it can be prevented (migrate one table at the time) or it can be</span> f<span class="highlight">ixed a posteriori (revert the web2py model to what corresponds to the table structure in databas</span>e,<span class="highlight"></span> set ``fake_migrate=True`` <span class="highlight">and after the metadata has been rebuilt, set ``fake_migrate=False`` and migrate the table again)</span>.<span class="highlight"></span></div><div class=""> </div><div class="insert"><span class="highlight">#### Googel </span>SQL<span class="highlight"></span></div><div class=""> </div><div class="insert"><span class="highlight"></span>Google SQL<span class="highlight"></span> has the same problems as MySQL and more. In particular table metadata itself must be stored in the database in a table that is not migrated by web2py. This is because Google App Engine has a read-only file system. Web2py migrations in Google:SQL combined with the MySQL issue described above can result in metadata corruption. Again, this can be prevented (by migrating the table at once and then setting migrate=False so that the metadata table is not accessed any more) or it can fixed a posteriori (by accessing the database using the Google dashboard and deleting any corrupted entry from the table called ``web2py_filesystem``.</div><div class=""> </div><div class="insert">+#### MSSQL (Microsoft SQL Server)</div><div class=""> ``limitby``:inxx</div><div class="insert"><span class="highlight"></span>MSSQL<span class="highlight"></span> does not support the SQL OFFSET keyword. Therefore the database cannot do pagination. When doing a ``limitby=(a,b)`` web2py will fetch the first ``b`` rows and discard the first ``a``. This may result in a considerable overhead when compared with other database engines.</div><div class=""> </div><div class="insert"><span class="highlight">####</span> Oracle<span class="highlight"></span></div><div class=""> </div><div class="insert">+Oracle also does not support pagination. It does not support neither the OFFSET nor the LIMIT keywords. Web2py achieves pagination by translating a ``db(...).select(limitby=(a,b))`` into a complex three-way nested select (as suggested by official Oracle documentation). </div><div class="insert">+This works for simple select but may break for complex selects involving aliased fields and or joins.</div><div class="insert">+</div><div class="insert">+#### MSSQL </div><div class="insert">+</div><div class="insert">+MSSQL has problems with circular references in tables that have ONDELETE CASCADE. This is an MSSQL bug and you work around it by setting the ondelete attribute for all reference fields to &quot;NO ACTION&quot;. </div><div class="insert">+You can also do it once and for all before you define tables:</div><div class=""> </div><div class=""> ``</div><div class=""> db = DAL(&#x27;mssql://....&#x27;)</div><div class=""> for key in [&#x27;reference&#x27;,&#x27;reference FK&#x27;]:</div><div class="">     db._adapter.types[key]=db._adapter.types[key].replace(</div><div class="">         &#x27;%(on_delete_action)s&#x27;,&#x27;NO ACTION&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class="insert"><span class="highlight"></span>MSSQL<span class="highlight"></span> also has problems with arguments passed to the DISTINCT keyword and therefore</div><div class="">  while this works,</div><div class=""> </div><div class=""> ``</div><div class=""> db(query).select(distinct=True)</div><div class=""> ``</div><div class=""> </div><div class=""> this does not</div><div class=""> </div><div class=""> ``</div><div class=""> db(query).select(distinct=db.mytable.myfield)</div><div class=""> ``</div><div class=""> </div><div class="insert">+#### Googel NoSQL (Datastore)</div><div class="insert">+Google NoSQL (Datastore) does not allow joins, left joins, aggregates, expression, OR involving more than one table, the ‘like’ operator searches in &quot;text&quot; fields. </div><div class="insert">+</div><div class="insert">+Transactions are limited and not provided automatically by web2py (you need to use the Google API ``run_in_transaction`` which you can look up in the Google App Engine documentation online). </div><div class="insert">+</div><div class="insert">+Google also limits the number of records you can retrieve in each one query (1000 at the time of writing). On the Google datastore record IDs are integer but they are not sequential. </div><div class="insert">+While on SQL the &quot;list:string&quot; type is mapped into a &quot;text&quot; type, on the Google Datastore it is mapped into a ``ListStringProperty``. Similarly &quot;list:integer&quot; and &quot;list:reference&quot; are mapped into &quot;ListProperty&quot;. This makes searches for content inside these fields types are more efficient on Google NoSQL than on SQL databases.</div></div></div>
    <div class="span6"><div class="diff"><div class=""> The Windows binary distribution works out of the box with SQLite and MySQL. The Mac binary distribution works out of the box with SQLite.</div><div class=""> To use any other database back-end, run from the source distribution and install the appropriate driver for the required back end.</div><div class=""> ``database drivers``:inxx</div><div class=""> </div><div class=""> Once the proper driver is installed, start web2py from source, and it will find the driver. Here is a list of drivers:</div><div class=""> </div><div class=""> ``DAL``:inxx ``SQLite``:inxx ``MySQL``:inxx ``PostgresSQL``:inxx ``Oracle``:inxx ``MSSQL``:inxx ``FireBird``:inxx ``DB2``:inxx ``Informix``:inxx ``Sybase``:inxx ``Teradata``:inxx ``MongoDB``:inxx ``CouchDB``:inxx ``SAPDB``:inxx ``Cubrid``:inxx</div><div class=""> </div><div class=""> ----------</div><div class=""> database | drivers (source)</div><div class=""> SQLite | sqlite3 or pysqlite2 or zxJDBC ``zxjdbc``:cite  (on Jython)</div><div class=""> PostgreSQL | psycopg2 ``psycopg2``:cite  or pg8000 ``pg8000``:cite or zxJDBC ``zxjdbc``:cite  (on Jython)</div><div class=""> MySQL | pymysql ``pymysql``:cite or MySQLdb ``mysqldb``:cite</div><div class=""> Oracle | cx_Oracle ``cxoracle``:cite</div><div class=""> MSSQL | pyodbc ``pyodbc``:cite</div><div class=""> FireBird | kinterbasdb ``kinterbasdb``:cite or fdb or pyodbc</div><div class=""> DB2 | pyodbc ``pyodbc``:cite</div><div class=""> Informix | informixdb ``informixdb``:cite</div><div class=""> Ingres | ingresdbi ``ingresdbi``:cite</div><div class=""> Cubrid | cubriddb ``cubridb``:cite ``cubridb``:cite</div><div class=""> ADAPTERS = {</div><div class=""> }</div><div class=""> ``:code</div><div class=""> </div><div class=""> the uri string is then parsed in more detail by the adapter itself.</div><div class=""> </div><div class=""> For any adapter you can replace the driver with a different one:</div><div class=""> </div><div class=""> ``</div><div class=""> import MySQLdb as mysqldb</div><div class=""> from gluon.dal import MySQLAdapter</div><div class=""> MySQLAdapter.driver = mysqldb</div><div class=""> ``</div><div class=""> i.e. ``mysqldb`` has to be &#x27;&#x27;that module&#x27;&#x27; with a .connect() method.</div><div class=""> You can specify optional driver arguments and adapter arguments:</div><div class=""> </div><div class=""> ``</div><div class=""> db =DAL(..., driver_args={}, adapter_args={})</div><div class=""> ``</div><div class=""> </div><div class=""> </div><div class="delete">-#### Gotchas</div><div class=""> </div><div class="delete"><span class="highlight">**</span>SQL<span class="highlight">ite** does not support dropping and altering columns</span>. Th<span class="highlight">at means that web2p</span>y migration<span class="highlight">s will wor</span>k<span class="highlight"> up to a point</span>. If <span class="highlight"></span>y<span class="highlight">ou delete a </span>f<span class="highlight">ield</span> f<span class="highlight">rom a tabl</span>e,<span class="highlight"> the column will remain in the database but will be invisible to web2py. If you decide to reinstate the column, web2py will try re-create it and fail. In this case you must</span> set ``fake_migrate=True`` <span class="highlight">so that metadata is rebuilt without attempting to add the column again</span>.<span class="highlight"> Also, for the same reason, **SQLite** is not aware of any change of column type. If you insert a number in a string field, it will be stored as string. If you later change the model and replace the type &quot;string&quot; with type &quot;integer&quot;, SQLite will continue to keep the number as a string and this may cause problem when you try to extract the data.</span></div><div class=""> </div><div class="delete"><span class="highlight">**My</span>SQL<span class="highlight">** does not support multiple ALTER TABLE within a single transaction. This means that any migration process is broken into multiple commits. If something happens that causes a failure it is possible to break a migration (the web2py metadata are no longer in sync with the actual table structure in the database). This is unfortunate but it can be prevented (migrate one table at the time) or it can be fixed a posteriori (revert the web2py model to what corresponds to the table structure in database, set ``fake_migrate=True`` and after the metadata has been rebuilt, set ``fake_migrate=False`` and migrate the table again).</span></div><div class=""> </div><div class="delete"><span class="highlight">**</span>Google SQL<span class="highlight">**</span> has the same problems as MySQL and more. In particular table metadata itself must be stored in the database in a table that is not migrated by web2py. This is because Google App Engine has a read-only file system. Web2py migrations in Google:SQL combined with the MySQL issue described above can result in metadata corruption. Again, this can be prevented (by migrating the table at once and then setting migrate=False so that the metadata table is not accessed any more) or it can fixed a posteriori (by accessing the database using the Google dashboard and deleting any corrupted entry from the table called ``web2py_filesystem``.</div><div class=""> </div><div class=""> ``limitby``:inxx</div><div class="delete"><span class="highlight">**</span>MSSQL<span class="highlight">**</span> does not support the SQL OFFSET keyword. Therefore the database cannot do pagination. When doing a ``limitby=(a,b)`` web2py will fetch the first ``b`` rows and discard the first ``a``. This may result in a considerable overhead when compared with other database engines.</div><div class=""> </div><div class="delete"><span class="highlight">**Oracle** also does not support pagination. It does not support neither the OFFSET nor the LIMIT keywords. Web2py achieves pagination by translating a ``db(...).select(limitby=(a,b))`` into a complex three-way nested select (as suggested by official</span> Oracle<span class="highlight"> documentation). This works for simple select but may break for complex selects involving aliased fields and or joins.</span></div><div class=""> </div><div class="delete">-**MSSQL** has problems with circular references in tables that have ONDELETE CASCADE. This is an MSSQL bug and you work around it by setting the ondelete attribute for all reference fields to &quot;NO ACTION&quot;. You can also do it once and for all before you define tables:</div><div class=""> </div><div class=""> ``</div><div class=""> db = DAL(&#x27;mssql://....&#x27;)</div><div class=""> for key in [&#x27;reference&#x27;,&#x27;reference FK&#x27;]:</div><div class="">     db._adapter.types[key]=db._adapter.types[key].replace(</div><div class="">         &#x27;%(on_delete_action)s&#x27;,&#x27;NO ACTION&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class="delete"><span class="highlight">**</span>MSSQL<span class="highlight">**</span> also has problems with arguments passed to the DISTINCT keyword and therefore</div><div class="">  while this works,</div><div class=""> </div><div class=""> ``</div><div class=""> db(query).select(distinct=True)</div><div class=""> ``</div><div class=""> </div><div class=""> this does not</div><div class=""> </div><div class=""> ``</div><div class=""> db(query).select(distinct=db.mytable.myfield)</div><div class=""> ``</div><div class=""> </div><div class="delete">-**Google NoSQL (Datastore)** does not allow joins, left joins, aggregates, expression, OR involving more than one table, the ‘like’ operator searches in &quot;text&quot; fields. Transactions are limited and not provided automatically by web2py (you need to use the Google API ``run_in_transaction`` which you can look up in the Google App Engine documentation online). Google also limits the number of records you can retrieve in each one query (1000 at the time of writing). On the Google datastore record IDs are integer but they are not sequential. While on SQL the &quot;list:string&quot; type is mapped into a &quot;text&quot; type, on the Google Datastore it is mapped into a ``ListStringProperty``. Similarly &quot;list:integer&quot; and &quot;list:reference&quot; are mapped into &quot;ListProperty&quot;. This makes searches for content inside these fields types are more efficient on Google NoSQL than on SQL databases.</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/847b1e97e19d2e8a0b30b4c3f22ebe4f8ad77ef9">847b1e9</a><ul><li>Date : 2013-10-08</li><li>Updates to DAL: rows.render(), orderby_limitby, tidied up options to be used with select to make them more discoverable</li></ul></li></ul>
<div class="row-fluid" id="com_847b1e97e19d2e8a0b30b4c3f22ebe4f8ad77ef9">
    <div class="span6"><div class="diff"><div class="insert">+#### Rendering rows using represent</div><div class="insert">+You may wish to rewrite rows returned by select to take advantage of formatting information contained in the represents setting of the fields. </div><div class="insert">+</div><div class="insert">+``rows = db(query).select()</div><div class="insert">+repr_row = rows.render(0)``:code</div><div class="insert">+</div><div class="insert">+If you don&#x27;t specify an index, you get a generator to iterate over all the rows:</div><div class="insert">+</div><div class="insert">+``for row in rows.render():</div><div class="insert">+    print row.myfield``:code</div><div class="insert">+</div><div class="insert">+Can also be applied to slices:</div><div class="insert">+</div><div class="insert">+``for row in rows[0:10].render():</div><div class="insert">+    print row.myfield``:code</div><div class="insert">+</div><div class="insert">+If you only want to transform selected fields via their &quot;represent&quot; attribute, you can list them in the &quot;fields&quot; argument:</div><div class="insert">+</div><div class="insert">+``repr_row = row.render(0, fields=[db.mytable.myfield])``:code</div><div class="insert">+</div><div class="insert">+Note, it returns a transformed copy of the original Row, so there&#x27;s no update_record (which you wouldn&#x27;t want anyway) or delete_record.</div><div class="insert">+</div><div class="insert">+</div><div class=""> #### Shortcuts</div><div class=""> ``DAL shortcuts``:inxx</div><div class=""> </div><div class=""> The DAL supports various code-simplifying shortcuts.</div><div class=""> In particular:</div><div class=""> ``</div><div class=""> myrecord = db.mytable[id]</div><div class=""> ``:code</div><div class=""> </div><div class=""> returns the record with the given ``id`` if it exists. If the ``id`` does not exist, it returns ``None``. The above statement is equivalent to</div><div class=""> </div><div class=""> ``</div><div class=""> myrecord = db(db.mytable.id==id).select().first()</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can delete records by id:</div><div class=""> </div><div class=""> ``</div><div class=""> del db.mytable[id]</div><div class=""> ``:code</div><div class=""> Here is an example:</div><div class=""> ------</div><div class=""> ``SQLTABLE`` is useful but there are times when one needs more. ``SQLFORM.grid`` is an extension of SQLTABLE that creates a table with search features and pagination, as well as ability to open detailed records, create, edit and delete records. ``SQLFORM.smartgrid`` is a further generalization that allows all of the above but also creates buttons to access referencing records.</div><div class=""> ------</div><div class=""> </div><div class=""> Here is an example of usage of ``SQLFORM.grid``:</div><div class=""> </div><div class=""> ``</div><div class=""> def index():</div><div class="">     return dict(grid=SQLFORM.grid(query))</div><div class=""> ``:code</div><div class=""> </div><div class=""> and the corresponding view:</div><div class=""> </div><div class=""> ``</div><div class=""> {{extend &#x27;layout.html&#x27;}}</div><div class=""> {{=grid}}</div><div class=""> ``</div><div class=""> </div><div class=""> ``SQLFORM.grid`` and ``SQLFORM.smartgrid`` should be preferred to ``SQLTABLE`` because they are more powerful although higher level and therefore more constraining. They will be explained in more detail in chapter 7.</div><div class=""> </div><div class="insert">#### ``orderby``, ``groupby``, ``limitby``, ``distinct``, ``having``<span class="highlight">,``orderby_on_limitby``,``left``,``cache``</span></div><div class=""> </div><div class="insert">The ``select`` command takes <span class="highlight">a number o</span>f<span class="highlight"></span> optional arguments<span class="highlight"></span>.<span class="highlight"></span></div><div class=""> </div><div class="insert">+##### orderby</div><div class=""> You can fetch the records sorted by name:</div><div class=""> </div><div class=""> ``orderby``:inxx ``groupby``:inxx ``having``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db().select(</div><div class="">         db.person.ALL, orderby=db.person.name):</div><div class="">         print row.name</div><div class=""> Alex</div><div class=""> Bob</div><div class=""> Carl</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can fetch the records sorted by name in reverse order (notice the tilde):</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db().select(</div><div class="">         db.person.ALL, orderby=~db.person.name):</div><div class="">         print row.name</div><div class=""> Carl</div><div class=""> Bob</div><div class=""> Alex</div><div class=""> Bob</div><div class=""> ``:code</div><div class=""> </div><div class=""> -----</div><div class=""> The use of ``orderby=&#x27;&lt;random&gt;&#x27;`` is not supported on Google NoSQL.  However, in this situation and likewise in many others where built-ins are insufficient, imports can be used:</div><div class=""> ``</div><div class=""> import random</div><div class=""> rows=db(...).select().sort(lambda row: random.random())</div><div class=""> ``:code</div><div class=""> -----</div><div class=""> </div><div class=""> You can sort the records according to multiple fields by concatenating them with a &quot;|&quot;:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db().select(</div><div class="">         db.person.ALL, orderby=db.person.name|db.person.id):</div><div class="">         print row.name</div><div class=""> Carl</div><div class=""> Bob</div><div class=""> Alex</div><div class=""> ``:code</div><div class=""> </div><div class="insert">+##### groupby, having</div><div class=""> Using ``groupby`` together with ``orderby``, you can group records with the same value for the specified field (this is back-end specific, and is not on the Google NoSQL):</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db().select(</div><div class="">         db.person.ALL,</div><div class="">         orderby=db.person.name, groupby=db.person.name):</div><div class="">         print row.name</div><div class=""> Alex</div><div class=""> Bob</div><div class=""> Carl</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can use ``having`` in conjunction with ``groupby`` to group conditionally (only those ``having`` the condition are grouped.</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; print db(query1).select(db.person.ALL, groupby=db.person.name, having=query2)</div><div class=""> ``</div><div class=""> </div><div class=""> Notice that query1 filters records to be displayed, query2 filters records to be grouped.</div><div class=""> </div><div class="insert">+##### distinct</div><div class=""> ``distinct``:inxx</div><div class=""> </div><div class=""> With the argument ``distinct=True``, you can specify that you only want to select distinct records. This has the same effect as grouping using all specified fields except that it does not require sorting. When using distinct it is important not to select ALL fields, and in particular not to select the &quot;id&quot; field, else all records will always be distinct.</div><div class=""> </div><div class=""> Here is an example:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db().select(db.person.name, distinct=True):</div><div class="">         print row.name</div><div class=""> Alex</div><div class=""> Bob</div><div class=""> Carl</div><div class=""> ``:code</div><div class=""> </div><div class=""> Notice that ``distinct`` can also be an expression for example:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db().select(db.person.name,distinct=db.person.name):</div><div class="">         print row.name</div><div class=""> Alex</div><div class=""> Bob</div><div class=""> Carl</div><div class=""> ``:code</div><div class="insert"><span class="highlight">##### limitby</span></div><div class=""> With limitby=(min, max), you can select a subset of the records from offset=min to but not including offset=max (in this case, the first two starting at zero):</div><div class=""> </div><div class=""> ``limitby``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db().select(db.person.ALL, limitby=(0, 2)):</div><div class="">         print row.name</div><div class=""> Alex</div><div class=""> Bob</div><div class=""> ``:code</div><div class=""> </div><div class="insert">+##### orderby_on_limitby</div><div class="insert">+``orderby_on_limitby``:inxx</div><div class="insert">+Note that the DAL defaults to implicitly adding an orderby when using a limitby.</div><div class="insert">+This ensures the same query returns the same results each time, important for pagination.</div><div class="insert">+But it can cause performance problems. </div><div class="insert">+use ``orderby_on_limitby = False`` to change this (this defaults to True). </div><div class="insert">+</div><div class="insert">+##### left</div><div class="insert">+Discussed below in the section on joins</div><div class="insert">+</div><div class="insert">+##### cache, cacheable</div><div class="insert">+An example use which gives much faster selects is:</div><div class="insert">+``rows = db(query).select(cache=(cache.ram,3600),cacheable=True)``:code</div><div class="insert">+See discussion on &#x27;caching selects&#x27;, below, to understand what the tradeoffs are. </div><div class="insert">+</div></div></div>
    <div class="span6"><div class="diff"><div class=""> #### Shortcuts</div><div class=""> ``DAL shortcuts``:inxx</div><div class=""> </div><div class=""> The DAL supports various code-simplifying shortcuts.</div><div class=""> In particular:</div><div class=""> ``</div><div class=""> myrecord = db.mytable[id]</div><div class=""> ``:code</div><div class=""> </div><div class=""> returns the record with the given ``id`` if it exists. If the ``id`` does not exist, it returns ``None``. The above statement is equivalent to</div><div class=""> </div><div class=""> ``</div><div class=""> myrecord = db(db.mytable.id==id).select().first()</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can delete records by id:</div><div class=""> </div><div class=""> ``</div><div class=""> del db.mytable[id]</div><div class=""> ``:code</div><div class=""> Here is an example:</div><div class=""> ------</div><div class=""> ``SQLTABLE`` is useful but there are times when one needs more. ``SQLFORM.grid`` is an extension of SQLTABLE that creates a table with search features and pagination, as well as ability to open detailed records, create, edit and delete records. ``SQLFORM.smartgrid`` is a further generalization that allows all of the above but also creates buttons to access referencing records.</div><div class=""> ------</div><div class=""> </div><div class=""> Here is an example of usage of ``SQLFORM.grid``:</div><div class=""> </div><div class=""> ``</div><div class=""> def index():</div><div class="">     return dict(grid=SQLFORM.grid(query))</div><div class=""> ``:code</div><div class=""> </div><div class=""> and the corresponding view:</div><div class=""> </div><div class=""> ``</div><div class=""> {{extend &#x27;layout.html&#x27;}}</div><div class=""> {{=grid}}</div><div class=""> ``</div><div class=""> </div><div class=""> ``SQLFORM.grid`` and ``SQLFORM.smartgrid`` should be preferred to ``SQLTABLE`` because they are more powerful although higher level and therefore more constraining. They will be explained in more detail in chapter 7.</div><div class=""> </div><div class="delete">#### ``orderby``, ``groupby``, ``limitby``, ``distinct``, ``having``<span class="highlight"></span></div><div class=""> </div><div class="delete">The ``select`` command takes <span class="highlight"></span>f<span class="highlight">ive</span> optional arguments<span class="highlight">: orderby, groupby, limitby, left and cache</span>.<span class="highlight"> Here we discuss the first three.</span></div><div class=""> </div><div class=""> You can fetch the records sorted by name:</div><div class=""> </div><div class=""> ``orderby``:inxx ``groupby``:inxx ``having``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db().select(</div><div class="">         db.person.ALL, orderby=db.person.name):</div><div class="">         print row.name</div><div class=""> Alex</div><div class=""> Bob</div><div class=""> Carl</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can fetch the records sorted by name in reverse order (notice the tilde):</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db().select(</div><div class="">         db.person.ALL, orderby=~db.person.name):</div><div class="">         print row.name</div><div class=""> Carl</div><div class=""> Bob</div><div class=""> Alex</div><div class=""> Bob</div><div class=""> ``:code</div><div class=""> </div><div class=""> -----</div><div class=""> The use of ``orderby=&#x27;&lt;random&gt;&#x27;`` is not supported on Google NoSQL.  However, in this situation and likewise in many others where built-ins are insufficient, imports can be used:</div><div class=""> ``</div><div class=""> import random</div><div class=""> rows=db(...).select().sort(lambda row: random.random())</div><div class=""> ``:code</div><div class=""> -----</div><div class=""> </div><div class=""> You can sort the records according to multiple fields by concatenating them with a &quot;|&quot;:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db().select(</div><div class="">         db.person.ALL, orderby=db.person.name|db.person.id):</div><div class="">         print row.name</div><div class=""> Carl</div><div class=""> Bob</div><div class=""> Alex</div><div class=""> ``:code</div><div class=""> </div><div class=""> Using ``groupby`` together with ``orderby``, you can group records with the same value for the specified field (this is back-end specific, and is not on the Google NoSQL):</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db().select(</div><div class="">         db.person.ALL,</div><div class="">         orderby=db.person.name, groupby=db.person.name):</div><div class="">         print row.name</div><div class=""> Alex</div><div class=""> Bob</div><div class=""> Carl</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can use ``having`` in conjunction with ``groupby`` to group conditionally (only those ``having`` the condition are grouped.</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; print db(query1).select(db.person.ALL, groupby=db.person.name, having=query2)</div><div class=""> ``</div><div class=""> </div><div class=""> Notice that query1 filters records to be displayed, query2 filters records to be grouped.</div><div class=""> </div><div class=""> ``distinct``:inxx</div><div class=""> </div><div class=""> With the argument ``distinct=True``, you can specify that you only want to select distinct records. This has the same effect as grouping using all specified fields except that it does not require sorting. When using distinct it is important not to select ALL fields, and in particular not to select the &quot;id&quot; field, else all records will always be distinct.</div><div class=""> </div><div class=""> Here is an example:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db().select(db.person.name, distinct=True):</div><div class="">         print row.name</div><div class=""> Alex</div><div class=""> Bob</div><div class=""> Carl</div><div class=""> ``:code</div><div class=""> </div><div class=""> Notice that ``distinct`` can also be an expression for example:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db().select(db.person.name,distinct=db.person.name):</div><div class="">         print row.name</div><div class=""> Alex</div><div class=""> Bob</div><div class=""> Carl</div><div class=""> ``:code</div><div class="delete"><span class="highlight"></span></div><div class=""> With limitby=(min, max), you can select a subset of the records from offset=min to but not including offset=max (in this case, the first two starting at zero):</div><div class=""> </div><div class=""> ``limitby``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db().select(db.person.ALL, limitby=(0, 2)):</div><div class="">         print row.name</div><div class=""> Alex</div><div class=""> Bob</div><div class=""> ``:code</div><div class=""> </div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/856633c656c161d28dca165dca637bd554f4ba10">856633c</a><ul><li>Date : 2013-09-24</li><li>Correction of spelling</li></ul></li></ul>
<div class="row-fluid" id="com_856633c656c161d28dca165dca637bd554f4ba10">
    <div class="span6"><div class="diff"><div class=""> ----------</div><div class="insert">Because usually in web2py models are executed before controllers, it is possible that some table are defined even if not needed. It is therefore necessary to speed up the code by making table definitions lazy. This is done by setting the ``DAL(...,lazy_tables=True)`` <span class="highlight"> parameter</span>. Tables will be actually created only when accessed.</div><div class=""> ----------</div><div class=""> </div><div class=""> </div><div class=""> ### Record representation</div><div class=""> </div><div class=""> It is optional but recommended to specify a format representation for records:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;), format=&#x27;%(name)s&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> or</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;), format=&#x27;%(name)s %(id)s&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> or even more complex ones using a function:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;),</div><div class="">        format=lambda r: r.name or &#x27;anonymous&#x27;)</div><div class=""> ``:code</div><div class=""> db = DAL(...,migrate_enabled=False)</div><div class=""> This is the recommended behavior when two apps share the same database. Only one of the two apps should perform migrations, the other should disabled them.</div><div class=""> </div><div class=""> ### Fixing broken migrations</div><div class=""> ``fake_migrate``:inxx</div><div class=""> </div><div class=""> There are two common problems with migrations and there are ways to recover from them.</div><div class=""> </div><div class=""> One problem is specific with SQLite. SQLite does not enforce column types and cannot drop columns. This means that if you have a column of type string and you remove it, it is not really removed. If you add the column again with a different type (for example datetime) you end up with a datetime column that contains strings (junk for practical purposes). web2py does not complain about this because it does not know what is in the database, until it tries to retrieve records and fails.</div><div class=""> </div><div class=""> If web2py returns an error in the gluon.sql.parse function when selecting records, this is the problem: corrupted data in a column because of the above issue.</div><div class=""> </div><div class=""> The solution consists in updating all records of the table and updating the values in the column in question with None.</div><div class=""> </div><div class=""> The other problem is more generic but typical with MySQL. MySQL does not allow more than one ALTER TABLE in a transaction. This means that web2py must break complex transactions into smaller ones (one ALTER TABLE at the time) and commit one piece at the time. It is therefore possible that part of a complex transaction gets committed and one part fails, leaving web2py in a corrupted state. Why would part of a transaction fail? Because, for example, it involves altering a table and converting a string column into a datetime column, web2py tries to convert the data, but the data cannot be converted. What happens to web2py? It gets confused about what exactly is the table structure actually stored in the database.</div><div class=""> </div><div class=""> The solution consists of disabling migrations for all tables and enabling fake migrations:</div><div class=""> ``</div><div class=""> db.define_table(....,migrate=False,fake_migrate=True)</div><div class=""> ``:code</div><div class=""> </div><div class="insert">This will rebuild web2py metadata about the table according to the table definition. Try multiple table definitions to see which one works (the one before the failed migration and the one after the failed migration). Once successful remove the ``fake_migrate=True`` <span class="highlight">parameter</span>.</div></div></div>
    <div class="span6"><div class="diff"><div class=""> ----------</div><div class="delete">Because usually in web2py models are executed before controllers, it is possible that some table are defined even if not needed. It is therefore necessary to speed up the code by making table definitions lazy. This is done by setting the ``DAL(...,lazy_tables=True)`` <span class="highlight">attribute</span>. Tables will be actually created only when accessed.</div><div class=""> ----------</div><div class=""> </div><div class=""> </div><div class=""> ### Record representation</div><div class=""> </div><div class=""> It is optional but recommended to specify a format representation for records:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;), format=&#x27;%(name)s&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> or</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;), format=&#x27;%(name)s %(id)s&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> or even more complex ones using a function:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;),</div><div class="">        format=lambda r: r.name or &#x27;anonymous&#x27;)</div><div class=""> ``:code</div><div class=""> db = DAL(...,migrate_enabled=False)</div><div class=""> This is the recommended behavior when two apps share the same database. Only one of the two apps should perform migrations, the other should disabled them.</div><div class=""> </div><div class=""> ### Fixing broken migrations</div><div class=""> ``fake_migrate``:inxx</div><div class=""> </div><div class=""> There are two common problems with migrations and there are ways to recover from them.</div><div class=""> </div><div class=""> One problem is specific with SQLite. SQLite does not enforce column types and cannot drop columns. This means that if you have a column of type string and you remove it, it is not really removed. If you add the column again with a different type (for example datetime) you end up with a datetime column that contains strings (junk for practical purposes). web2py does not complain about this because it does not know what is in the database, until it tries to retrieve records and fails.</div><div class=""> </div><div class=""> If web2py returns an error in the gluon.sql.parse function when selecting records, this is the problem: corrupted data in a column because of the above issue.</div><div class=""> </div><div class=""> The solution consists in updating all records of the table and updating the values in the column in question with None.</div><div class=""> </div><div class=""> The other problem is more generic but typical with MySQL. MySQL does not allow more than one ALTER TABLE in a transaction. This means that web2py must break complex transactions into smaller ones (one ALTER TABLE at the time) and commit one piece at the time. It is therefore possible that part of a complex transaction gets committed and one part fails, leaving web2py in a corrupted state. Why would part of a transaction fail? Because, for example, it involves altering a table and converting a string column into a datetime column, web2py tries to convert the data, but the data cannot be converted. What happens to web2py? It gets confused about what exactly is the table structure actually stored in the database.</div><div class=""> </div><div class=""> The solution consists of disabling migrations for all tables and enabling fake migrations:</div><div class=""> ``</div><div class=""> db.define_table(....,migrate=False,fake_migrate=True)</div><div class=""> ``:code</div><div class=""> </div><div class="delete">This will rebuild web2py metadata about the table according to the table definition. Try multiple table definitions to see which one works (the one before the failed migration and the one after the failed migration). Once successful remove the ``fake_migrate=True`` <span class="highlight">attribute</span>.</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/ad37241aa4b4e64711dff1659027331eae1d9ddd">ad37241</a><ul><li>Date : 2013-09-12</li><li>documented {{}} always adding a blank line in views, &amp; adding custom attributes to fields and tables (see undocumented features document) Plus changed the version on the English chapter to be 6th ed pre-release</li></ul></li></ul>
<div class="row-fluid" id="com_ad37241aa4b4e64711dff1659027331eae1d9ddd">
    <div class="span6"><div class="diff"><div class="insert">+#### Adding attributes to fields and tables</div><div class="insert">+If you need to add custom attributes to fields, you can simply do this:</div><div class="insert">+``db.table.field.extra = {}``:code </div><div class="insert">+</div><div class="insert">+&quot;extra&quot; is not a keyword ; it&#x27;s a custom attributes now attached to the field object. You can do it with tables too but they must be preceded by an </div><div class="insert">+underscore to avoid naming conflicts with fields: </div><div class="insert">+</div><div class="insert">+``db.table._extra = {} ``:code</div><div class=""> </div><div class=""> ### Record representation</div><div class=""> </div><div class=""> It is optional but recommended to specify a format representation for records:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;), format=&#x27;%(name)s&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> or</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;), format=&#x27;%(name)s %(id)s&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> or even more complex ones using a function:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;),</div><div class="">        format=lambda r: r.name or &#x27;anonymous&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> The format attribute will be used for two purposes:</div><div class=""> False</div><div class=""> </div><div class=""> including its parent table, tablename, and parent connection:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.person.name._table == db.person</div><div class=""> True</div><div class=""> &gt;&gt;&gt; db.person.name._tablename == &#x27;person&#x27;</div><div class=""> True</div><div class=""> &gt;&gt;&gt; db.person.name._db == db</div><div class=""> True</div><div class=""> ``:code</div><div class=""> </div><div class=""> A field also has methods. Some of them are used to build queries and we will see them later.</div><div class=""> A special method of the field object is ``validate`` and it calls the validators for the field.</div><div class=""> </div><div class=""> ``</div><div class=""> print db.person.name.validate(&#x27;John&#x27;)</div><div class=""> ``</div><div class=""> </div><div class=""> which returns a tuple ``(value, error)``. ``error`` is ``None`` if the input passes validation.</div><div class=""> </div><div class="insert">+</div><div class="insert">+</div><div class=""> ### Migrations</div><div class=""> ``migrations``:inxx</div></div></div>
    <div class="span6"><div class="diff"><div class=""> </div><div class=""> ### Record representation</div><div class=""> </div><div class=""> It is optional but recommended to specify a format representation for records:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;), format=&#x27;%(name)s&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> or</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;), format=&#x27;%(name)s %(id)s&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> or even more complex ones using a function:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;),</div><div class="">        format=lambda r: r.name or &#x27;anonymous&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> The format attribute will be used for two purposes:</div><div class=""> False</div><div class=""> </div><div class=""> including its parent table, tablename, and parent connection:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.person.name._table == db.person</div><div class=""> True</div><div class=""> &gt;&gt;&gt; db.person.name._tablename == &#x27;person&#x27;</div><div class=""> True</div><div class=""> &gt;&gt;&gt; db.person.name._db == db</div><div class=""> True</div><div class=""> ``:code</div><div class=""> </div><div class=""> A field also has methods. Some of them are used to build queries and we will see them later.</div><div class=""> A special method of the field object is ``validate`` and it calls the validators for the field.</div><div class=""> </div><div class=""> ``</div><div class=""> print db.person.name.validate(&#x27;John&#x27;)</div><div class=""> ``</div><div class=""> </div><div class=""> which returns a tuple ``(value, error)``. ``error`` is ``None`` if the input passes validation.</div><div class=""> </div><div class=""> ### Migrations</div><div class=""> ``migrations``:inxx</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/dc4a99c7818e7510595150a5c7a4a5d204f5c092">dc4a99c</a><ul><li>Date : 2013-08-05</li><li>book edit for fake_migrate, thanks Jonathan (to myself: what took me so long?)</li></ul></li></ul>
<div class="row-fluid" id="com_dc4a99c7818e7510595150a5c7a4a5d204f5c092">
    <div class="span6"><div class="diff"><div class="insert">The first argument of ``define_table`` is always the table name. The other unnamed arguments are the fields (Field). The function also takes an optional <span class="highlight">keyword</span> argument called &quot;migrate&quot;<span class="highlight"></span>:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;), migrate=&#x27;person.table&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> The value of migrate is the filename (in the &quot;databases&quot; folder for the application) where web2py stores internal migration information for this table.</div><div class=""> These files are very important and should never be removed while the corresponding tables exist.  In cases where a table has been dropped and the corresponding file still exist, it can be removed manually. By default, migrate is set to True. This causes web2py to generate the filename from a hash of the connection string. If migrate is set to False, the migration is not performed, and web2py assumes that the table exists in the datastore and it contains (at least) the fields listed in ``define_table``.</div><div class=""> The best practice is to give an explicit name to the migrate table.</div><div class=""> </div><div class=""> There may not be two tables in the same application with the same migrate filename.</div><div class=""> </div><div class=""> The DAL class also takes a &quot;migrate&quot; argument, which determines the default value of migrate for calls to ``define_table``. For example,</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db = DAL(&#x27;sqlite://storage.db&#x27;, migrate=False)</div><div class=""> ``:code</div><div class=""> </div><div class=""> will set the default value of migrate to False whenever ``db.define_table`` is called without a migrate argument.</div><div class=""> </div><div class=""> ------</div><div class=""> Notice that web2py only migrates new columns, removed columns, and changes in column type (except in sqlite). web2py does not migrate changes in attributes such as changes in the values of ``default``, ``unique``, ``notnull``, and ``ondelete``.</div><div class=""> ------</div><div class=""> Migrations can be disabled for all tables at once:</div><div class=""> db = DAL(...,migrate_enabled=False)</div><div class=""> ``</div><div class=""> </div><div class=""> This is the recommended behavior when two apps share the same database. Only one of the two apps should perform migrations, the other should disabled them.</div><div class=""> </div><div class=""> ### Fixing broken migrations</div><div class=""> ``fake_migrate``:inxx</div><div class=""> </div><div class=""> There are two common problems with migrations and there are ways to recover from them.</div><div class=""> </div><div class=""> One problem is specific with SQLite. SQLite does not enforce column types and cannot drop columns. This means that if you have a column of type string and you remove it, it is not really removed. If you add the column again with a different type (for example datetime) you end up with a datetime column that contains strings (junk for practical purposes). web2py does not complain about this because it does not know what is in the database, until it tries to retrieve records and fails.</div><div class=""> </div><div class=""> If web2py returns an error in the gluon.sql.parse function when selecting records, this is the problem: corrupted data in a column because of the above issue.</div><div class=""> </div><div class=""> The solution consists in updating all records of the table and updating the values in the column in question with None.</div><div class=""> </div><div class=""> The other problem is more generic but typical with MySQL. MySQL does not allow more than one ALTER TABLE in a transaction. This means that web2py must break complex transactions into smaller ones (one ALTER TABLE at the time) and commit one piece at the time. It is therefore possible that part of a complex transaction gets committed and one part fails, leaving web2py in a corrupted state. Why would part of a transaction fail? Because, for example, it involves altering a table and converting a string column into a datetime column, web2py tries to convert the data, but the data cannot be converted. What happens to web2py? It gets confused about what exactly is the table structure actually stored in the database.</div><div class=""> </div><div class=""> The solution consists of disabling migrations for all tables and enabling fake migrations:</div><div class=""> ``</div><div class="insert">db.define_table(....,migrate=<span class="highlight">Tru</span>e,fake_migrate=True)</div><div class=""> ``:code</div><div class=""> </div><div class=""> This will rebuild web2py metadata about the table according to the table definition. Try multiple table definitions to see which one works (the one before the failed migration and the one after the failed migration). Once successful remove the ``fake_migrate=True`` attribute.</div><div class=""> </div><div class=""> Before attempting to fix migration problems it is prudent to make a copy of &quot;applications/yourapp/databases/*.table&quot; files.</div><div class=""> </div><div class=""> Migration problems can also be fixed for all tables at once:</div><div class=""> </div><div class=""> ``</div><div class=""> db = DAL(...,fake_migrate_all=True)</div><div class=""> ``:code</div><div class=""> </div><div class=""> This also fails if the model describes tables that do not exist in the database,</div><div class=""> but it can help narrowing down the problem.</div><div class=""> </div><div class="insert">+### Migration control summary</div><div class="insert">+</div><div class="insert">+The logic of the various migration arguments are summarized in this pseudo-code:</div><div class="insert">+``</div><div class="insert">+if DAL.migrate_enabled and table.migrate:</div><div class="insert">+   if DAL.fake_migrate_all or table.fake_migrate:</div><div class="insert">+       perform fake migration</div><div class="insert">+   else:</div><div class="insert">+       perform migration</div><div class="insert">+``:code</div><div class="insert">+</div><div class=""> ### ``insert``</div></div></div>
    <div class="span6"><div class="diff"><div class="delete">The first argument of ``define_table`` is always the table name. The other unnamed arguments are the fields (Field). The function also takes an optional <span class="highlight">last</span> argument called &quot;migrate&quot;<span class="highlight"> which must be referred to explicitly by name as in</span>:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;), migrate=&#x27;person.table&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> The value of migrate is the filename (in the &quot;databases&quot; folder for the application) where web2py stores internal migration information for this table.</div><div class=""> These files are very important and should never be removed while the corresponding tables exist.  In cases where a table has been dropped and the corresponding file still exist, it can be removed manually. By default, migrate is set to True. This causes web2py to generate the filename from a hash of the connection string. If migrate is set to False, the migration is not performed, and web2py assumes that the table exists in the datastore and it contains (at least) the fields listed in ``define_table``.</div><div class=""> The best practice is to give an explicit name to the migrate table.</div><div class=""> </div><div class=""> There may not be two tables in the same application with the same migrate filename.</div><div class=""> </div><div class=""> The DAL class also takes a &quot;migrate&quot; argument, which determines the default value of migrate for calls to ``define_table``. For example,</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db = DAL(&#x27;sqlite://storage.db&#x27;, migrate=False)</div><div class=""> ``:code</div><div class=""> </div><div class=""> will set the default value of migrate to False whenever ``db.define_table`` is called without a migrate argument.</div><div class=""> </div><div class=""> ------</div><div class=""> Notice that web2py only migrates new columns, removed columns, and changes in column type (except in sqlite). web2py does not migrate changes in attributes such as changes in the values of ``default``, ``unique``, ``notnull``, and ``ondelete``.</div><div class=""> ------</div><div class=""> Migrations can be disabled for all tables at once:</div><div class=""> db = DAL(...,migrate_enabled=False)</div><div class=""> ``</div><div class=""> </div><div class=""> This is the recommended behavior when two apps share the same database. Only one of the two apps should perform migrations, the other should disabled them.</div><div class=""> </div><div class=""> ### Fixing broken migrations</div><div class=""> ``fake_migrate``:inxx</div><div class=""> </div><div class=""> There are two common problems with migrations and there are ways to recover from them.</div><div class=""> </div><div class=""> One problem is specific with SQLite. SQLite does not enforce column types and cannot drop columns. This means that if you have a column of type string and you remove it, it is not really removed. If you add the column again with a different type (for example datetime) you end up with a datetime column that contains strings (junk for practical purposes). web2py does not complain about this because it does not know what is in the database, until it tries to retrieve records and fails.</div><div class=""> </div><div class=""> If web2py returns an error in the gluon.sql.parse function when selecting records, this is the problem: corrupted data in a column because of the above issue.</div><div class=""> </div><div class=""> The solution consists in updating all records of the table and updating the values in the column in question with None.</div><div class=""> </div><div class=""> The other problem is more generic but typical with MySQL. MySQL does not allow more than one ALTER TABLE in a transaction. This means that web2py must break complex transactions into smaller ones (one ALTER TABLE at the time) and commit one piece at the time. It is therefore possible that part of a complex transaction gets committed and one part fails, leaving web2py in a corrupted state. Why would part of a transaction fail? Because, for example, it involves altering a table and converting a string column into a datetime column, web2py tries to convert the data, but the data cannot be converted. What happens to web2py? It gets confused about what exactly is the table structure actually stored in the database.</div><div class=""> </div><div class=""> The solution consists of disabling migrations for all tables and enabling fake migrations:</div><div class=""> ``</div><div class="delete">db.define_table(....,migrate=<span class="highlight">Fals</span>e,fake_migrate=True)</div><div class=""> ``:code</div><div class=""> </div><div class=""> This will rebuild web2py metadata about the table according to the table definition. Try multiple table definitions to see which one works (the one before the failed migration and the one after the failed migration). Once successful remove the ``fake_migrate=True`` attribute.</div><div class=""> </div><div class=""> Before attempting to fix migration problems it is prudent to make a copy of &quot;applications/yourapp/databases/*.table&quot; files.</div><div class=""> </div><div class=""> Migration problems can also be fixed for all tables at once:</div><div class=""> </div><div class=""> ``</div><div class=""> db = DAL(...,fake_migrate_all=True)</div><div class=""> ``:code</div><div class=""> </div><div class=""> This also fails if the model describes tables that do not exist in the database,</div><div class=""> but it can help narrowing down the problem.</div><div class=""> </div><div class=""> ### ``insert``</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/25b48e10519bf6be1fcf7dd853f642da5a7524b8">25b48e1</a><ul><li>Date : 2013-06-25</li><li>computed fields can refer to earlier defined computed fields</li></ul></li></ul>
<div class="row-fluid" id="com_25b48e10519bf6be1fcf7dd853f642da5a7524b8">
    <div class="span6"><div class="diff"><div class="insert">+Computed fields are evaluated in the order in which they are defined in the table definition. A computed field can refer to previously defined computed fields (new after v 2.5.1)</div><div class="insert">+</div><div class=""> ### Virtual fields</div></div></div>
    <div class="span6"><div class="diff"><div class=""> ### Virtual fields</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/67961abf844c1076bc877583cf42b9720d89eeed">67961ab</a><ul><li>Date : 2013-06-04</li><li>Updated virtual fields to for changes of June 4</li></ul></li></ul>
<div class="row-fluid" id="com_67961abf844c1076bc877583cf42b9720d89eeed">
    <div class="span6"><div class="diff"><div class=""> ------</div><div class="insert">Mind that virtual fields do not have the same attributes as the other fields (default, readable, requires, etc)<span class="highlight">.  In older versions of web2py</span> they do not appear in the list of ``db.table.fields`` and <span class="highlight">the</span>y <span class="highlight">require a special approach to display in </span>SQLFORM.grid<span class="highlight"> and</span> SQLFORM.smartgrid<span class="highlight">. See the discussion on grids and virtual fields in the</span> For<span class="highlight"></span>ms chapter.</div><div class=""> ------</div></div></div>
    <div class="span6"><div class="diff"><div class=""> ------</div><div class="delete">Mind that virtual fields do not have the same attributes as the other fields (default, readable, requires, etc)<span class="highlight"> and</span> they do not appear in the list of ``db.table.fields`` and <span class="highlight">are not visualized b</span>y <span class="highlight">default in tables (TABLE) and grids (</span>SQLFORM.grid<span class="highlight">,</span> SQLFORM.smartgrid<span class="highlight">).</span> For<span class="highlight"> the grids, see the discussion on virtual fields in the For</span>ms chapter.</div><div class=""> ------</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/5ebcc42a6693401b956821b9bcae4a94afa3f869">5ebcc42</a><ul><li>Date : 2013-06-04</li><li>Explain the use of links to display virtual fields in grids</li></ul></li></ul>
<div class="row-fluid" id="com_5ebcc42a6693401b956821b9bcae4a94afa3f869">
    <div class="span6"><div class="diff"><div class=""> ------</div><div class="insert">Mind that virtual fields do not have the same attributes as the other fields (default, readable, requires, etc) and they do not appear in the list of ``db.table.fields`` and are not visualized by default in tables (TABLE) and grids (SQLFORM.grid, SQLFORM.smartgrid).<span class="highlight"> For the grids, see the discussion on virtual fields in the Forms chapter.</span></div><div class=""> ------</div></div></div>
    <div class="span6"><div class="diff"><div class=""> ------</div><div class="delete">Mind that virtual fields do not have the same attributes as the other fields (default, readable, requires, etc) and they do not appear in the list of ``db.table.fields`` and are not visualized by default in tables (TABLE) and grids (SQLFORM.grid, SQLFORM.smartgrid).<span class="highlight"></span></div><div class=""> ------</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/7a446d89ebb85821e59f8370cf12fdfda11fc300">7a446d8</a><ul><li>Date : 2013-06-04</li><li>fixed typo and unbalanced parantheses in ch 06 example about update_or_insert with criteria</li></ul></li></ul>
<div class="row-fluid" id="com_7a446d89ebb85821e59f8370cf12fdfda11fc300">
    <div class="span6"><div class="diff"><div class="insert">The selection criteria in the ex<span class="highlight">a</span>m<span class="highlight"></span>ple above is a single field. </div><div class=""> It can also be a query, such as </div><div class=""> ``</div><div class="insert">db.person.update_or_insert((db.person.name==&#x27;John&#x27;) &amp; (db.person.birthplace==&#x27;Chicago&#x27;)<span class="highlight"></span>,</div><div class="">      name=&#x27;John&#x27;,birthplace=&#x27;Chicago&#x27;,pet=&#x27;Rover&#x27;)</div><div class=""> ``:code</div></div></div>
    <div class="span6"><div class="diff"><div class="delete">The selection criteria in the ex<span class="highlight"></span>m<span class="highlight">a</span>ple above is a single field. </div><div class=""> It can also be a query, such as </div><div class=""> ``</div><div class="delete">db.person.update_or_insert((db.person.name==&#x27;John&#x27;) &amp; (db.person.birthplace==&#x27;Chicago&#x27;)<span class="highlight">)</span>,</div><div class="">      name=&#x27;John&#x27;,birthplace=&#x27;Chicago&#x27;,pet=&#x27;Rover&#x27;)</div><div class=""> ``:code</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/60e4c9465c6bef7f187d805ffe813ff6ae76e35c">60e4c94</a><ul><li>Date : 2013-05-14</li><li>clarifying that uploadfield takes on True/False</li></ul></li></ul>
<div class="row-fluid" id="com_60e4c9465c6bef7f187d805ffe813ff6ae76e35c">
    <div class="span6"><div class="diff"><div class=""> - ``ondelete`` translates into the &quot;ON DELETE&quot; SQL statement. By default it is set to &quot;CASCADE&quot;. This tells the database that when it deletes a record, it should also delete all records that refer to it. To disable this feature, set ``ondelete`` to &quot;NO ACTION&quot; or &quot;SET NULL&quot;.</div><div class=""> - ``notnull=True`` translates into the &quot;NOT NULL&quot; SQL statement. It prevents the database from inserting null values for the field.</div><div class=""> - ``unique=True`` translates into the &quot;UNIQUE&quot; SQL statement and it makes sure that values of this field are unique within the table. It is enforced at the database level.</div><div class="insert">- ``uploadfield`` applies only to fields of type &quot;upload&quot;. A field of type &quot;upload&quot; stores the name of a file saved somewhere else, by default on the filesystem under the application &quot;uploads/&quot; folder. If ``uploadfield`` is set<span class="highlight"> to True</span>, then the file is stored in a blob field within the same table and the value of ``uploadfield`` is the name of the blob field. This will be discussed in more detail later in the context of SQLFORM.</div></div></div>
    <div class="span6"><div class="diff"><div class=""> - ``ondelete`` translates into the &quot;ON DELETE&quot; SQL statement. By default it is set to &quot;CASCADE&quot;. This tells the database that when it deletes a record, it should also delete all records that refer to it. To disable this feature, set ``ondelete`` to &quot;NO ACTION&quot; or &quot;SET NULL&quot;.</div><div class=""> - ``notnull=True`` translates into the &quot;NOT NULL&quot; SQL statement. It prevents the database from inserting null values for the field.</div><div class=""> - ``unique=True`` translates into the &quot;UNIQUE&quot; SQL statement and it makes sure that values of this field are unique within the table. It is enforced at the database level.</div><div class="delete">- ``uploadfield`` applies only to fields of type &quot;upload&quot;. A field of type &quot;upload&quot; stores the name of a file saved somewhere else, by default on the filesystem under the application &quot;uploads/&quot; folder. If ``uploadfield`` is set<span class="highlight"></span>, then the file is stored in a blob field within the same table and the value of ``uploadfield`` is the name of the blob field. This will be discussed in more detail later in the context of SQLFORM.</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/1970e6f5596a96358cbcba2202bc1fa69211a389">1970e6f</a><ul><li>Date : 2013-04-21</li><li>updates</li></ul></li></ul>
<div class="row-fluid" id="com_1970e6f5596a96358cbcba2202bc1fa69211a389">
    <div class="span6"><div class="diff"><div class="insert">+The selection criteria in the exmaple above is a single field. </div><div class="insert">+It can also be a query, such as </div><div class="insert">+``</div><div class="insert">+db.person.update_or_insert((db.person.name==&#x27;John&#x27;) &amp; (db.person.birthplace==&#x27;Chicago&#x27;)),</div><div class="insert">+     name=&#x27;John&#x27;,birthplace=&#x27;Chicago&#x27;,pet=&#x27;Rover&#x27;)</div><div class="insert">+``:code</div><div class="insert">+</div><div class=""> #### ``validate_and_insert``, ``validate_and_update``</div></div></div>
    <div class="span6"><div class="diff"><div class=""> #### ``validate_and_insert``, ``validate_and_update``</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/9ea182b85a74864c21b9b17b703c8af4d071e274">9ea182b</a><ul><li>Date : 2013-04-18</li><li>More details to connection string for Google Cloud SQL.</li></ul></li></ul>
<div class="row-fluid" id="com_9ea182b85a74864c21b9b17b703c8af4d071e274">
    <div class="span6"><div class="diff"><div class=""> -------------</div><div class=""> **SQLite**     | ``sqlite://storage.db``</div><div class=""> **MySQL**      | ``mysql://username:password@localhost/test``</div><div class=""> **PostgreSQL** | ``postgres://username:password@localhost/test``</div><div class=""> **MSSQL**      | ``mssql://username:password@localhost/test``</div><div class=""> **FireBird**   | ``firebird://username:password@localhost/test``</div><div class=""> **Oracle**     | ``oracle://username/password@test``</div><div class=""> **DB2**        | ``db2://username:password@test``</div><div class=""> **Ingres**     | ``ingres://username:password@localhost/test``</div><div class=""> **Sybase**     | ``sybase://username:password@localhost/test``</div><div class=""> **Informix**   | ``informix://username:password@test``</div><div class=""> **Teradata**   | ``teradata://DSN=dsn;UID=user;PWD=pass;DATABASE=test``</div><div class=""> **Cubrid**     | ``cubrid://username:password@localhost/test``</div><div class=""> **SAPDB**      | ``sapdb://username:password@localhost/test``</div><div class=""> **IMAP**       | ``imap://user:password@server:port``</div><div class=""> **MongoDB**    | ``mongodb://username:password@localhost/test``</div><div class="insert">**Google/SQL** | ``google:sql<span class="highlight">://project:instance/database</span>``</div><div class=""> **Google/NoSQL** | ``google:datastore``</div><div class=""> -------------</div></div></div>
    <div class="span6"><div class="diff"><div class=""> -------------</div><div class=""> **SQLite**     | ``sqlite://storage.db``</div><div class=""> **MySQL**      | ``mysql://username:password@localhost/test``</div><div class=""> **PostgreSQL** | ``postgres://username:password@localhost/test``</div><div class=""> **MSSQL**      | ``mssql://username:password@localhost/test``</div><div class=""> **FireBird**   | ``firebird://username:password@localhost/test``</div><div class=""> **Oracle**     | ``oracle://username/password@test``</div><div class=""> **DB2**        | ``db2://username:password@test``</div><div class=""> **Ingres**     | ``ingres://username:password@localhost/test``</div><div class=""> **Sybase**     | ``sybase://username:password@localhost/test``</div><div class=""> **Informix**   | ``informix://username:password@test``</div><div class=""> **Teradata**   | ``teradata://DSN=dsn;UID=user;PWD=pass;DATABASE=test``</div><div class=""> **Cubrid**     | ``cubrid://username:password@localhost/test``</div><div class=""> **SAPDB**      | ``sapdb://username:password@localhost/test``</div><div class=""> **IMAP**       | ``imap://user:password@server:port``</div><div class=""> **MongoDB**    | ``mongodb://username:password@localhost/test``</div><div class="delete">**Google/SQL** | ``google:sql<span class="highlight"></span>``</div><div class=""> **Google/NoSQL** | ``google:datastore``</div><div class=""> -------------</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/6a1aeae64591ab64e493ae1a24bca312a01dabca">6a1aeae</a><ul><li>Date : 2013-04-17</li><li>updated ch6 drop to mention the need to delete a file if using sqlite</li></ul></li></ul>
<div class="row-fluid" id="com_6a1aeae64591ab64e493ae1a24bca312a01dabca">
    <div class="span6"><div class="diff"><div class="insert">+Note for sqlite: web2py will not re-create the dropped table until you navigate the file system to the databases directory of your app, and delete the file associated with the dropped table. </div><div class="insert">+</div><div class=""> ### Indexes</div></div></div>
    <div class="span6"><div class="diff"><div class=""> ### Indexes</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/739a4c66c06a1aa5de5f4bd07b49e2f04ec30290">739a4c6</a><ul><li>Date : 2013-04-04</li><li>English 5th: Various text corrections</li></ul></li></ul>
<div class="row-fluid" id="com_739a4c66c06a1aa5de5f4bd07b49e2f04ec30290">
    <div class="span6"><div class="diff"><div class=""> -------------</div><div class=""> **SQLite**     | ``sqlite://storage.db``</div><div class=""> **MySQL**      | ``mysql://username:password@localhost/test``</div><div class=""> **PostgreSQL** | ``postgres://username:password@localhost/test``</div><div class=""> **MSSQL**      | ``mssql://username:password@localhost/test``</div><div class=""> **FireBird**   | ``firebird://username:password@localhost/test``</div><div class=""> **Oracle**     | ``oracle://username/password@test``</div><div class=""> **DB2**        | ``db2://username:password@test``</div><div class=""> **Ingres**     | ``ingres://username:password@localhost/test``</div><div class=""> **Sybase**     | ``sybase://username:password@localhost/test``</div><div class=""> **Informix**   | ``informix://username:password@test``</div><div class="insert">**Teradata**   | ``teradata://DSN=dsn;UID=user;PWD=pass;DATABASE=<span class="highlight">t</span>e<span class="highlight">st</span>``</div><div class=""> **Cubrid**     | ``cubrid://username:password@localhost/test``</div><div class=""> **SAPDB**      | ``sapdb://username:password@localhost/test``</div><div class=""> **IMAP**       | ``imap://user:password@server:port``</div><div class=""> **MongoDB**    | ``mongodb://username:password@localhost/test``</div><div class=""> **Google/SQL** | ``google:sql``</div><div class=""> **Google/NoSQL** | ``google:datastore``</div><div class=""> -------------</div><div class=""> </div><div class=""> Notice that in SQLite the database consists of a single file. If it does not exist, it is created. This file is locked every time it is accessed. In the case of MySQL, PostgreSQL, MSSQL, FireBird, Oracle, DB2, Ingres and Informix the database &quot;test&quot; must be created outside web2py. Once the connection is established, web2py will create, alter, and drop tables appropriately.</div><div class=""> </div><div class=""> It is also possible to set the connection string to ``None``. In this case DAL will not connect to any back-end database, but the API can still be accessed for testing. Examples of this will be discussed in Chapter 7.</div><div class=""> </div><div class=""> Some times you may need to generate SQL as if you had a connection but without actually connecting to the database. This can be done with</div><div class=""> </div><div class=""> ``</div><div class=""> db = DAL(&#x27;...&#x27;, do_connect=False)</div><div class=""> ``:code</div><div class=""> </div><div class=""> In this case you will be able to call ``_select``, ``_insert``, ``_update``, and ``_delete`` to generate SQL but not call ``select``, ``insert``, ``update``, and ``delete``. In most of the cases you can use ``do_connect=False`` even without having the required database drivers.</div><div class=""> </div><div class=""> Notice that by default web2py uses utf8 character encoding for databases. If you work with existing databases that behave differently, you have to change it with the optional parameter ``db_codec`` like</div><div class=""> </div><div class=""> ``</div><div class=""> db = DAL(&#x27;...&#x27;, db_codec=&#x27;latin1&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class="insert">otherwise you&#x27;ll get UnicodeDecodeError<span class="highlight"></span> tickets.</div><div class=""> </div><div class=""> #### Connection pooling</div><div class=""> ``connection pooling``:inxx</div><div class=""> </div><div class=""> The second argument of the DAL constructor is the ``pool_size``; it defaults to zero.</div><div class=""> </div><div class=""> As it is rather slow to establish a new database connection for each request, web2py implements a mechanism for connection pooling. Once a connection is established and the page has been served and the transaction completed, the connection is not closed but goes into a pool. When the next http request arrives, web2py tries to recycle a connection from the pool and use that for the new transaction. If there are no available connections in the pool, a new connection is established.</div><div class=""> </div><div class=""> When web2py starts, the pool is always empty. The pool grows up to the minimum between the value of ``pool_size`` and the max number of concurrent requests. This means that if ``pool_size=10`` but our server never receives more than 5 concurrent requests, then the actual pool size will only grow to 5. If ``pool_size=0`` then connection pooling is not used.</div><div class=""> </div><div class=""> Connections in the pools are shared sequentially among threads, in the sense that they may be used by two different but not simultaneous threads. There is only one pool for each web2py process.</div><div class=""> </div><div class=""> The ``pool_size`` parameter is ignored by SQLite and Google App Engine.</div><div class=""> Connection pooling is ignored for SQLite, since it would not yield any benefit.</div><div class=""> </div><div class=""> #### Connection failures</div><div class=""> </div><div class=""> If web2py fails to connect to the database it waits 1 seconds and tries again up to 5 times before declaring a failure. In case of connection pooling it is possible that a pooled connection that stays open but unused for some time is closed by the database end. Thanks to the retry feature web2py tries to re-establish these dropped connections.</div><div class=""> </div><div class=""> #### Replicated databases</div><div class=""> </div><div class=""> The first argument of ``DAL(...)`` can be a list of URIs. In this case web2py tries to connect to each of them. The main purpose for this is to deal with multiple database servers and distribute the workload among them). Here is a typical use case:</div><div class=""> </div><div class=""> ``</div><div class=""> db = DAL([&#x27;mysql://...1&#x27;,&#x27;mysql://...2&#x27;,&#x27;mysql://...3&#x27;])</div><div class=""> ``:code</div><div class=""> </div><div class=""> In this case the DAL tries to connect to the first and, on failure, it</div><div class=""> will try the second and the third. This can also be used to distribute load</div><div class=""> in a database master-slave configuration. We will talk more about this</div><div class=""> in Chapter 13 in the context of scalability.</div><div class=""> </div><div class=""> ### Reserved keywords</div><div class=""> ``reserved Keywords``:inxx</div><div class=""> </div><div class="insert"><span class="highlight">``check_reserved`` is yet another</span> argument <span class="highlight">that can be passed to the DAL constructor. It tells it to check table names and column names against reserved SQL keywords in target back-end databases.</span> ``check_reserved`` <span class="highlight"></span>defaults to None.</div><div class=""> </div><div class=""> This is a list of strings that contain the database back-end adapter names.</div><div class=""> </div><div class=""> The adapter name is the same as used in the DAL connection string. So if you want to check against PostgreSQL and MSSQL then your connection string would look as follows:</div><div class=""> ``</div><div class=""> db = DAL(&#x27;sqlite://storage.db&#x27;,</div><div class="">          check_reserved=[&#x27;postgres&#x27;, &#x27;mssql&#x27;])</div><div class=""> ``:code</div><div class=""> </div><div class=""> The DAL will scan the keywords in the same order as of the list.</div><div class=""> </div><div class=""> There are two extra options &quot;all&quot; and &quot;common&quot;. If you specify all, it will check against all known SQL keywords. If you specify common, it will only check against common SQL keywords such as ``SELECT``, ``INSERT``, ``UPDATE``, etc.</div><div class=""> </div><div class=""> For supported back-ends you may also specify if you would like to check against the non-reserved SQL keywords as well. In this case you would append ``_nonreserved`` to the name. For example:</div><div class=""> ``</div><div class=""> check_reserved=[&#x27;postgres&#x27;, &#x27;postgres_nonreserved&#x27;]</div><div class=""> ``:code</div><div class=""> </div><div class=""> The following database backends support reserved words checking.</div><div class=""> </div><div class=""> The most important method of a DAL is ``define_table``:</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class=""> It defines, stores and returns a ``Table`` object called &quot;person&quot; containing a field (column) &quot;name&quot;. This object can also be accessed via ``db.person``, so you do not need to catch the return value.</div><div class=""> </div><div class=""> Do not declare a field called &quot;id&quot;, because one is created by web2py anyway. Every table has a field called &quot;id&quot; by default. It is an auto-increment integer field (starting at 1) used for cross-reference and for making every record unique, so &quot;id&quot; is a primary key. (Note: the id&#x27;s starting at 1 is back-end specific. For example, this does not apply to the Google App Engine NoSQL.)</div><div class=""> </div><div class=""> ``named id field``:inxx</div><div class=""> Optionally you can define a field of ``type=&#x27;id&#x27;`` and web2py will use this field as auto-increment id field. This is not recommended except when accessing legacy database tables. With some limitation, you can also use different primary keys and this is discussed in the section on &quot;Legacy databases and keyed tables&quot;.</div><div class=""> </div><div class=""> Tables can be defined only once but you can force web2py to redefine an existing table:</div><div class=""> </div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;))</div><div class=""> db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;), redefine=True)</div><div class=""> ``:code</div><div class=""> </div><div class=""> The redefinition may trigger a migration if field content is different.</div><div class=""> </div><div class=""> ----------</div><div class="insert">Because usually in web2py models are executed before controllers, it is possible that some table are defined even if not needed. It is therefore necessary to speed up the code by making table definitions lazy. This is done by setting the ``DAL(...,lazy_tables=True)`` attribute<span class="highlight"></span>. Tables will be actually created only when accessed.</div><div class=""> ----------</div><div class=""> </div><div class=""> </div><div class=""> ### Record representation</div><div class=""> </div><div class=""> It is optional but recommended to specify a format representation for records:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;), format=&#x27;%(name)s&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> or</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;), format=&#x27;%(name)s %(id)s&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> or even more complex ones using a function:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;),</div><div class="">        format=lambda r: r.name or &#x27;anonymous&#x27;)</div><div class=""> ``:code</div><div class=""> All queries are automatically timed by web2py. The variable ``db._timings`` is a</div><div class=""> {{=response.toolbar()}}</div><div class=""> ``</div><div class=""> </div><div class=""> #### ``executesql``</div><div class=""> </div><div class=""> The DAL allows you to explicitly issue SQL statements.</div><div class=""> </div><div class=""> ``executesql``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; print db.executesql(&#x27;SELECT * FROM person;&#x27;)</div><div class=""> [(1, u&#x27;Massimo&#x27;), (2, u&#x27;Massimo&#x27;)]</div><div class=""> ``:code</div><div class=""> </div><div class=""> In this case, the return values are not parsed or transformed by the DAL, and the format depends on the specific database driver. This usage with selects is normally not needed, but it is more common with indexes.</div><div class=""> ``executesql`` takes four optional arguments: ``placeholders``, ``as_dict``, ``fields`` and ``colnames``.</div><div class=""> ``placeholders`` is an optional</div><div class=""> sequence of values to be substituted in</div><div class=""> or, if supported by the DB driver, a dictionary with keys</div><div class=""> matching named placeholders in your SQL.</div><div class=""> </div><div class="insert"><span class="highlight">If ``as_dict`` is set to True, the results cursor returned by the DB driver will be converted to a sequence of dictionaries keyed with the db field names.  Results returned with ``as_dict = True`` are </span>the same as those returned when applying **.as_list()** to a normal select.</div><div class=""> ``</div><div class=""> [{field1: value1, field2: value2}, {field1: value1b, field2: value2b}]</div><div class=""> ``:code</div><div class=""> </div><div class=""> The ``fields`` argument is a list of DAL Field objects that match the</div><div class=""> fields returned from the DB. The Field objects should be part of one or</div><div class=""> more Table objects defined on the DAL object. The ``fields`` list can</div><div class=""> include one or more DAL Table objects in addition to or instead of</div><div class=""> including Field objects, or it can be just a single table (not in a</div><div class=""> list). In that case, the Field objects will be extracted from the</div><div class=""> table(s).</div><div class=""> </div><div class=""> Instead of specifying the ``fields`` argument, the ``colnames`` argument</div><div class=""> can be specified as a list of field names in tablename.fieldname format.</div><div class=""> Again, these should represent tables and fields defined on the DAL</div><div class=""> object.</div><div class=""> </div><div class=""> It is also possible to specify both ``fields`` and the associated</div><div class=""> ``colnames``. In that case, ``fields`` can also include DAL Expression</div><div class=""> objects in addition to Field objects. For Field objects in &quot;fields&quot;,</div><div class=""> Here is an example:</div><div class=""> ``SQLFORM.grid``:inxx ``SQLFORM.smartgrid``:inxx</div><div class=""> </div><div class=""> ------</div><div class=""> ``SQLTABLE`` is useful but there are times when one needs more. ``SQLFORM.grid`` is an extension of SQLTABLE that creates a table with search features and pagination, as well as ability to open detailed records, create, edit and delete records. ``SQLFORM.smartgrid`` is a further generalization that allows all of the above but also creates buttons to access referencing records.</div><div class=""> ------</div><div class=""> </div><div class=""> Here is an example of usage of ``SQLFORM.grid``:</div><div class=""> </div><div class=""> ``</div><div class=""> def index():</div><div class="">     return dict(grid=SQLFORM.grid(query))</div><div class=""> ``:code</div><div class=""> </div><div class=""> and the corresponding view:</div><div class=""> </div><div class=""> ``</div><div class=""> {{extend &#x27;layout.html&#x27;}}</div><div class=""> {{=grid}}</div><div class=""> ``</div><div class=""> </div><div class="insert">``SQLFORM.grid`` and ``SQLFORM.smartgrid`` should be preferred to ``SQLTABLE`` because they are more powerful although higher level and therefore more constraining. They will be explained in more detail in chapter <span class="highlight">7.</span></div><div class=""> </div><div class=""> #### ``orderby``, ``groupby``, ``limitby``, ``distinct``, ``having``</div><div class=""> </div><div class=""> The ``select`` command takes five optional arguments: orderby, groupby, limitby, left and cache. Here we discuss the first three.</div><div class=""> </div><div class=""> You can fetch the records sorted by name:</div><div class=""> </div><div class=""> ``orderby``:inxx ``groupby``:inxx ``having``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db().select(</div><div class="">         db.person.ALL, orderby=db.person.name):</div><div class="">         print row.name</div><div class=""> Alex</div><div class=""> Bob</div><div class=""> Carl</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can fetch the records sorted by name in reverse order (notice the tilde):</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db().select(</div><div class=""> name</div><div class=""> Max</div><div class=""> Tim</div><div class=""> John</div><div class=""> Tim</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can do a union of the records removing duplicates:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows3 = rows1 | rows2</div><div class=""> &gt;&gt;&gt; print rows3</div><div class=""> name</div><div class=""> Max</div><div class=""> Tim</div><div class=""> John</div><div class=""> ``:code</div><div class=""> </div><div class=""> #### ``find``, ``exclude``, ``sort``</div><div class=""> ``find``:inxx ``exclude``:inxx ``sort``:inxx</div><div class=""> </div><div class="insert">Some times you<span class="highlight"> need</span> to perform two selects and one contains a subset of a previous select. In this case it is pointless to access the database again. The ``find``, ``exclude`` and ``sort`` objects allow you to manipulate a Rows objects and generate another one without accessing the database. More specifically:</div><div class=""> - ``find`` returns a new set of Rows filtered by a condition and leaves the original unchanged.</div><div class=""> - ``exclude`` returns a new set of Rows filtered by a condition and removes them from the original Rows.</div><div class=""> - ``sort`` returns a new set of Rows sorted by a condition and leaves the original unchanged.</div><div class=""> </div><div class=""> All these methods take a single argument, a function that acts on each individual row.</div><div class=""> </div><div class=""> Here is an example of usage:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;,Field(&#x27;name&#x27;))</div><div class=""> &gt;&gt;&gt; db.person.insert(name=&#x27;John&#x27;)</div><div class=""> &gt;&gt;&gt; db.person.insert(name=&#x27;Max&#x27;)</div><div class=""> &gt;&gt;&gt; db.person.insert(name=&#x27;Alex&#x27;)</div><div class=""> &gt;&gt;&gt; rows = db(db.person).select()</div><div class=""> &gt;&gt;&gt; for row in rows.find(lambda row: row.name[0]==&#x27;M&#x27;):</div><div class="">         print row.name</div><div class=""> Max</div><div class=""> &gt;&gt;&gt; print len(rows)</div><div class=""> 3</div><div class=""> &gt;&gt;&gt; for row in rows.exclude(lambda row: row.name[0]==&#x27;M&#x27;):</div><div class="">         print row.name</div><div class=""> Max</div><div class=""> &gt;&gt;&gt; for row in rows.sort(lambda row: row.name):</div><div class="">         print row.name</div><div class=""> Alex</div><div class=""> John</div><div class=""> ``:code</div><div class=""> </div><div class=""> They can be combined:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows = db(db.person).select()</div><div class=""> &gt;&gt;&gt; rows = rows.find(</div><div class="">         lambda row: &#x27;x&#x27; in row.name).sort(</div><div class="">             lambda row: row.name)</div><div class=""> &gt;&gt;&gt; for row in rows:</div><div class="">         print row.name</div><div class=""> Alex</div><div class=""> Max</div><div class=""> ``:code</div><div class=""> </div><div class=""> Sort takes an optional argument ``reverse=True`` with the obvious meaning.</div><div class=""> </div><div class="insert">The ``find`` method <span class="highlight">h</span>as an optional limitby argument with the same syntax and functionality as the Set select ``method``.</div><div class=""> </div><div class=""> </div><div class=""> </div><div class=""> ### Other methods</div><div class=""> </div><div class=""> #### ``update_or_insert``</div><div class=""> ``update_or_insert``:inxx</div><div class=""> </div><div class=""> Some times you need to perform an insert only if there is no record with the same values as those being inserted.</div><div class=""> This can be done with</div><div class=""> </div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;,Field(&#x27;name&#x27;),Field(&#x27;birthplace&#x27;))</div><div class=""> db.person.update_or_insert(name=&#x27;John&#x27;,birthplace=&#x27;Chicago&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class="insert">The record will be inserted only <span class="highlight">i</span>f there is no other user called John born in Chicago.</div><div class=""> </div><div class=""> You can specify which values to use as a key to determine if the record exists. For example:</div><div class=""> ``</div><div class=""> db.person.update_or_insert(db.person.name==&#x27;John&#x27;,</div><div class="">      name=&#x27;John&#x27;,birthplace=&#x27;Chicago&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> and if there is John his birthplace will be updated else a new record will be created.</div><div class=""> </div><div class=""> #### ``validate_and_insert``, ``validate_and_update``</div><div class=""> </div><div class=""> ``validate_and_insert``:inxx ``validate_and_update``:inxx</div><div class=""> </div><div class=""> The function</div><div class=""> </div><div class=""> ``</div><div class=""> ret = db.mytable.validate_and_insert(field=&#x27;value&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> works very much like</div><div class=""> </div><div class=""> ``</div><div class=""> id = db.mytable.insert(field=&#x27;value&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> except that it calls the validators for the fields before performing the insert and bails out if the validation does not pass. If validation does not pass the errors can be found in ``ret.error``. If it passes, the id of the new record is in ``ret.id``. Mind that normally validation is done by the form processing logic so this function is rarely needed.</div><div class=""> </div><div class=""> Similarly</div><div class=""> </div><div class=""> ``</div><div class=""> ret = db(query).validate_and_update(field=&#x27;value&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> works very much the same as</div><div class=""> </div><div class=""> ``</div><div class=""> num = db(query).update(field=&#x27;value&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class="insert">except that it calls the validators for <span class="highlight"></span>the fields before performing the update. Notice that it only works if query involves a single table. The number of updated records can be found in ``res.updated`` and errors will be ``ret.errors``.</div><div class=""> </div><div class=""> #### ``smart_query`` (experimental)</div><div class=""> </div><div class=""> There are times when you need to parse a query using natural language such as</div><div class=""> </div><div class=""> ``</div><div class=""> name contain m and age greater than 18</div><div class=""> ``</div><div class=""> </div><div class=""> The DAL provides a method to parse this type of queries:</div><div class=""> </div><div class=""> ``</div><div class=""> search = &#x27;name contain m and age greater than 18&#x27;</div><div class=""> rows = db.smart_query([db.person],search).select()</div><div class=""> ``</div><div class=""> </div><div class=""> The first argument must be a list of tables or fields that should be allowed in the search. It raises a ``RuntimeError`` if the search string is invalid. This functionality can be used to build RESTful interfaces (see chapter 10) and it is used internally by the ``SQLFORM.grid`` and ``SQLFORM.smartgrid``.</div><div class=""> </div><div class=""> In the smartquery search string, a field can be identified by fieldname only and or by tablename.fieldname. Strings may be delimited by double quotes if they contain spaces.</div><div class=""> </div><div class=""> left = db.thing.on(...)</div><div class=""> ``:code</div><div class=""> </div><div class=""> does the left join query. Here the argument of ``db.thing.on`` is the condition required for the join (the same used above for the inner join). In the case of a left join, it is necessary to be explicit about which fields to select.</div><div class=""> </div><div class=""> Multiple left joins can be combined by passing a list or tuple of ``db.mytable.on(...)`` to the  ``left`` attribute.</div><div class=""> </div><div class=""> #### Grouping and counting</div><div class=""> </div><div class=""> When doing joins, sometimes you want to group rows according to certain criteria and count them. For example, count the number of things owned by every person. web2py allows this as well. First, you need a count operator. Second, you want to join the person table with the thing table by owner. Third, you want to select all rows (person + thing), group them by person, and count them while grouping:</div><div class=""> </div><div class=""> ``grouping``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; count = db.person.id.count()</div><div class=""> &gt;&gt;&gt; for row in db(db.person.id==db.thing.owner_id).select(</div><div class="">         db.person.name, count, groupby=db.person.name):</div><div class="">         print row.person.name, row[count]</div><div class=""> Alex 2</div><div class=""> Bob 1</div><div class=""> ``:code</div><div class=""> </div><div class="insert">Notice the <span class="highlight">``count``</span> operator (which is built-in) is used as a field. The only issue here is in how to retrieve the information. Each row clearly contains a person and the count, but the count is not a field of a person nor is it a table. So where does it go? It goes into the storage object representing the record with a key equal to the query expression itself. The count method of the Field object has an optional ``distinct`` argument. When set to ``True`` it specifies that only distinct values of the field in question are to be counted.</div><div class=""> </div><div class=""> ### Many to many</div><div class=""> ``many-to-many``:inxx</div><div class=""> In the previous examples, we allowed a thing to have one owner but one person could have many things. What if Boat was owned by Alex and Curt? This requires a many-to-many relation, and it is realized via an intermediate table that links a person to a thing via an ownership relation.</div><div class=""> </div><div class=""> Here is how to do it:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;,</div><div class="">                     Field(&#x27;name&#x27;))</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;thing&#x27;,</div><div class="">                     Field(&#x27;name&#x27;))</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;ownership&#x27;,</div><div class="">                     Field(&#x27;person&#x27;, &#x27;reference person&#x27;),</div><div class="">                     Field(&#x27;thing&#x27;, &#x27;reference thing&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class=""> the existing ownership relationship can now be rewritten as:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.ownership.insert(person=1, thing=1) # Alex owns Boat</div><div class=""> &gt;&gt;&gt; db.ownership.insert(person=1, thing=2) # Alex owns Chair</div><div class=""> or any value from the list</div><div class=""> db.mytable.myfield.contains([&#x27;value1&#x27;,&#x27;value2&#x27;], all=false)</div><div class=""> ``</div><div class=""> </div><div class=""> There is a also a ``regexp`` method that works like the ``like`` method but allows regular expression syntax for the look-up expression. It is only supported by PostgreSQL and SQLite.</div><div class=""> </div><div class=""> The ``upper`` and ``lower`` methods allow you to convert the value of the field to upper or lower case, and you can also combine them with the like operator:</div><div class=""> </div><div class=""> ``upper``:inxx ``lower``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db(db.log.event.upper().like(&#x27;PORT%&#x27;)).select():</div><div class="">         print row.event</div><div class=""> port scan</div><div class=""> ``:code</div><div class=""> </div><div class=""> #### ``year``, ``month``, ``day``, ``hour``, ``minutes``, ``seconds``</div><div class=""> ``hour``:inxx ``minutes``:inxx ``seconds``:inxx ``day``:inxx ``month``:inxx ``year``:inxx</div><div class=""> </div><div class=""> The date and datetime fields have day, month and year methods. The datetime and time fields have hour, minutes and seconds methods. Here is an example:</div><div class=""> </div><div class=""> ``</div><div class="insert">&gt;&gt;&gt; for row in db(db.log.event_time.year()==20<span class="highlight">13</span>).select():</div><div class="">         print row.event</div><div class=""> port scan</div><div class=""> xss injection</div><div class=""> unauthorized login</div><div class=""> ``:code</div><div class=""> </div><div class=""> #### ``belongs``</div><div class=""> </div><div class="insert">The SQL IN operator is realized via the belongs method which returns true when the field value belongs to the specified set (list o<span class="highlight">r</span> tuples):</div><div class=""> </div><div class=""> ``belongs``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db(db.log.severity.belongs((1, 2))).select():</div><div class="">         print row.event</div><div class=""> port scan</div><div class=""> xss injection</div><div class=""> ``:code</div><div class=""> </div><div class=""> The DAL also allows a nested select as the argument of the belongs operator. The only caveat is that the nested select has to be a ``_select``, not a ``select``, and only one field has to be selected explicitly, the one that defines the set.</div><div class=""> </div><div class=""> ``nested select``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; bad_days = db(db.log.severity==3)._select(db.log.event_time)</div><div class=""> &gt;&gt;&gt; for row in db(db.log.event_time.belongs(bad_days)).select():</div><div class="">         print row.event</div><div class=""> port scan</div><div class=""> xss injection</div><div class=""> unauthorized login</div><div class=""> ``:code</div><div class=""> </div><div class=""> In those cases where a nested select is required and the look-up field is a reference we can also use a query as argument. For example:</div><div class=""> </div><div class=""> ``</div><div class="insert">+db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;))</div><div class="insert">+db.define_table(&#x27;thing&#x27;, Field(&#x27;name&#x27;), Field(&#x27;owner_id&#x27;, &#x27;reference thing&#x27;))</div><div class=""> db(db.thing.owner_id.belongs(db.person.name==&#x27;Jonathan&#x27;)).select()</div><div class=""> ``:code</div><div class=""> </div><div class=""> In this case it is obvious that the next select only needs the field referenced by the ``db.thing.owner_id`` field so we do not need the more verbose ``_select`` notation.</div><div class=""> </div><div class=""> ``nested_select``:inxx</div><div class=""> </div><div class=""> A nested select can also be used as insert/update value but in this case the syntax is different:</div><div class=""> </div><div class=""> ``</div><div class=""> lazy = db(db.person.name==&#x27;Jonathan&#x27;).nested_select(db.person.id)</div><div class=""> db(db.thing.id==1).update(owner_id = lazy)</div><div class=""> ``:code</div><div class=""> </div><div class=""> In this case ``lazy`` is a nested expression that computes the ``id`` of person &quot;Jonathan&quot;. The two lines result in one single SQL query.</div><div class=""> </div><div class=""> #### ``sum``, ``avg``, ``min``, ``max`` and ``len``</div><div class=""> </div><div class=""> ``sum``:inxx ``avg``:inxx ``min``:inxx ``max``:inxx</div><div class=""> Previously, you have used the count operator to count records. Similarly, you can use the sum operator to add (sum) the values of a specific field from a group of records. As in the case of count, the result of a sum is retrieved via the store object:</div><div class=""> if not db(db.person).count():</div><div class=""> ``:code</div><div class=""> </div><div class=""> Each record is identified by an ID and referenced by that ID. If you</div><div class=""> have two copies of the database used by distinct web2py installations,</div><div class=""> the ID is unique only within each database and not across the databases.</div><div class=""> This is a problem when merging records from different databases.</div><div class=""> </div><div class=""> In order to make a record uniquely identifiable across databases, they</div><div class=""> must:</div><div class=""> - have a unique id (UUID),</div><div class=""> - have an event_time (to figure out which one is more recent if multiple copies),</div><div class=""> - reference the UUID instead of the id.</div><div class=""> </div><div class=""> This can be achieved without modifying web2py. Here is what to do:</div><div class=""> </div><div class=""> Change the above model into:</div><div class=""> </div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;,</div><div class="">     Field(&#x27;uuid&#x27;, length=64, default=lambda:str(uuid.uuid4())),</div><div class="insert">    Field(&#x27;modified_on&#x27;, &#x27;datetime&#x27;, default=<span class="highlight">request.</span>now),</div><div class="">     Field(&#x27;name&#x27;),</div><div class="">     format=&#x27;%(name)s&#x27;)</div><div class=""> </div><div class=""> db.define_table(&#x27;thing&#x27;,</div><div class="">     Field(&#x27;uuid&#x27;, length=64, default=lambda:str(uuid.uuid4())),</div><div class="insert">    Field(&#x27;modified_on&#x27;, &#x27;datetime&#x27;, default=<span class="highlight">request.</span>now),</div><div class="">     Field(&#x27;owner_id&#x27;, length=64),</div><div class="">     Field(&#x27;name&#x27;),</div><div class="">     format=&#x27;%(name)s&#x27;)</div><div class=""> </div><div class=""> db.thing.owner_id.requires = IS_IN_DB(db,&#x27;person.uuid&#x27;,&#x27;%(name)s&#x27;)</div><div class=""> </div><div class=""> if not db(db.person.id).count():</div><div class="">     id = uuid.uuid4()</div><div class="">     db.person.insert(name=&quot;Massimo&quot;, uuid=id)</div><div class="">     db.thing.insert(owner_id=id, name=&quot;Chair&quot;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> -------</div><div class=""> Notice that in the above table definitions, the default value for the two ``uuid`` fields is set to a lambda function, which returns a UUID (converted to a string). The lambda function is called once for each record inserted, ensuring that each record gets a unique UUID, even if multiple records are inserted in a single transaction.</div><div class=""> -------</div><div class=""> </div><div class=""> Create a controller action to export the database:</div><div class=""> </div><div class=""> ``</div><div class=""> def export():</div><div class=""> The ``export_to_csv_file`` function accepts a keyword argument named ``represent</div><div class=""> ``colnames``:inxx</div><div class=""> The function also accepts a keyword argument named ``colnames`` that should contain a list of column names one wish to export. It defaults to all columns.</div><div class=""> </div><div class=""> Both ``export_to_csv_file`` and ``import_from_csv_file`` accept keyword arguments that tell the csv parser the format to save/load the files:</div><div class=""> - ``delimiter``: delimiter to separate values (default &#x27;,&#x27;)</div><div class=""> - ``quotechar``: character to use to quote string values (default to double quotes)</div><div class=""> - ``quoting``: quote system (default ``csv.QUOTE_MINIMAL``)</div><div class=""> </div><div class=""> Here is some example usage:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; import csv</div><div class=""> &gt;&gt;&gt; rows = db(query).select()</div><div class=""> &gt;&gt;&gt; rows.export_to_csv_file(open(&#x27;/tmp/test.txt&#x27;, &#x27;w&#x27;),</div><div class="">         delimiter=&#x27;|&#x27;,</div><div class="">         quotechar=&#x27;&quot;&#x27;,</div><div class="">         quoting=csv.QUOTE_NONNUMERIC)</div><div class=""> ``:code</div><div class=""> </div><div class=""> Which would render something similar to</div><div class=""> ``</div><div class="insert">&quot;hello&quot;|35|&quot;this is the text description&quot;|&quot;20<span class="highlight">13</span>-03-03&quot;</div><div class=""> ``:code</div><div class=""> </div><div class=""> For more information consult the official Python documentation ``quoteall``:cite</div><div class=""> </div><div class=""> ### Caching selects</div><div class=""> </div><div class=""> The select method also takes a cache argument, which defaults to None. For caching purposes, it should be set to a tuple where the first element is the cache model (cache.ram, cache.disk, etc.), and the second element is the expiration time in seconds.</div><div class=""> </div><div class=""> In the following example, you see a controller that caches a select on the previously defined db.log table. The actual select fetches data from the back-end database no more frequently than once every 60 seconds and stores the result in cache.ram. If the next call to this controller occurs in less than 60 seconds since the last database IO, it simply fetches the previous data from cache.ram.</div><div class=""> </div><div class=""> ``cache select``:inxx</div><div class=""> ``</div><div class=""> def cache_db_select():</div><div class="">     logs = db().select(db.log.ALL, cache=(cache.ram, 60))</div><div class="">     return dict(logs=logs)</div><div class=""> ``:code</div><div class=""> </div><div class=""> ``cacheable``:inxx</div><div class=""> </div><div class=""> The ``select`` method has an optional ``cacheable`` argument, normally set to ``False``. When ``cacheable=True`` the resulting ``Rows`` is serializable but The ``Row``s lack ``update_record`` and ``delete_record`` methods.</div><div class=""> This is best explained via some examples.</div><div class=""> ``:code</div><div class=""> </div><div class=""> Here ``f`` is a dict of fields passed to insert or update, ``id`` is the id of the newly inserted record, ``s`` is the Set object used for update or delete.</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.person.insert(name=&#x27;John&#x27;)</div><div class=""> ({&#x27;name&#x27;: &#x27;John&#x27;},)</div><div class=""> ({&#x27;name&#x27;: &#x27;John&#x27;}, 1)</div><div class=""> &gt;&gt;&gt; db(db.person.id==1).update(name=&#x27;Tim&#x27;)</div><div class=""> (&lt;Set (person.id = 1)&gt;, {&#x27;name&#x27;: &#x27;Tim&#x27;})</div><div class=""> (&lt;Set (person.id = 1)&gt;, {&#x27;name&#x27;: &#x27;Tim&#x27;})</div><div class=""> &gt;&gt;&gt; db(db.person.id==1).delete()</div><div class=""> (&lt;Set (person.id = 1)&gt;,)</div><div class=""> (&lt;Set (person.id = 1)&gt;,)</div><div class=""> ``:code</div><div class=""> </div><div class=""> The return values of these callback should be ``None`` or ``False``. If any of the ``_before_*`` callback returns a ``True`` value it will abort the actual insert/update/delete operation.</div><div class=""> </div><div class=""> ``update_naive``:inxx.</div><div class=""> </div><div class="insert">Some times a callback may need to perform an update in the same o<span class="highlight">r</span> a different table and one wants to avoid callbacks calling themselves recursively.</div><div class=""> </div><div class=""> For this purpose there the Set objects have an ``update_naive`` method that works like ``update`` but ignores before and after callbacks.</div><div class=""> </div><div class=""> #### Record versioning</div><div class=""> </div><div class=""> ``_enable_record_versioning``:inxx</div><div class=""> </div><div class=""> It is possible to ask web2py to save every copy of a record when the record is individually modified. There are different ways to do it and it can be done for all tables at once using the syntax:</div><div class=""> </div><div class=""> ``</div><div class=""> auth.enable_record_versioning(db)</div><div class=""> ``:code</div><div class=""> </div><div class=""> this requires Auth and it is discussed in the chapter about authentication.</div><div class=""> It can also be done for each individual table as discussed below.</div><div class=""> </div><div class=""> Consider the following table:</div><div class=""> </div><div class=""> ``</div><div class=""> db.define_table(&#x27;stored_item&#x27;,</div><div class=""> True.</div><div class=""> </div><div class=""> We can tell web2py to create a new table (in the same or a different database) and store all previous versions of each record in the table, when modified.</div><div class=""> </div><div class=""> This is done in the following way:</div><div class=""> ``</div><div class=""> db.stored_item._enable_record_versioning()</div><div class=""> ``:code</div><div class=""> </div><div class=""> or in a more verbose syntax:</div><div class=""> </div><div class=""> ``</div><div class=""> db.stored_item._enable_record_versioning(</div><div class="">     archive_db = db,</div><div class="">     archive_name = &#x27;stored_item_archive&#x27;,</div><div class="">     current_record = &#x27;current_record&#x27;,</div><div class="">     is_active = &#x27;is_active&#x27;)</div><div class=""> ``</div><div class=""> </div><div class=""> The ``archive_db=db`` tells web2py to store the archive table in the same database as the ``stored_item`` table. The ``archive_name`` sets the name for the archive table. The archive table has the same fields as the original table ``stored_item`` except that unique fields are no longer unique (because it needs to store multiple versions) and has an extra field which name is specified by ``current_record`` and which is a reference to the current record in the ``stored_item`` table.</div><div class=""> </div><div class="insert">When records are deleted, they are not really deleted. A deleted record is copied in the ``stored_item_archive`` table (like when it is modified) and the ``is_active`` field is set to False. By enabling record versioning web2py sets a ``custom_filter`` on this table that hides all <span class="highlight">recor</span>ds in table ``stored_item`` where the ``is_active`` field is set to False. The ``is_active`` parameter in the ``_enable_record_versioning`` method allows to specify the name of the field used by the ``custom_filter`` to determine if the field was deleted or not.</div><div class=""> </div><div class=""> ``custom_filter``s are ignored by the appadmin interface.</div><div class=""> </div><div class=""> #### Common fields and multi-tenancy</div><div class=""> ``common fields``:inxx</div><div class=""> ``multi tenancy``:inxx</div><div class=""> </div><div class=""> ``db._common_fields`` is a list of fields that should belong to all the tables. This list can also contain tables and it is understood as all fields from the table. For example occasionally you find yourself in need to add a signature to all your tables but the ```auth`` tables. In this case, after you ``db.define_tables()`` but before defining any other table, insert</div><div class=""> </div><div class=""> ``</div><div class=""> db._common_fields.append(auth.signature)</div><div class=""> ``</div><div class=""> </div><div class=""> One field is special: &quot;request_tenant&quot;.</div><div class=""> This field does not exist but you can create it and add it to any of your tables (or them all):</div><div class=""> </div><div class=""> ``</div><div class=""> db._common_fields.append(Field(&#x27;request_tenant&#x27;,</div><div class="">     default=request.env.http_host,writable=False))</div><div class=""> ``</div><div class=""> Any select, delete or update in this table, will include only public blog posts.</div><div class=""> ``</div><div class=""> db.blog_post._common_filter = lambda query: db.blog_post.is_public == True</div><div class=""> ``</div><div class=""> </div><div class=""> It serves both as a way to avoid repeating the &quot;db.blog_post.is_public==True&quot; phrase in each blog post search, and also as a security enhancement, that prevents you from forgetting to disallow viewing of none public posts.</div><div class=""> </div><div class=""> In case you actually do want items left out by the common filter (for example, allowing the admin to see none public posts), you can either remove the filter:</div><div class=""> ``</div><div class=""> db.blog_post._common_filter = None</div><div class=""> ``</div><div class=""> or ignore it:</div><div class=""> ``</div><div class=""> db(query, ignore_common_filters=True).select(...)</div><div class=""> ``</div><div class=""> </div><div class=""> #### Custom ``Field`` types (experimental)</div><div class=""> </div><div class=""> ``SQLCustomType``:inxx</div><div class=""> </div><div class=""> Aside for using ``filter_in`` and ``filter_out``, it is possible to define new/custom field types.</div><div class="insert">For example we consider here<span class="highlight"></span> a field that contains binary data in compressed form:</div><div class=""> </div><div class=""> ``</div><div class=""> from gluon.dal import SQLCustomType</div><div class=""> import zlib</div><div class=""> </div><div class=""> compressed = SQLCustomType(</div><div class="">      type =&#x27;text&#x27;,</div><div class="">      native=&#x27;text&#x27;,</div><div class="">      encoder =(lambda x: zlib.compress(x or &#x27;&#x27;)),</div><div class="">      decoder = (lambda x: zlib.decompress(x))</div><div class=""> )</div><div class=""> </div><div class=""> db.define_table(&#x27;example&#x27;, Field(&#x27;data&#x27;,type=compressed))</div><div class=""> ``:code</div><div class=""> </div><div class=""> ``SQLCustomType`` is a field type factory. Its ``type`` argument must be one of the standard web2py types. It tells web2py how to treat the field values at the web2py level. ``native`` is the name of the field as far as the database is concerned. Allowed names depend on the database engine. ``encoder`` is an optional transformation function applied when the data is stored and ``decoder`` is the optional reversed transformation function.</div><div class=""> </div><div class=""> This feature is marked as experimental. In practice it has been in web2py for a long time and it works but it can make the code not portable, for example when the native type is database specific. It does not work on Google App Engine NoSQL.</div><div class=""> </div><div class=""> #### Using DAL without define tables</div><div class=""> SQLiteAdapter extends BaseAdapter</div><div class=""> JDBCSQLiteAdapter extends SQLiteAdapter</div><div class=""> MySQLAdapter extends BaseAdapter</div><div class=""> PostgreSQLAdapter extends BaseAdapter</div><div class=""> JDBCPostgreSQLAdapter extends PostgreSQLAdapter</div><div class=""> OracleAdapter extends BaseAdapter</div><div class=""> MSSQLAdapter extends BaseAdapter</div><div class=""> MSSQL2Adapter extends MSSQLAdapter</div><div class=""> FireBirdAdapter extends BaseAdapter</div><div class=""> FireBirdEmbeddedAdapter extends FireBirdAdapter</div><div class=""> InformixAdapter extends BaseAdapter</div><div class=""> DB2Adapter extends BaseAdapter</div><div class=""> IngresAdapter extends BaseAdapter</div><div class=""> IngresUnicodeAdapter extends IngresAdapter</div><div class=""> GoogleSQLAdapter extends MySQLAdapter</div><div class=""> NoSQLAdapter extends BaseAdapter</div><div class=""> GoogleDatastoreAdapter extends NoSQLAdapter</div><div class=""> CubridAdapter extends MySQLAdapter (experimental)</div><div class=""> TeradataAdapter extends DB2Adapter (experimental)</div><div class=""> SAPDBAdapter extends BaseAdapter (experimental)</div><div class=""> CouchDBAdapter extends NoSQLAdapter (experimental)</div><div class="insert">+IMAPAdapter extends NoSQLAdapter (experimental)</div><div class=""> MongoDBAdapter extends NoSQLAdapter (experimental)</div><div class=""> ``</div><div class=""> </div><div class=""> which override the behavior of the ``BaseAdapter``.</div><div class=""> </div><div class=""> Each adapter has more or less this structure:</div><div class=""> </div><div class=""> ``</div><div class=""> class MySQLAdapter(BaseAdapter):</div><div class=""> </div><div class="">     # specify a diver to use</div><div class="">     driver = globals().get(&#x27;pymysql&#x27;,None)</div><div class=""> </div><div class="">     # map web2py types into database types</div><div class="">     types = {</div><div class="">         &#x27;boolean&#x27;: &#x27;CHAR(1)&#x27;,</div><div class="">         &#x27;string&#x27;: &#x27;VARCHAR(%(length)s)&#x27;,</div><div class="">         &#x27;text&#x27;: &#x27;LONGTEXT&#x27;,</div><div class="">         ...</div><div class="">         }</div><div class=""> ADAPTERS = {</div><div class="">     &#x27;oracle&#x27;: OracleAdapter,</div><div class="">     &#x27;mssql&#x27;: MSSQLAdapter,</div><div class="">     &#x27;mssql2&#x27;: MSSQL2Adapter,</div><div class="">     &#x27;db2&#x27;: DB2Adapter,</div><div class="">     &#x27;teradata&#x27;: TeradataAdapter,</div><div class="">     &#x27;informix&#x27;: InformixAdapter,</div><div class="">     &#x27;firebird&#x27;: FireBirdAdapter,</div><div class="">     &#x27;firebird_embedded&#x27;: FireBirdAdapter,</div><div class="">     &#x27;ingres&#x27;: IngresAdapter,</div><div class="">     &#x27;ingresu&#x27;: IngresUnicodeAdapter,</div><div class="">     &#x27;sapdb&#x27;: SAPDBAdapter,</div><div class="">     &#x27;cubrid&#x27;: CubridAdapter,</div><div class="">     &#x27;jdbc:sqlite&#x27;: JDBCSQLiteAdapter,</div><div class="">     &#x27;jdbc:sqlite:memory&#x27;: JDBCSQLiteAdapter,</div><div class="">     &#x27;jdbc:postgres&#x27;: JDBCPostgreSQLAdapter,</div><div class="">     &#x27;gae&#x27;: GoogleDatastoreAdapter, # discouraged, for backward compatibility</div><div class="">     &#x27;google:datastore&#x27;: GoogleDatastoreAdapter,</div><div class="">     &#x27;google:sql&#x27;: GoogleSQLAdapter,</div><div class="">     &#x27;couchdb&#x27;: CouchDBAdapter,</div><div class="">     &#x27;mongodb&#x27;: MongoDBAdapter,</div><div class="insert">+    &#x27;imap&#x27;: IMAPAdapter</div><div class=""> }</div><div class=""> ``:code</div><div class=""> </div><div class=""> the uri string is then parsed in more detail by the adapter itself.</div><div class=""> </div><div class=""> For any adapter you can replace the driver with a different one:</div><div class=""> </div><div class=""> ``</div><div class=""> import MySQLdb as mysqldb</div><div class=""> from gluon.dal import MySQLAdapter</div><div class=""> MySQLAdapter.driver = mysqldb</div><div class=""> ``</div><div class=""> i.e. ``mysqldb`` has to be &#x27;&#x27;that module&#x27;&#x27; with a .connect() method.</div><div class=""> You can specify optional driver arguments and adapter arguments:</div><div class=""> </div><div class=""> ``</div><div class=""> db =DAL(..., driver_args={}, adapter_args={})</div><div class=""> ``</div><div class=""> </div><div class=""> </div><div class=""> #### Gotchas</div><div class=""> </div><div class="insert">**SQLite** does not support dropping and altering columns. That means that web2py migrations will work up to a point. If you delete a field from a table, the column will remain in the database but <span class="highlight">will </span>be invisible to web2py. If you decide to reinstate the column, web2py will try re-create it and fail. In this case you must set ``fake_migrate=True`` so that metadata is rebuilt without attempting to add the column again. Also, for the same reason, **SQLite** is not aware of any change of column type. If you insert a number in a string field, it will be stored as string. If you later change the model and replace the type &quot;string&quot; with type &quot;integer&quot;, SQLite will continue to keep the number as a string and this may cause problem when you try to extract the data.</div><div class=""> </div><div class=""> **MySQL** does not support multiple ALTER TABLE within a single transaction. This means that any migration process is broken into multiple commits. If something happens that causes a failure it is possible to break a migration (the web2py metadata are no longer in sync with the actual table structure in the database). This is unfortunate but it can be prevented (migrate one table at the time) or it can be fixed a posteriori (revert the web2py model to what corresponds to the table structure in database, set ``fake_migrate=True`` and after the metadata has been rebuilt, set ``fake_migrate=False`` and migrate the table again).</div><div class=""> </div><div class="insert">**Google SQL** has the same problems as MySQL and more. In particular table metadata itself must be stored in the database in a table that is not migrated by web2py. This is because Google App Engine has a read-only file system. Web2py migrations in Google:SQL combined with the MySQL issue described above can result in metadata corruption. Again, this can be prevented (<span class="highlight">b</span>y migrating the table at once and then setting migrate=False so that the metadata table is not accessed any more) or it can fixed a posteriori (<span class="highlight">b</span>y accessing the database using the Google dashboard and deleting any corrupted entry from the table called ``web2py_filesystem``.</div><div class=""> </div><div class=""> ``limitby``:inxx</div><div class=""> **MSSQL** does not support the SQL OFFSET keyword. Therefore the database cannot do pagination. When doing a ``limitby=(a,b)`` web2py will fetch the first ``b`` rows and discard the first ``a``. This may result in a considerable overhead when compared with other database engines.</div><div class=""> </div><div class=""> **Oracle** also does not support pagination. It does not support neither the OFFSET nor the LIMIT keywords. Web2py achieves pagination by translating a ``db(...).select(limitby=(a,b))`` into a complex three-way nested select (as suggested by official Oracle documentation). This works for simple select but may break for complex selects involving aliased fields and or joins.</div><div class=""> </div><div class="insert">**MSSQL** has problems with circular references in tables that have ONDELETE CASCADE. This is an M<span class="highlight"></span>SSQL bug and you work around it by setting the ondelete attribute for all reference fields to &quot;NO ACTION&quot;. You can also do it once and for all before you define tables:</div></div></div>
    <div class="span6"><div class="diff"><div class=""> -------------</div><div class=""> **SQLite**     | ``sqlite://storage.db``</div><div class=""> **MySQL**      | ``mysql://username:password@localhost/test``</div><div class=""> **PostgreSQL** | ``postgres://username:password@localhost/test``</div><div class=""> **MSSQL**      | ``mssql://username:password@localhost/test``</div><div class=""> **FireBird**   | ``firebird://username:password@localhost/test``</div><div class=""> **Oracle**     | ``oracle://username/password@test``</div><div class=""> **DB2**        | ``db2://username:password@test``</div><div class=""> **Ingres**     | ``ingres://username:password@localhost/test``</div><div class=""> **Sybase**     | ``sybase://username:password@localhost/test``</div><div class=""> **Informix**   | ``informix://username:password@test``</div><div class="delete">**Teradata**   | ``teradata://DSN=dsn;UID=user;PWD=pass;DATABASE=<span class="highlight">nam</span>e<span class="highlight"></span>``</div><div class=""> **Cubrid**     | ``cubrid://username:password@localhost/test``</div><div class=""> **SAPDB**      | ``sapdb://username:password@localhost/test``</div><div class=""> **IMAP**       | ``imap://user:password@server:port``</div><div class=""> **MongoDB**    | ``mongodb://username:password@localhost/test``</div><div class=""> **Google/SQL** | ``google:sql``</div><div class=""> **Google/NoSQL** | ``google:datastore``</div><div class=""> -------------</div><div class=""> </div><div class=""> Notice that in SQLite the database consists of a single file. If it does not exist, it is created. This file is locked every time it is accessed. In the case of MySQL, PostgreSQL, MSSQL, FireBird, Oracle, DB2, Ingres and Informix the database &quot;test&quot; must be created outside web2py. Once the connection is established, web2py will create, alter, and drop tables appropriately.</div><div class=""> </div><div class=""> It is also possible to set the connection string to ``None``. In this case DAL will not connect to any back-end database, but the API can still be accessed for testing. Examples of this will be discussed in Chapter 7.</div><div class=""> </div><div class=""> Some times you may need to generate SQL as if you had a connection but without actually connecting to the database. This can be done with</div><div class=""> </div><div class=""> ``</div><div class=""> db = DAL(&#x27;...&#x27;, do_connect=False)</div><div class=""> ``:code</div><div class=""> </div><div class=""> In this case you will be able to call ``_select``, ``_insert``, ``_update``, and ``_delete`` to generate SQL but not call ``select``, ``insert``, ``update``, and ``delete``. In most of the cases you can use ``do_connect=False`` even without having the required database drivers.</div><div class=""> </div><div class=""> Notice that by default web2py uses utf8 character encoding for databases. If you work with existing databases that behave differently, you have to change it with the optional parameter ``db_codec`` like</div><div class=""> </div><div class=""> ``</div><div class=""> db = DAL(&#x27;...&#x27;, db_codec=&#x27;latin1&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class="delete">otherwise you&#x27;ll get UnicodeDecodeError<span class="highlight">s</span> tickets.</div><div class=""> </div><div class=""> #### Connection pooling</div><div class=""> ``connection pooling``:inxx</div><div class=""> </div><div class=""> The second argument of the DAL constructor is the ``pool_size``; it defaults to zero.</div><div class=""> </div><div class=""> As it is rather slow to establish a new database connection for each request, web2py implements a mechanism for connection pooling. Once a connection is established and the page has been served and the transaction completed, the connection is not closed but goes into a pool. When the next http request arrives, web2py tries to recycle a connection from the pool and use that for the new transaction. If there are no available connections in the pool, a new connection is established.</div><div class=""> </div><div class=""> When web2py starts, the pool is always empty. The pool grows up to the minimum between the value of ``pool_size`` and the max number of concurrent requests. This means that if ``pool_size=10`` but our server never receives more than 5 concurrent requests, then the actual pool size will only grow to 5. If ``pool_size=0`` then connection pooling is not used.</div><div class=""> </div><div class=""> Connections in the pools are shared sequentially among threads, in the sense that they may be used by two different but not simultaneous threads. There is only one pool for each web2py process.</div><div class=""> </div><div class=""> The ``pool_size`` parameter is ignored by SQLite and Google App Engine.</div><div class=""> Connection pooling is ignored for SQLite, since it would not yield any benefit.</div><div class=""> </div><div class=""> #### Connection failures</div><div class=""> </div><div class=""> If web2py fails to connect to the database it waits 1 seconds and tries again up to 5 times before declaring a failure. In case of connection pooling it is possible that a pooled connection that stays open but unused for some time is closed by the database end. Thanks to the retry feature web2py tries to re-establish these dropped connections.</div><div class=""> </div><div class=""> #### Replicated databases</div><div class=""> </div><div class=""> The first argument of ``DAL(...)`` can be a list of URIs. In this case web2py tries to connect to each of them. The main purpose for this is to deal with multiple database servers and distribute the workload among them). Here is a typical use case:</div><div class=""> </div><div class=""> ``</div><div class=""> db = DAL([&#x27;mysql://...1&#x27;,&#x27;mysql://...2&#x27;,&#x27;mysql://...3&#x27;])</div><div class=""> ``:code</div><div class=""> </div><div class=""> In this case the DAL tries to connect to the first and, on failure, it</div><div class=""> will try the second and the third. This can also be used to distribute load</div><div class=""> in a database master-slave configuration. We will talk more about this</div><div class=""> in Chapter 13 in the context of scalability.</div><div class=""> </div><div class=""> ### Reserved keywords</div><div class=""> ``reserved Keywords``:inxx</div><div class=""> </div><div class="delete">-``check_reserved`` is yet another argument that can be passed to the DAL constructor. It tells it to check table names and column names against reserved SQL keywords in target back-end databases.</div><div class="delete">-</div><div class="delete"><span class="highlight">This</span> argument <span class="highlight">is</span> ``check_reserved`` <span class="highlight">and it </span>defaults to None.</div><div class=""> </div><div class=""> This is a list of strings that contain the database back-end adapter names.</div><div class=""> </div><div class=""> The adapter name is the same as used in the DAL connection string. So if you want to check against PostgreSQL and MSSQL then your connection string would look as follows:</div><div class=""> ``</div><div class=""> db = DAL(&#x27;sqlite://storage.db&#x27;,</div><div class="">          check_reserved=[&#x27;postgres&#x27;, &#x27;mssql&#x27;])</div><div class=""> ``:code</div><div class=""> </div><div class=""> The DAL will scan the keywords in the same order as of the list.</div><div class=""> </div><div class=""> There are two extra options &quot;all&quot; and &quot;common&quot;. If you specify all, it will check against all known SQL keywords. If you specify common, it will only check against common SQL keywords such as ``SELECT``, ``INSERT``, ``UPDATE``, etc.</div><div class=""> </div><div class=""> For supported back-ends you may also specify if you would like to check against the non-reserved SQL keywords as well. In this case you would append ``_nonreserved`` to the name. For example:</div><div class=""> ``</div><div class=""> check_reserved=[&#x27;postgres&#x27;, &#x27;postgres_nonreserved&#x27;]</div><div class=""> ``:code</div><div class=""> </div><div class=""> The following database backends support reserved words checking.</div><div class=""> </div><div class=""> The most important method of a DAL is ``define_table``:</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class=""> It defines, stores and returns a ``Table`` object called &quot;person&quot; containing a field (column) &quot;name&quot;. This object can also be accessed via ``db.person``, so you do not need to catch the return value.</div><div class=""> </div><div class=""> Do not declare a field called &quot;id&quot;, because one is created by web2py anyway. Every table has a field called &quot;id&quot; by default. It is an auto-increment integer field (starting at 1) used for cross-reference and for making every record unique, so &quot;id&quot; is a primary key. (Note: the id&#x27;s starting at 1 is back-end specific. For example, this does not apply to the Google App Engine NoSQL.)</div><div class=""> </div><div class=""> ``named id field``:inxx</div><div class=""> Optionally you can define a field of ``type=&#x27;id&#x27;`` and web2py will use this field as auto-increment id field. This is not recommended except when accessing legacy database tables. With some limitation, you can also use different primary keys and this is discussed in the section on &quot;Legacy databases and keyed tables&quot;.</div><div class=""> </div><div class=""> Tables can be defined only once but you can force web2py to redefine an existing table:</div><div class=""> </div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;))</div><div class=""> db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;), redefine=True)</div><div class=""> ``:code</div><div class=""> </div><div class=""> The redefinition may trigger a migration if field content is different.</div><div class=""> </div><div class=""> ----------</div><div class="delete">Because usually in web2py models are executed before controllers, it is possible that some table are defined even if not needed. It is therefore necessary to speed up the code by making table definitions lazy. This is done by setting the ``DAL(...,lazy_tables=True)`` attribute<span class="highlight">s</span>. Tables will be actually created only when accessed.</div><div class=""> ----------</div><div class=""> </div><div class=""> </div><div class=""> ### Record representation</div><div class=""> </div><div class=""> It is optional but recommended to specify a format representation for records:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;), format=&#x27;%(name)s&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> or</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;), format=&#x27;%(name)s %(id)s&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> or even more complex ones using a function:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;),</div><div class="">        format=lambda r: r.name or &#x27;anonymous&#x27;)</div><div class=""> ``:code</div><div class=""> All queries are automatically timed by web2py. The variable ``db._timings`` is a</div><div class=""> {{=response.toolbar()}}</div><div class=""> ``</div><div class=""> </div><div class=""> #### ``executesql``</div><div class=""> </div><div class=""> The DAL allows you to explicitly issue SQL statements.</div><div class=""> </div><div class=""> ``executesql``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; print db.executesql(&#x27;SELECT * FROM person;&#x27;)</div><div class=""> [(1, u&#x27;Massimo&#x27;), (2, u&#x27;Massimo&#x27;)]</div><div class=""> ``:code</div><div class=""> </div><div class=""> In this case, the return values are not parsed or transformed by the DAL, and the format depends on the specific database driver. This usage with selects is normally not needed, but it is more common with indexes.</div><div class=""> ``executesql`` takes four optional arguments: ``placeholders``, ``as_dict``, ``fields`` and ``colnames``.</div><div class=""> ``placeholders`` is an optional</div><div class=""> sequence of values to be substituted in</div><div class=""> or, if supported by the DB driver, a dictionary with keys</div><div class=""> matching named placeholders in your SQL.</div><div class=""> </div><div class="delete">-If ``as_dict`` is set to True,</div><div class="delete">-and the results cursor returned by the DB driver will be</div><div class="delete">-converted to a sequence of dictionaries keyed with the db</div><div class="delete">-field names.  Results returned with ``as_dict = True ``are</div><div class="delete"><span class="highlight"></span>the same as those returned when applying **.as_list()** to a normal select.</div><div class=""> ``</div><div class=""> [{field1: value1, field2: value2}, {field1: value1b, field2: value2b}]</div><div class=""> ``:code</div><div class=""> </div><div class=""> The ``fields`` argument is a list of DAL Field objects that match the</div><div class=""> fields returned from the DB. The Field objects should be part of one or</div><div class=""> more Table objects defined on the DAL object. The ``fields`` list can</div><div class=""> include one or more DAL Table objects in addition to or instead of</div><div class=""> including Field objects, or it can be just a single table (not in a</div><div class=""> list). In that case, the Field objects will be extracted from the</div><div class=""> table(s).</div><div class=""> </div><div class=""> Instead of specifying the ``fields`` argument, the ``colnames`` argument</div><div class=""> can be specified as a list of field names in tablename.fieldname format.</div><div class=""> Again, these should represent tables and fields defined on the DAL</div><div class=""> object.</div><div class=""> </div><div class=""> It is also possible to specify both ``fields`` and the associated</div><div class=""> ``colnames``. In that case, ``fields`` can also include DAL Expression</div><div class=""> objects in addition to Field objects. For Field objects in &quot;fields&quot;,</div><div class=""> Here is an example:</div><div class=""> ``SQLFORM.grid``:inxx ``SQLFORM.smartgrid``:inxx</div><div class=""> </div><div class=""> ------</div><div class=""> ``SQLTABLE`` is useful but there are times when one needs more. ``SQLFORM.grid`` is an extension of SQLTABLE that creates a table with search features and pagination, as well as ability to open detailed records, create, edit and delete records. ``SQLFORM.smartgrid`` is a further generalization that allows all of the above but also creates buttons to access referencing records.</div><div class=""> ------</div><div class=""> </div><div class=""> Here is an example of usage of ``SQLFORM.grid``:</div><div class=""> </div><div class=""> ``</div><div class=""> def index():</div><div class="">     return dict(grid=SQLFORM.grid(query))</div><div class=""> ``:code</div><div class=""> </div><div class=""> and the corresponding view:</div><div class=""> </div><div class=""> ``</div><div class=""> {{extend &#x27;layout.html&#x27;}}</div><div class=""> {{=grid}}</div><div class=""> ``</div><div class=""> </div><div class="delete">``SQLFORM.grid`` and ``SQLFORM.smartgrid`` should be preferred to ``SQLTABLE`` because they are more powerful although higher level and therefore more constraining. They will be explained in more detail in chapter <span class="highlight">8.</span></div><div class=""> </div><div class=""> #### ``orderby``, ``groupby``, ``limitby``, ``distinct``, ``having``</div><div class=""> </div><div class=""> The ``select`` command takes five optional arguments: orderby, groupby, limitby, left and cache. Here we discuss the first three.</div><div class=""> </div><div class=""> You can fetch the records sorted by name:</div><div class=""> </div><div class=""> ``orderby``:inxx ``groupby``:inxx ``having``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db().select(</div><div class="">         db.person.ALL, orderby=db.person.name):</div><div class="">         print row.name</div><div class=""> Alex</div><div class=""> Bob</div><div class=""> Carl</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can fetch the records sorted by name in reverse order (notice the tilde):</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db().select(</div><div class=""> name</div><div class=""> Max</div><div class=""> Tim</div><div class=""> John</div><div class=""> Tim</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can do a union of the records removing duplicates:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows3 = rows1 | rows2</div><div class=""> &gt;&gt;&gt; print rows3</div><div class=""> name</div><div class=""> Max</div><div class=""> Tim</div><div class=""> John</div><div class=""> ``:code</div><div class=""> </div><div class=""> #### ``find``, ``exclude``, ``sort``</div><div class=""> ``find``:inxx ``exclude``:inxx ``sort``:inxx</div><div class=""> </div><div class="delete">Some times you<span class="highlight"></span> to perform two selects and one contains a subset of a previous select. In this case it is pointless to access the database again. The ``find``, ``exclude`` and ``sort`` objects allow you to manipulate a Rows objects and generate another one without accessing the database. More specifically:</div><div class=""> - ``find`` returns a new set of Rows filtered by a condition and leaves the original unchanged.</div><div class=""> - ``exclude`` returns a new set of Rows filtered by a condition and removes them from the original Rows.</div><div class=""> - ``sort`` returns a new set of Rows sorted by a condition and leaves the original unchanged.</div><div class=""> </div><div class=""> All these methods take a single argument, a function that acts on each individual row.</div><div class=""> </div><div class=""> Here is an example of usage:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;,Field(&#x27;name&#x27;))</div><div class=""> &gt;&gt;&gt; db.person.insert(name=&#x27;John&#x27;)</div><div class=""> &gt;&gt;&gt; db.person.insert(name=&#x27;Max&#x27;)</div><div class=""> &gt;&gt;&gt; db.person.insert(name=&#x27;Alex&#x27;)</div><div class=""> &gt;&gt;&gt; rows = db(db.person).select()</div><div class=""> &gt;&gt;&gt; for row in rows.find(lambda row: row.name[0]==&#x27;M&#x27;):</div><div class="">         print row.name</div><div class=""> Max</div><div class=""> &gt;&gt;&gt; print len(rows)</div><div class=""> 3</div><div class=""> &gt;&gt;&gt; for row in rows.exclude(lambda row: row.name[0]==&#x27;M&#x27;):</div><div class="">         print row.name</div><div class=""> Max</div><div class=""> &gt;&gt;&gt; for row in rows.sort(lambda row: row.name):</div><div class="">         print row.name</div><div class=""> Alex</div><div class=""> John</div><div class=""> ``:code</div><div class=""> </div><div class=""> They can be combined:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows = db(db.person).select()</div><div class=""> &gt;&gt;&gt; rows = rows.find(</div><div class="">         lambda row: &#x27;x&#x27; in row.name).sort(</div><div class="">             lambda row: row.name)</div><div class=""> &gt;&gt;&gt; for row in rows:</div><div class="">         print row.name</div><div class=""> Alex</div><div class=""> Max</div><div class=""> ``:code</div><div class=""> </div><div class=""> Sort takes an optional argument ``reverse=True`` with the obvious meaning.</div><div class=""> </div><div class="delete">The ``find`` method <span class="highlight"></span>as an optional limitby argument with the same syntax and functionality as the Set select ``method``.</div><div class=""> </div><div class=""> </div><div class=""> </div><div class=""> ### Other methods</div><div class=""> </div><div class=""> #### ``update_or_insert``</div><div class=""> ``update_or_insert``:inxx</div><div class=""> </div><div class=""> Some times you need to perform an insert only if there is no record with the same values as those being inserted.</div><div class=""> This can be done with</div><div class=""> </div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;,Field(&#x27;name&#x27;),Field(&#x27;birthplace&#x27;))</div><div class=""> db.person.update_or_insert(name=&#x27;John&#x27;,birthplace=&#x27;Chicago&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class="delete">The record will be inserted only <span class="highlight">o</span>f there is no other user called John born in Chicago.</div><div class=""> </div><div class=""> You can specify which values to use as a key to determine if the record exists. For example:</div><div class=""> ``</div><div class=""> db.person.update_or_insert(db.person.name==&#x27;John&#x27;,</div><div class="">      name=&#x27;John&#x27;,birthplace=&#x27;Chicago&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> and if there is John his birthplace will be updated else a new record will be created.</div><div class=""> </div><div class=""> #### ``validate_and_insert``, ``validate_and_update``</div><div class=""> </div><div class=""> ``validate_and_insert``:inxx ``validate_and_update``:inxx</div><div class=""> </div><div class=""> The function</div><div class=""> </div><div class=""> ``</div><div class=""> ret = db.mytable.validate_and_insert(field=&#x27;value&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> works very much like</div><div class=""> </div><div class=""> ``</div><div class=""> id = db.mytable.insert(field=&#x27;value&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> except that it calls the validators for the fields before performing the insert and bails out if the validation does not pass. If validation does not pass the errors can be found in ``ret.error``. If it passes, the id of the new record is in ``ret.id``. Mind that normally validation is done by the form processing logic so this function is rarely needed.</div><div class=""> </div><div class=""> Similarly</div><div class=""> </div><div class=""> ``</div><div class=""> ret = db(query).validate_and_update(field=&#x27;value&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> works very much the same as</div><div class=""> </div><div class=""> ``</div><div class=""> num = db(query).update(field=&#x27;value&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class="delete">except that it calls the validators for <span class="highlight">       </span>the fields before performing the update. Notice that it only works if query involves a single table. The number of updated records can be found in ``res.updated`` and errors will be ``ret.errors``.</div><div class=""> </div><div class=""> #### ``smart_query`` (experimental)</div><div class=""> </div><div class=""> There are times when you need to parse a query using natural language such as</div><div class=""> </div><div class=""> ``</div><div class=""> name contain m and age greater than 18</div><div class=""> ``</div><div class=""> </div><div class=""> The DAL provides a method to parse this type of queries:</div><div class=""> </div><div class=""> ``</div><div class=""> search = &#x27;name contain m and age greater than 18&#x27;</div><div class=""> rows = db.smart_query([db.person],search).select()</div><div class=""> ``</div><div class=""> </div><div class=""> The first argument must be a list of tables or fields that should be allowed in the search. It raises a ``RuntimeError`` if the search string is invalid. This functionality can be used to build RESTful interfaces (see chapter 10) and it is used internally by the ``SQLFORM.grid`` and ``SQLFORM.smartgrid``.</div><div class=""> </div><div class=""> In the smartquery search string, a field can be identified by fieldname only and or by tablename.fieldname. Strings may be delimited by double quotes if they contain spaces.</div><div class=""> </div><div class=""> left = db.thing.on(...)</div><div class=""> ``:code</div><div class=""> </div><div class=""> does the left join query. Here the argument of ``db.thing.on`` is the condition required for the join (the same used above for the inner join). In the case of a left join, it is necessary to be explicit about which fields to select.</div><div class=""> </div><div class=""> Multiple left joins can be combined by passing a list or tuple of ``db.mytable.on(...)`` to the  ``left`` attribute.</div><div class=""> </div><div class=""> #### Grouping and counting</div><div class=""> </div><div class=""> When doing joins, sometimes you want to group rows according to certain criteria and count them. For example, count the number of things owned by every person. web2py allows this as well. First, you need a count operator. Second, you want to join the person table with the thing table by owner. Third, you want to select all rows (person + thing), group them by person, and count them while grouping:</div><div class=""> </div><div class=""> ``grouping``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; count = db.person.id.count()</div><div class=""> &gt;&gt;&gt; for row in db(db.person.id==db.thing.owner_id).select(</div><div class="">         db.person.name, count, groupby=db.person.name):</div><div class="">         print row.person.name, row[count]</div><div class=""> Alex 2</div><div class=""> Bob 1</div><div class=""> ``:code</div><div class=""> </div><div class="delete">Notice the <span class="highlight">count</span> operator (which is built-in) is used as a field. The only issue here is in how to retrieve the information. Each row clearly contains a person and the count, but the count is not a field of a person nor is it a table. So where does it go? It goes into the storage object representing the record with a key equal to the query expression itself. The count method of the Field object has an optional ``distinct`` argument. When set to ``True`` it specifies that only distinct values of the field in question are to be counted.</div><div class=""> </div><div class=""> ### Many to many</div><div class=""> ``many-to-many``:inxx</div><div class=""> In the previous examples, we allowed a thing to have one owner but one person could have many things. What if Boat was owned by Alex and Curt? This requires a many-to-many relation, and it is realized via an intermediate table that links a person to a thing via an ownership relation.</div><div class=""> </div><div class=""> Here is how to do it:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;,</div><div class="">                     Field(&#x27;name&#x27;))</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;thing&#x27;,</div><div class="">                     Field(&#x27;name&#x27;))</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;ownership&#x27;,</div><div class="">                     Field(&#x27;person&#x27;, &#x27;reference person&#x27;),</div><div class="">                     Field(&#x27;thing&#x27;, &#x27;reference thing&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class=""> the existing ownership relationship can now be rewritten as:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.ownership.insert(person=1, thing=1) # Alex owns Boat</div><div class=""> &gt;&gt;&gt; db.ownership.insert(person=1, thing=2) # Alex owns Chair</div><div class=""> or any value from the list</div><div class=""> db.mytable.myfield.contains([&#x27;value1&#x27;,&#x27;value2&#x27;], all=false)</div><div class=""> ``</div><div class=""> </div><div class=""> There is a also a ``regexp`` method that works like the ``like`` method but allows regular expression syntax for the look-up expression. It is only supported by PostgreSQL and SQLite.</div><div class=""> </div><div class=""> The ``upper`` and ``lower`` methods allow you to convert the value of the field to upper or lower case, and you can also combine them with the like operator:</div><div class=""> </div><div class=""> ``upper``:inxx ``lower``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db(db.log.event.upper().like(&#x27;PORT%&#x27;)).select():</div><div class="">         print row.event</div><div class=""> port scan</div><div class=""> ``:code</div><div class=""> </div><div class=""> #### ``year``, ``month``, ``day``, ``hour``, ``minutes``, ``seconds``</div><div class=""> ``hour``:inxx ``minutes``:inxx ``seconds``:inxx ``day``:inxx ``month``:inxx ``year``:inxx</div><div class=""> </div><div class=""> The date and datetime fields have day, month and year methods. The datetime and time fields have hour, minutes and seconds methods. Here is an example:</div><div class=""> </div><div class=""> ``</div><div class="delete">&gt;&gt;&gt; for row in db(db.log.event_time.year()==20<span class="highlight">09</span>).select():</div><div class="">         print row.event</div><div class=""> port scan</div><div class=""> xss injection</div><div class=""> unauthorized login</div><div class=""> ``:code</div><div class=""> </div><div class=""> #### ``belongs``</div><div class=""> </div><div class="delete">The SQL IN operator is realized via the belongs method which returns true when the field value belongs to the specified set (list o<span class="highlight">f</span> tuples):</div><div class=""> </div><div class=""> ``belongs``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db(db.log.severity.belongs((1, 2))).select():</div><div class="">         print row.event</div><div class=""> port scan</div><div class=""> xss injection</div><div class=""> ``:code</div><div class=""> </div><div class=""> The DAL also allows a nested select as the argument of the belongs operator. The only caveat is that the nested select has to be a ``_select``, not a ``select``, and only one field has to be selected explicitly, the one that defines the set.</div><div class=""> </div><div class=""> ``nested select``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; bad_days = db(db.log.severity==3)._select(db.log.event_time)</div><div class=""> &gt;&gt;&gt; for row in db(db.log.event_time.belongs(bad_days)).select():</div><div class="">         print row.event</div><div class=""> port scan</div><div class=""> xss injection</div><div class=""> unauthorized login</div><div class=""> ``:code</div><div class=""> </div><div class=""> In those cases where a nested select is required and the look-up field is a reference we can also use a query as argument. For example:</div><div class=""> </div><div class=""> ``</div><div class="delete">-db.define_table(&#x27;person&#x27;,Field(&#x27;name&#x27;))</div><div class="delete">-db.define_table(&#x27;thing,Field(&#x27;name&#x27;), Field(&#x27;owner_id&#x27;,&#x27;reference thing&#x27;))</div><div class=""> db(db.thing.owner_id.belongs(db.person.name==&#x27;Jonathan&#x27;)).select()</div><div class=""> ``:code</div><div class=""> </div><div class=""> In this case it is obvious that the next select only needs the field referenced by the ``db.thing.owner_id`` field so we do not need the more verbose ``_select`` notation.</div><div class=""> </div><div class=""> ``nested_select``:inxx</div><div class=""> </div><div class=""> A nested select can also be used as insert/update value but in this case the syntax is different:</div><div class=""> </div><div class=""> ``</div><div class=""> lazy = db(db.person.name==&#x27;Jonathan&#x27;).nested_select(db.person.id)</div><div class=""> db(db.thing.id==1).update(owner_id = lazy)</div><div class=""> ``:code</div><div class=""> </div><div class=""> In this case ``lazy`` is a nested expression that computes the ``id`` of person &quot;Jonathan&quot;. The two lines result in one single SQL query.</div><div class=""> </div><div class=""> #### ``sum``, ``avg``, ``min``, ``max`` and ``len``</div><div class=""> </div><div class=""> ``sum``:inxx ``avg``:inxx ``min``:inxx ``max``:inxx</div><div class=""> Previously, you have used the count operator to count records. Similarly, you can use the sum operator to add (sum) the values of a specific field from a group of records. As in the case of count, the result of a sum is retrieved via the store object:</div><div class=""> if not db(db.person).count():</div><div class=""> ``:code</div><div class=""> </div><div class=""> Each record is identified by an ID and referenced by that ID. If you</div><div class=""> have two copies of the database used by distinct web2py installations,</div><div class=""> the ID is unique only within each database and not across the databases.</div><div class=""> This is a problem when merging records from different databases.</div><div class=""> </div><div class=""> In order to make a record uniquely identifiable across databases, they</div><div class=""> must:</div><div class=""> - have a unique id (UUID),</div><div class=""> - have an event_time (to figure out which one is more recent if multiple copies),</div><div class=""> - reference the UUID instead of the id.</div><div class=""> </div><div class=""> This can be achieved without modifying web2py. Here is what to do:</div><div class=""> </div><div class=""> Change the above model into:</div><div class=""> </div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;,</div><div class="">     Field(&#x27;uuid&#x27;, length=64, default=lambda:str(uuid.uuid4())),</div><div class="delete">    Field(&#x27;modified_on&#x27;, &#x27;datetime&#x27;, default=<span class="highlight"></span>now),</div><div class="">     Field(&#x27;name&#x27;),</div><div class="">     format=&#x27;%(name)s&#x27;)</div><div class=""> </div><div class=""> db.define_table(&#x27;thing&#x27;,</div><div class="">     Field(&#x27;uuid&#x27;, length=64, default=lambda:str(uuid.uuid4())),</div><div class="delete">    Field(&#x27;modified_on&#x27;, &#x27;datetime&#x27;, default=<span class="highlight"></span>now),</div><div class="">     Field(&#x27;owner_id&#x27;, length=64),</div><div class="">     Field(&#x27;name&#x27;),</div><div class="">     format=&#x27;%(name)s&#x27;)</div><div class=""> </div><div class=""> db.thing.owner_id.requires = IS_IN_DB(db,&#x27;person.uuid&#x27;,&#x27;%(name)s&#x27;)</div><div class=""> </div><div class=""> if not db(db.person.id).count():</div><div class="">     id = uuid.uuid4()</div><div class="">     db.person.insert(name=&quot;Massimo&quot;, uuid=id)</div><div class="">     db.thing.insert(owner_id=id, name=&quot;Chair&quot;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> -------</div><div class=""> Notice that in the above table definitions, the default value for the two ``uuid`` fields is set to a lambda function, which returns a UUID (converted to a string). The lambda function is called once for each record inserted, ensuring that each record gets a unique UUID, even if multiple records are inserted in a single transaction.</div><div class=""> -------</div><div class=""> </div><div class=""> Create a controller action to export the database:</div><div class=""> </div><div class=""> ``</div><div class=""> def export():</div><div class=""> The ``export_to_csv_file`` function accepts a keyword argument named ``represent</div><div class=""> ``colnames``:inxx</div><div class=""> The function also accepts a keyword argument named ``colnames`` that should contain a list of column names one wish to export. It defaults to all columns.</div><div class=""> </div><div class=""> Both ``export_to_csv_file`` and ``import_from_csv_file`` accept keyword arguments that tell the csv parser the format to save/load the files:</div><div class=""> - ``delimiter``: delimiter to separate values (default &#x27;,&#x27;)</div><div class=""> - ``quotechar``: character to use to quote string values (default to double quotes)</div><div class=""> - ``quoting``: quote system (default ``csv.QUOTE_MINIMAL``)</div><div class=""> </div><div class=""> Here is some example usage:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; import csv</div><div class=""> &gt;&gt;&gt; rows = db(query).select()</div><div class=""> &gt;&gt;&gt; rows.export_to_csv_file(open(&#x27;/tmp/test.txt&#x27;, &#x27;w&#x27;),</div><div class="">         delimiter=&#x27;|&#x27;,</div><div class="">         quotechar=&#x27;&quot;&#x27;,</div><div class="">         quoting=csv.QUOTE_NONNUMERIC)</div><div class=""> ``:code</div><div class=""> </div><div class=""> Which would render something similar to</div><div class=""> ``</div><div class="delete">&quot;hello&quot;|35|&quot;this is the text description&quot;|&quot;20<span class="highlight">09</span>-03-03&quot;</div><div class=""> ``:code</div><div class=""> </div><div class=""> For more information consult the official Python documentation ``quoteall``:cite</div><div class=""> </div><div class=""> ### Caching selects</div><div class=""> </div><div class=""> The select method also takes a cache argument, which defaults to None. For caching purposes, it should be set to a tuple where the first element is the cache model (cache.ram, cache.disk, etc.), and the second element is the expiration time in seconds.</div><div class=""> </div><div class=""> In the following example, you see a controller that caches a select on the previously defined db.log table. The actual select fetches data from the back-end database no more frequently than once every 60 seconds and stores the result in cache.ram. If the next call to this controller occurs in less than 60 seconds since the last database IO, it simply fetches the previous data from cache.ram.</div><div class=""> </div><div class=""> ``cache select``:inxx</div><div class=""> ``</div><div class=""> def cache_db_select():</div><div class="">     logs = db().select(db.log.ALL, cache=(cache.ram, 60))</div><div class="">     return dict(logs=logs)</div><div class=""> ``:code</div><div class=""> </div><div class=""> ``cacheable``:inxx</div><div class=""> </div><div class=""> The ``select`` method has an optional ``cacheable`` argument, normally set to ``False``. When ``cacheable=True`` the resulting ``Rows`` is serializable but The ``Row``s lack ``update_record`` and ``delete_record`` methods.</div><div class=""> This is best explained via some examples.</div><div class=""> ``:code</div><div class=""> </div><div class=""> Here ``f`` is a dict of fields passed to insert or update, ``id`` is the id of the newly inserted record, ``s`` is the Set object used for update or delete.</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.person.insert(name=&#x27;John&#x27;)</div><div class=""> ({&#x27;name&#x27;: &#x27;John&#x27;},)</div><div class=""> ({&#x27;name&#x27;: &#x27;John&#x27;}, 1)</div><div class=""> &gt;&gt;&gt; db(db.person.id==1).update(name=&#x27;Tim&#x27;)</div><div class=""> (&lt;Set (person.id = 1)&gt;, {&#x27;name&#x27;: &#x27;Tim&#x27;})</div><div class=""> (&lt;Set (person.id = 1)&gt;, {&#x27;name&#x27;: &#x27;Tim&#x27;})</div><div class=""> &gt;&gt;&gt; db(db.person.id==1).delete()</div><div class=""> (&lt;Set (person.id = 1)&gt;,)</div><div class=""> (&lt;Set (person.id = 1)&gt;,)</div><div class=""> ``:code</div><div class=""> </div><div class=""> The return values of these callback should be ``None`` or ``False``. If any of the ``_before_*`` callback returns a ``True`` value it will abort the actual insert/update/delete operation.</div><div class=""> </div><div class=""> ``update_naive``:inxx.</div><div class=""> </div><div class="delete">Some times a callback may need to perform an update in the same o<span class="highlight">f</span> a different table and one wants to avoid callbacks calling themselves recursively.</div><div class=""> </div><div class=""> For this purpose there the Set objects have an ``update_naive`` method that works like ``update`` but ignores before and after callbacks.</div><div class=""> </div><div class=""> #### Record versioning</div><div class=""> </div><div class=""> ``_enable_record_versioning``:inxx</div><div class=""> </div><div class=""> It is possible to ask web2py to save every copy of a record when the record is individually modified. There are different ways to do it and it can be done for all tables at once using the syntax:</div><div class=""> </div><div class=""> ``</div><div class=""> auth.enable_record_versioning(db)</div><div class=""> ``:code</div><div class=""> </div><div class=""> this requires Auth and it is discussed in the chapter about authentication.</div><div class=""> It can also be done for each individual table as discussed below.</div><div class=""> </div><div class=""> Consider the following table:</div><div class=""> </div><div class=""> ``</div><div class=""> db.define_table(&#x27;stored_item&#x27;,</div><div class=""> True.</div><div class=""> </div><div class=""> We can tell web2py to create a new table (in the same or a different database) and store all previous versions of each record in the table, when modified.</div><div class=""> </div><div class=""> This is done in the following way:</div><div class=""> ``</div><div class=""> db.stored_item._enable_record_versioning()</div><div class=""> ``:code</div><div class=""> </div><div class=""> or in a more verbose syntax:</div><div class=""> </div><div class=""> ``</div><div class=""> db.stored_item._enable_record_versioning(</div><div class="">     archive_db = db,</div><div class="">     archive_name = &#x27;stored_item_archive&#x27;,</div><div class="">     current_record = &#x27;current_record&#x27;,</div><div class="">     is_active = &#x27;is_active&#x27;)</div><div class=""> ``</div><div class=""> </div><div class=""> The ``archive_db=db`` tells web2py to store the archive table in the same database as the ``stored_item`` table. The ``archive_name`` sets the name for the archive table. The archive table has the same fields as the original table ``stored_item`` except that unique fields are no longer unique (because it needs to store multiple versions) and has an extra field which name is specified by ``current_record`` and which is a reference to the current record in the ``stored_item`` table.</div><div class=""> </div><div class="delete">When records are deleted, they are not really deleted. A deleted record is copied in the ``stored_item_archive`` table (like when it is modified) and the ``is_active`` field is set to False. By enabling record versioning web2py sets a ``custom_filter`` on this table that hides all <span class="highlight">fiel</span>ds in table ``stored_item`` where the ``is_active`` field is set to False. The ``is_active`` parameter in the ``_enable_record_versioning`` method allows to specify the name of the field used by the ``custom_filter`` to determine if the field was deleted or not.</div><div class=""> </div><div class=""> ``custom_filter``s are ignored by the appadmin interface.</div><div class=""> </div><div class=""> #### Common fields and multi-tenancy</div><div class=""> ``common fields``:inxx</div><div class=""> ``multi tenancy``:inxx</div><div class=""> </div><div class=""> ``db._common_fields`` is a list of fields that should belong to all the tables. This list can also contain tables and it is understood as all fields from the table. For example occasionally you find yourself in need to add a signature to all your tables but the ```auth`` tables. In this case, after you ``db.define_tables()`` but before defining any other table, insert</div><div class=""> </div><div class=""> ``</div><div class=""> db._common_fields.append(auth.signature)</div><div class=""> ``</div><div class=""> </div><div class=""> One field is special: &quot;request_tenant&quot;.</div><div class=""> This field does not exist but you can create it and add it to any of your tables (or them all):</div><div class=""> </div><div class=""> ``</div><div class=""> db._common_fields.append(Field(&#x27;request_tenant&#x27;,</div><div class="">     default=request.env.http_host,writable=False))</div><div class=""> ``</div><div class=""> Any select, delete or update in this table, will include only public blog posts.</div><div class=""> ``</div><div class=""> db.blog_post._common_filter = lambda query: db.blog_post.is_public == True</div><div class=""> ``</div><div class=""> </div><div class=""> It serves both as a way to avoid repeating the &quot;db.blog_post.is_public==True&quot; phrase in each blog post search, and also as a security enhancement, that prevents you from forgetting to disallow viewing of none public posts.</div><div class=""> </div><div class=""> In case you actually do want items left out by the common filter (for example, allowing the admin to see none public posts), you can either remove the filter:</div><div class=""> ``</div><div class=""> db.blog_post._common_filter = None</div><div class=""> ``</div><div class=""> or ignore it:</div><div class=""> ``</div><div class=""> db(query, ignore_common_filters=True).select(...)</div><div class=""> ``</div><div class=""> </div><div class=""> #### Custom ``Field`` types (experimental)</div><div class=""> </div><div class=""> ``SQLCustomType``:inxx</div><div class=""> </div><div class=""> Aside for using ``filter_in`` and ``filter_out``, it is possible to define new/custom field types.</div><div class="delete">For example we consider here<span class="highlight"> the example if</span> a field that contains binary data in compressed form:</div><div class=""> </div><div class=""> ``</div><div class=""> from gluon.dal import SQLCustomType</div><div class=""> import zlib</div><div class=""> </div><div class=""> compressed = SQLCustomType(</div><div class="">      type =&#x27;text&#x27;,</div><div class="">      native=&#x27;text&#x27;,</div><div class="">      encoder =(lambda x: zlib.compress(x or &#x27;&#x27;)),</div><div class="">      decoder = (lambda x: zlib.decompress(x))</div><div class=""> )</div><div class=""> </div><div class=""> db.define_table(&#x27;example&#x27;, Field(&#x27;data&#x27;,type=compressed))</div><div class=""> ``:code</div><div class=""> </div><div class=""> ``SQLCustomType`` is a field type factory. Its ``type`` argument must be one of the standard web2py types. It tells web2py how to treat the field values at the web2py level. ``native`` is the name of the field as far as the database is concerned. Allowed names depend on the database engine. ``encoder`` is an optional transformation function applied when the data is stored and ``decoder`` is the optional reversed transformation function.</div><div class=""> </div><div class=""> This feature is marked as experimental. In practice it has been in web2py for a long time and it works but it can make the code not portable, for example when the native type is database specific. It does not work on Google App Engine NoSQL.</div><div class=""> </div><div class=""> #### Using DAL without define tables</div><div class=""> SQLiteAdapter extends BaseAdapter</div><div class=""> JDBCSQLiteAdapter extends SQLiteAdapter</div><div class=""> MySQLAdapter extends BaseAdapter</div><div class=""> PostgreSQLAdapter extends BaseAdapter</div><div class=""> JDBCPostgreSQLAdapter extends PostgreSQLAdapter</div><div class=""> OracleAdapter extends BaseAdapter</div><div class=""> MSSQLAdapter extends BaseAdapter</div><div class=""> MSSQL2Adapter extends MSSQLAdapter</div><div class=""> FireBirdAdapter extends BaseAdapter</div><div class=""> FireBirdEmbeddedAdapter extends FireBirdAdapter</div><div class=""> InformixAdapter extends BaseAdapter</div><div class=""> DB2Adapter extends BaseAdapter</div><div class=""> IngresAdapter extends BaseAdapter</div><div class=""> IngresUnicodeAdapter extends IngresAdapter</div><div class=""> GoogleSQLAdapter extends MySQLAdapter</div><div class=""> NoSQLAdapter extends BaseAdapter</div><div class=""> GoogleDatastoreAdapter extends NoSQLAdapter</div><div class=""> CubridAdapter extends MySQLAdapter (experimental)</div><div class=""> TeradataAdapter extends DB2Adapter (experimental)</div><div class=""> SAPDBAdapter extends BaseAdapter (experimental)</div><div class=""> CouchDBAdapter extends NoSQLAdapter (experimental)</div><div class=""> MongoDBAdapter extends NoSQLAdapter (experimental)</div><div class=""> ``</div><div class=""> </div><div class=""> which override the behavior of the ``BaseAdapter``.</div><div class=""> </div><div class=""> Each adapter has more or less this structure:</div><div class=""> </div><div class=""> ``</div><div class=""> class MySQLAdapter(BaseAdapter):</div><div class=""> </div><div class="">     # specify a diver to use</div><div class="">     driver = globals().get(&#x27;pymysql&#x27;,None)</div><div class=""> </div><div class="">     # map web2py types into database types</div><div class="">     types = {</div><div class="">         &#x27;boolean&#x27;: &#x27;CHAR(1)&#x27;,</div><div class="">         &#x27;string&#x27;: &#x27;VARCHAR(%(length)s)&#x27;,</div><div class="">         &#x27;text&#x27;: &#x27;LONGTEXT&#x27;,</div><div class="">         ...</div><div class="">         }</div><div class=""> ADAPTERS = {</div><div class="">     &#x27;oracle&#x27;: OracleAdapter,</div><div class="">     &#x27;mssql&#x27;: MSSQLAdapter,</div><div class="">     &#x27;mssql2&#x27;: MSSQL2Adapter,</div><div class="">     &#x27;db2&#x27;: DB2Adapter,</div><div class="">     &#x27;teradata&#x27;: TeradataAdapter,</div><div class="">     &#x27;informix&#x27;: InformixAdapter,</div><div class="">     &#x27;firebird&#x27;: FireBirdAdapter,</div><div class="">     &#x27;firebird_embedded&#x27;: FireBirdAdapter,</div><div class="">     &#x27;ingres&#x27;: IngresAdapter,</div><div class="">     &#x27;ingresu&#x27;: IngresUnicodeAdapter,</div><div class="">     &#x27;sapdb&#x27;: SAPDBAdapter,</div><div class="">     &#x27;cubrid&#x27;: CubridAdapter,</div><div class="">     &#x27;jdbc:sqlite&#x27;: JDBCSQLiteAdapter,</div><div class="">     &#x27;jdbc:sqlite:memory&#x27;: JDBCSQLiteAdapter,</div><div class="">     &#x27;jdbc:postgres&#x27;: JDBCPostgreSQLAdapter,</div><div class="">     &#x27;gae&#x27;: GoogleDatastoreAdapter, # discouraged, for backward compatibility</div><div class="">     &#x27;google:datastore&#x27;: GoogleDatastoreAdapter,</div><div class="">     &#x27;google:sql&#x27;: GoogleSQLAdapter,</div><div class="">     &#x27;couchdb&#x27;: CouchDBAdapter,</div><div class="">     &#x27;mongodb&#x27;: MongoDBAdapter,</div><div class=""> }</div><div class=""> ``:code</div><div class=""> </div><div class=""> the uri string is then parsed in more detail by the adapter itself.</div><div class=""> </div><div class=""> For any adapter you can replace the driver with a different one:</div><div class=""> </div><div class=""> ``</div><div class=""> import MySQLdb as mysqldb</div><div class=""> from gluon.dal import MySQLAdapter</div><div class=""> MySQLAdapter.driver = mysqldb</div><div class=""> ``</div><div class=""> i.e. ``mysqldb`` has to be &#x27;&#x27;that module&#x27;&#x27; with a .connect() method.</div><div class=""> You can specify optional driver arguments and adapter arguments:</div><div class=""> </div><div class=""> ``</div><div class=""> db =DAL(..., driver_args={}, adapter_args={})</div><div class=""> ``</div><div class=""> </div><div class=""> </div><div class=""> #### Gotchas</div><div class=""> </div><div class="delete">**SQLite** does not support dropping and altering columns. That means that web2py migrations will work up to a point. If you delete a field from a table, the column will remain in the database but <span class="highlight"></span>be invisible to web2py. If you decide to reinstate the column, web2py will try re-create it and fail. In this case you must set ``fake_migrate=True`` so that metadata is rebuilt without attempting to add the column again. Also, for the same reason, **SQLite** is not aware of any change of column type. If you insert a number in a string field, it will be stored as string. If you later change the model and replace the type &quot;string&quot; with type &quot;integer&quot;, SQLite will continue to keep the number as a string and this may cause problem when you try to extract the data.</div><div class=""> </div><div class=""> **MySQL** does not support multiple ALTER TABLE within a single transaction. This means that any migration process is broken into multiple commits. If something happens that causes a failure it is possible to break a migration (the web2py metadata are no longer in sync with the actual table structure in the database). This is unfortunate but it can be prevented (migrate one table at the time) or it can be fixed a posteriori (revert the web2py model to what corresponds to the table structure in database, set ``fake_migrate=True`` and after the metadata has been rebuilt, set ``fake_migrate=False`` and migrate the table again).</div><div class=""> </div><div class="delete">**Google SQL** has the same problems as MySQL and more. In particular table metadata itself must be stored in the database in a table that is not migrated by web2py. This is because Google App Engine has a read-only file system. Web2py migrations in Google:SQL combined with the MySQL issue described above can result in metadata corruption. Again, this can be prevented (<span class="highlight">m</span>y migrating the table at once and then setting migrate=False so that the metadata table is not accessed any more) or it can fixed a posteriori (<span class="highlight">m</span>y accessing the database using the Google dashboard and deleting any corrupted entry from the table called ``web2py_filesystem``.</div><div class=""> </div><div class=""> ``limitby``:inxx</div><div class=""> **MSSQL** does not support the SQL OFFSET keyword. Therefore the database cannot do pagination. When doing a ``limitby=(a,b)`` web2py will fetch the first ``b`` rows and discard the first ``a``. This may result in a considerable overhead when compared with other database engines.</div><div class=""> </div><div class=""> **Oracle** also does not support pagination. It does not support neither the OFFSET nor the LIMIT keywords. Web2py achieves pagination by translating a ``db(...).select(limitby=(a,b))`` into a complex three-way nested select (as suggested by official Oracle documentation). This works for simple select but may break for complex selects involving aliased fields and or joins.</div><div class=""> </div><div class="delete">**MSSQL** has problems with circular references in tables that have ONDELETE CASCADE. This is an M<span class="highlight">S</span>SSQL bug and you work around it by setting the ondelete attribute for all reference fields to &quot;NO ACTION&quot;. You can also do it once and for all before you define tables:</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/d5b786168d913e831aedb847c3eae42b87d49f1d">d5b7861</a><ul><li>Date : 2013-03-16</li><li>explains better how to switch adapters at runtime, thanks Niphlod</li></ul></li></ul>
<div class="row-fluid" id="com_d5b786168d913e831aedb847c3eae42b87d49f1d">
    <div class="span6"><div class="diff"><div class=""> ``</div><div class="insert">+import MySQLdb as mysqldb</div><div class=""> from gluon.dal import MySQLAdapter</div><div class=""> MySQLAdapter.driver = mysqldb</div><div class=""> ``</div><div class="insert">+i.e. ``mysqldb`` has to be &#x27;&#x27;that module&#x27;&#x27; with a .connect() method.</div><div class="insert">+You can specify optional driver arguments and adapter arguments:</div></div></div>
    <div class="span6"><div class="diff"><div class=""> ``</div><div class=""> from gluon.dal import MySQLAdapter</div><div class=""> MySQLAdapter.driver = mysqldb</div><div class=""> ``</div><div class="delete">-</div><div class="delete">-and you can specify optional driver arguments and adapter arguments:</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/068e4f02f4612cfdd764a910dcc633691b508de8">068e4f0</a><ul><li>Date : 2013-02-26</li><li>fixed owner in chap 6 examples</li></ul></li></ul>
<div class="row-fluid" id="com_068e4f02f4612cfdd764a910dcc633691b508de8">
    <div class="span6"><div class="diff"><div class=""> Consider the previous table person and a new table &quot;thing&quot; referencing a &quot;person&quot;:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;thing&#x27;,</div><div class="">         Field(&#x27;name&#x27;),</div><div class="insert">        Field(&#x27;owner<span class="highlight">_id</span>&#x27;,&#x27;reference person&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class=""> and a simple select from this table:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; things = db(db.thing).select()</div><div class=""> ``:code</div><div class=""> </div><div class=""> which is equivalent to</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; things = db(db.thing._id&gt;0).select()</div><div class=""> ``:code</div><div class=""> </div><div class=""> where ``._id`` is a reference to the primary key of the table. Normally ``db.thing._id`` is the same as ``db.thing.id`` and we will assume that in most of this book. ``_id``:inxx</div><div class=""> </div><div class=""> </div><div class=""> For each Row of things it is possible to fetch not just fields from the selected table (thing) but also from linked tables (recursively):</div><div class=""> ``</div><div class="insert">&gt;&gt;&gt; for thing in things: print thing.name, thing.owner<span class="highlight">_id</span>.name</div><div class=""> ``:code</div><div class=""> </div><div class="insert">Here ``thing.owner<span class="highlight">_id</span>.name`` requires one database select for each thing in things and it is therefore inefficient. We suggest using joins whenever possible instead of recursive selects, nevertheless this is convenient and practical when accessing individual records.</div><div class=""> </div><div class=""> You can also do it backwards, by selecting the things referenced by a person:</div><div class=""> </div><div class=""> ``</div><div class=""> person =  db.person(id)</div><div class=""> for thing in person.thing.select(orderby=db.thing.name):</div><div class="">     print person.name, &#x27;owns&#x27;, thing.name</div><div class=""> ``:code</div><div class=""> </div><div class=""> In this last expressions ``person.thing`` is a shortcut for</div><div class=""> </div><div class=""> ``</div><div class="insert">db(db.thing.owner<span class="highlight">_id</span>==person.id)</div><div class=""> ``:code</div><div class=""> </div><div class=""> i.e. the Set of ``thing``s referenced by the current ``person``. This syntax breaks down if the referencing table has multiple references to the referenced table. In this case one needs to be more explicit and use a full Query.</div><div class=""> </div><div class=""> </div><div class=""> #### Serializing ``Rows`` in views</div><div class=""> </div><div class=""> Given the following action containing a query</div><div class=""> ``SQLTABLE``:inxx</div><div class=""> </div><div class=""> ``</div><div class=""> def index()</div><div class="">     return dict(rows = db(query).select())</div><div class=""> ``:code</div><div class=""> </div><div class=""> The result of a select can be displayed in a view with the following syntax:</div><div class=""> ``</div><div class=""> {{extend &#x27;layout.html&#x27;}}</div><div class=""> &lt;h1&gt;Records&lt;/h1&gt;</div><div class=""> {{=rows}}</div><div class=""> Virtual fields can be &#x27;&#x27;lazy&#x27;&#x27;; all they need to do is return a function and acc</div><div class=""> ``:code</div><div class=""> </div><div class=""> or shorter using a lambda function:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; class MyVirtualFields(object):</div><div class="">         def lazy_total_price(self):</div><div class="">             return lambda self=self: self.item.unit_price \</div><div class="">                 * self.item.quantity</div><div class=""> ``:code</div><div class=""> </div><div class=""> ### One to many relation</div><div class=""> ``one to many``:inxx</div><div class=""> </div><div class=""> To illustrate how to implement one to many relations with the web2py DAL, define another table &quot;thing&quot; that refers to the table &quot;person&quot; which we redefine here:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;,</div><div class="">                     Field(&#x27;name&#x27;),</div><div class="">                     format=&#x27;%(name)s&#x27;)</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;thing&#x27;,</div><div class="">                     Field(&#x27;name&#x27;),</div><div class="insert">                    Field(&#x27;owner<span class="highlight">_id</span>&#x27;, &#x27;reference person&#x27;),</div><div class="">                     format=&#x27;%(name)s&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class="insert">Table &quot;thing&quot; has two fields, the name of the thing and the owner of the thing. The &quot;owner<span class="highlight">_id</span>&quot; field id a reference field. A reference type can be specified in two equivalent ways:</div><div class=""> </div><div class=""> ``</div><div class="insert">+Field(&#x27;owner_id&#x27;, &#x27;reference person&#x27;)</div><div class="insert">+Field(&#x27;owner_id&#x27;, db.person)</div><div class=""> ``:code</div><div class=""> </div><div class=""> The latter is always converted to the former. They are equivalent except in the case of lazy tables, self references or other types of cyclic references where the former notation is the only allowed notation.</div><div class=""> </div><div class=""> When a field type is another table, it is intended that the field reference the other table by its id. In fact, you can print the actual type value and get:</div><div class=""> ``</div><div class="insert">&gt;&gt;&gt; print db.thing.owner<span class="highlight">_id</span>.type</div><div class=""> reference person</div><div class=""> ``:code</div><div class=""> </div><div class=""> Now, insert three things, two owned by Alex and one by Bob:</div><div class=""> ``</div><div class="insert">&gt;&gt;&gt; db.thing.insert(name=&#x27;Boat&#x27;, owner<span class="highlight">_id</span>=1)</div><div class=""> 1</div><div class="insert">&gt;&gt;&gt; db.thing.insert(name=&#x27;Chair&#x27;, owner<span class="highlight">_id</span>=1)</div><div class=""> 2</div><div class="insert">&gt;&gt;&gt; db.thing.insert(name=&#x27;Shoes&#x27;, owner<span class="highlight">_id</span>=2)</div><div class=""> 3</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can select as you did for any other table:</div><div class=""> ``</div><div class="insert">&gt;&gt;&gt; for row in db(db.thing.owner<span class="highlight">_id</span>==1).select():</div><div class="">         print row.name</div><div class=""> Boat</div><div class=""> Chair</div><div class=""> ``:code</div><div class=""> </div><div class=""> Because a thing has a reference to a person, a person can have many things, so a record of table person now acquires a new attribute thing, which is a Set, that defines the things of that person. This allows looping over all persons and fetching their things easily:</div><div class=""> </div><div class=""> ``referencing``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for person in db().select(db.person.ALL):</div><div class="">         print person.name</div><div class="">         for thing in person.thing.select():</div><div class="">             print &#x27;    &#x27;, thing.name</div><div class=""> Alex</div><div class="">      Boat</div><div class="">      Chair</div><div class=""> Bob</div><div class="">      Shoes</div><div class=""> Carl</div><div class=""> ``:code</div><div class=""> </div><div class=""> #### Inner joins</div><div class=""> </div><div class=""> Another way to achieve a similar result is by using a join, specifically an INNER JOIN. web2py performs joins automatically and transparently when the query links two or more tables as in the following example:</div><div class=""> </div><div class=""> ``Rows``:inxx ``inner join``:inxx ``join``:inxx</div><div class=""> ``</div><div class="insert">&gt;&gt;&gt; rows = db(db.person.id==db.thing.owner<span class="highlight">_id</span>).select()</div><div class=""> &gt;&gt;&gt; for row in rows:</div><div class="">         print row.person.name, &#x27;has&#x27;, row.thing.name</div><div class=""> Alex has Boat</div><div class=""> Alex has Chair</div><div class=""> Bob has Shoes</div><div class=""> ``:code</div><div class=""> </div><div class=""> Observe that web2py did a join, so the rows now contain two records, one from each table, linked together. Because the two records may have fields with conflicting names, you need to specify the table when extracting a field value from a row. This means that while before you could do:</div><div class=""> ``</div><div class=""> row.name</div><div class=""> ``:code</div><div class=""> </div><div class=""> and it was obvious whether this was the name of a person or a thing, in the result of a join you have to be more explicit and say:</div><div class=""> ``</div><div class=""> row.person.name</div><div class=""> ``:code</div><div class=""> </div><div class=""> or:</div><div class=""> ``</div><div class=""> row.thing.name</div><div class=""> ``:code</div><div class=""> </div><div class=""> There is an alternative syntax for INNER JOINS:</div><div class=""> ``</div><div class="insert">&gt;&gt;&gt; rows = db(db.person).select(join=db.thing.on(db.person.id==db.thing.owner<span class="highlight">_id</span>))</div><div class=""> &gt;&gt;&gt; for row in rows:</div><div class="">     print row.person.name, &#x27;has&#x27;, row.thing.name</div><div class=""> Alex has Boat</div><div class=""> Alex has Chair</div><div class=""> Bob has Shoes</div><div class=""> ``:code</div><div class=""> </div><div class=""> While the output is the same, the generated SQL in the two cases can be different. The latter syntax removes possible ambiguities when the same table is joined twice and aliased:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;thing&#x27;,</div><div class="">         Field(&#x27;name&#x27;),</div><div class="insert">+        Field(&#x27;owner_id1&#x27;,&#x27;reference person&#x27;),</div><div class="insert">+        Field(&#x27;owner_id2&#x27;,&#x27;reference person&#x27;))</div><div class=""> &gt;&gt;&gt; rows = db(db.person).select(</div><div class="insert">+    join=[db.person.with_alias(&#x27;owner_id1&#x27;).on(db.person.id==db.thing.owner_id1).</div><div class="insert">+          db.person.with_alias(&#x27;owner_id2&#x27;).on(db.person.id==db.thing.owner_id2)])</div><div class=""> ``</div><div class=""> </div><div class=""> The value of ``join`` can be list of ``db.table.on(...)`` to join.</div><div class=""> </div><div class=""> #### Left outer join</div><div class=""> </div><div class=""> Notice that Carl did not appear in the list above because he has no things. If you intend to select on persons (whether they have things or not) and their things (if they have any), then you need to perform a LEFT OUTER JOIN. This is done using the argument &quot;left&quot; of the select command. Here is an example:</div><div class=""> </div><div class=""> ``Rows``:inxx ``left outer join``:inxx ``outer join``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows=db().select(</div><div class="">         db.person.ALL, db.thing.ALL,</div><div class="insert">        left=db.thing.on(db.person.id==db.thing.owner<span class="highlight">_id</span>))</div><div class=""> &gt;&gt;&gt; for row in rows:</div><div class="">         print row.person.name, &#x27;has&#x27;, row.thing.name</div><div class=""> Alex has Boat</div><div class=""> Alex has Chair</div><div class=""> Bob has Shoes</div><div class=""> Carl has None</div><div class=""> ``:code</div><div class=""> </div><div class=""> where:</div><div class=""> ``</div><div class=""> left = db.thing.on(...)</div><div class=""> ``:code</div><div class=""> </div><div class=""> does the left join query. Here the argument of ``db.thing.on`` is the condition required for the join (the same used above for the inner join). In the case of a left join, it is necessary to be explicit about which fields to select.</div><div class=""> </div><div class=""> Multiple left joins can be combined by passing a list or tuple of ``db.mytable.on(...)`` to the  ``left`` attribute.</div><div class=""> </div><div class=""> #### Grouping and counting</div><div class=""> </div><div class=""> When doing joins, sometimes you want to group rows according to certain criteria and count them. For example, count the number of things owned by every person. web2py allows this as well. First, you need a count operator. Second, you want to join the person table with the thing table by owner. Third, you want to select all rows (person + thing), group them by person, and count them while grouping:</div><div class=""> </div><div class=""> ``grouping``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; count = db.person.id.count()</div><div class="insert">&gt;&gt;&gt; for row in db(db.person.id==db.thing.owner<span class="highlight">_id</span>).select(</div><div class="">         db.person.name, count, groupby=db.person.name):</div><div class="">         print row.person.name, row[count]</div><div class=""> Alex 2</div><div class=""> Bob 1</div><div class=""> ``:code</div><div class=""> </div><div class=""> Notice the count operator (which is built-in) is used as a field. The only issue here is in how to retrieve the information. Each row clearly contains a person and the count, but the count is not a field of a person nor is it a table. So where does it go? It goes into the storage object representing the record with a key equal to the query expression itself. The count method of the Field object has an optional ``distinct`` argument. When set to ``True`` it specifies that only distinct values of the field in question are to be counted.</div><div class=""> </div><div class=""> ### Many to many</div><div class=""> ``many-to-many``:inxx</div><div class=""> In the previous examples, we allowed a thing to have one owner but one person could have many things. What if Boat was owned by Alex and Curt? This requires a many-to-many relation, and it is realized via an intermediate table that links a person to a thing via an ownership relation.</div><div class=""> </div><div class=""> Here is how to do it:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;,</div><div class="">                     Field(&#x27;name&#x27;))</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;thing&#x27;,</div><div class="">                     Field(&#x27;name&#x27;))</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;ownership&#x27;,</div><div class="">                     Field(&#x27;person&#x27;, &#x27;reference person&#x27;),</div><div class=""> The SQL IN operator is realized via the belongs method which returns true when t</div><div class=""> port scan</div><div class=""> xss injection</div><div class=""> ``:code</div><div class=""> </div><div class=""> The DAL also allows a nested select as the argument of the belongs operator. The only caveat is that the nested select has to be a ``_select``, not a ``select``, and only one field has to be selected explicitly, the one that defines the set.</div><div class=""> </div><div class=""> ``nested select``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; bad_days = db(db.log.severity==3)._select(db.log.event_time)</div><div class=""> &gt;&gt;&gt; for row in db(db.log.event_time.belongs(bad_days)).select():</div><div class="">         print row.event</div><div class=""> port scan</div><div class=""> xss injection</div><div class=""> unauthorized login</div><div class=""> ``:code</div><div class=""> </div><div class=""> In those cases where a nested select is required and the look-up field is a reference we can also use a query as argument. For example:</div><div class=""> </div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;,Field(&#x27;name&#x27;))</div><div class="insert">+db.define_table(&#x27;thing,Field(&#x27;name&#x27;), Field(&#x27;owner_id&#x27;,&#x27;reference thing&#x27;))</div><div class="insert">+db(db.thing.owner_id.belongs(db.person.name==&#x27;Jonathan&#x27;)).select()</div><div class=""> ``:code</div><div class=""> </div><div class="insert">In this case it is obvious that the next select only needs the field referenced by the ``db.thing.owner<span class="highlight">_id</span>`` field so we do not need the more verbose ``_select`` notation.</div><div class=""> </div><div class=""> ``nested_select``:inxx</div><div class=""> </div><div class=""> A nested select can also be used as insert/update value but in this case the syntax is different:</div><div class=""> </div><div class=""> ``</div><div class=""> lazy = db(db.person.name==&#x27;Jonathan&#x27;).nested_select(db.person.id)</div><div class="insert">db(db.thing.id==1).update(owner<span class="highlight">_id</span> = lazy)</div><div class=""> ``:code</div><div class=""> </div><div class=""> In this case ``lazy`` is a nested expression that computes the ``id`` of person &quot;Jonathan&quot;. The two lines result in one single SQL query.</div><div class=""> </div><div class=""> #### ``sum``, ``avg``, ``min``, ``max`` and ``len``</div><div class=""> </div><div class=""> ``sum``:inxx ``avg``:inxx ``min``:inxx ``max``:inxx</div><div class=""> Previously, you have used the count operator to count records. Similarly, you can use the sum operator to add (sum) the values of a specific field from a group of records. As in the case of count, the result of a sum is retrieved via the store object:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; sum = db.log.severity.sum()</div><div class=""> &gt;&gt;&gt; print db().select(sum).first()[sum]</div><div class=""> 6</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can also use ``avg``, ``min``, and ``max`` to the average, minimum, and maximum value respectively for the selected records. For example:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; max = db.log.severity.max()</div><div class=""> &gt;&gt;&gt; print db().select(max).first()[max]</div><div class=""> 3</div><div class=""> And finally, here is ``_update`` ``_update``:inxx</div><div class=""> &gt;&gt;&gt; print db(db.person.name==&#x27;Alex&#x27;)._update()</div><div class=""> UPDATE person SET  WHERE person.name=&#x27;Alex&#x27;;</div><div class=""> ``:code</div><div class=""> </div><div class=""> -----</div><div class=""> Moreover you can always use ``db._lastsql`` to return the most recent</div><div class=""> SQL code, whether it was executed manually using executesql or was SQL</div><div class=""> generated by the DAL.</div><div class=""> -----</div><div class=""> </div><div class=""> ### Exporting and importing data</div><div class=""> ``export``:inxx ``import``:inxx</div><div class=""> </div><div class=""> #### CSV (one Table at a time)</div><div class=""> </div><div class=""> When a Rows object is converted to a string it is automatically</div><div class=""> serialized in CSV:</div><div class=""> </div><div class=""> ``csv``:inxx</div><div class=""> ``</div><div class="insert">&gt;&gt;&gt; rows = db(db.person.id==db.thing.owner<span class="highlight">_id</span>).select()</div><div class=""> &gt;&gt;&gt; print rows</div><div class="insert">person.id,person.name,thing.id,thing.name,thing.owner<span class="highlight">_id</span></div><div class=""> 1,Alex,1,Boat,1</div><div class=""> 1,Alex,2,Chair,1</div><div class=""> 2,Bob,3,Shoes,2</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can serialize a single table in CSV and store it in a file &quot;test.csv&quot;:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; open(&#x27;test.csv&#x27;, &#x27;wb&#x27;).write(str(db(db.person.id).select()))</div><div class=""> ``:code</div><div class=""> </div><div class=""> This is equivalent to</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows = db(db.person.id).select()</div><div class=""> &gt;&gt;&gt; rows.export_to_csv_file(open(&#x27;test.csv&#x27;, &#x27;wb&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can read the CSV file back with:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.person.import_from_csv_file(open(&#x27;test.csv&#x27;, &#x27;r&#x27;))</div><div class=""> END</div><div class=""> ``:code</div><div class=""> </div><div class=""> The file does not include uploaded files if these are not stored in the database. In any case it is easy enough to zip the &quot;uploads&quot; folder separately.</div><div class=""> </div><div class=""> When importing, the new records will be appended to the database if it is not empty. In general the new imported records will not have the same record id as the original (saved) records but web2py will restore references so they are not broken, even if the id values may change.</div><div class=""> </div><div class=""> If a table contains a field called</div><div class=""> &quot;uuid&quot;, this field will be used to identify duplicates.  Also, if an</div><div class=""> imported record has the same &quot;uuid&quot; as an existing record, the</div><div class=""> previous record will be updated.</div><div class=""> </div><div class=""> #### CSV and remote database synchronization</div><div class=""> </div><div class=""> Consider the following model:</div><div class=""> ``</div><div class=""> db = DAL(&#x27;sqlite:memory:&#x27;)</div><div class=""> db.define_table(&#x27;person&#x27;,</div><div class="">     Field(&#x27;name&#x27;),</div><div class="">     format=&#x27;%(name)s&#x27;)</div><div class=""> db.define_table(&#x27;thing&#x27;,</div><div class="insert">    Field(&#x27;owner<span class="highlight">_id</span>&#x27;, &#x27;reference person&#x27;),</div><div class="">     Field(&#x27;name&#x27;),</div><div class="">     format=&#x27;%(name)s&#x27;)</div><div class=""> </div><div class=""> if not db(db.person).count():</div><div class="">     id = db.person.insert(name=&quot;Massimo&quot;)</div><div class="insert">    db.thing.insert(owner<span class="highlight">_id</span>=id, name=&quot;Chair&quot;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> Each record is identified by an ID and referenced by that ID. If you</div><div class=""> have two copies of the database used by distinct web2py installations,</div><div class=""> the ID is unique only within each database and not across the databases.</div><div class=""> This is a problem when merging records from different databases.</div><div class=""> </div><div class=""> In order to make a record uniquely identifiable across databases, they</div><div class=""> must:</div><div class=""> - have a unique id (UUID),</div><div class=""> - have an event_time (to figure out which one is more recent if multiple copies),</div><div class=""> - reference the UUID instead of the id.</div><div class=""> </div><div class=""> This can be achieved without modifying web2py. Here is what to do:</div><div class=""> </div><div class=""> Change the above model into:</div><div class=""> </div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;,</div><div class="">     Field(&#x27;uuid&#x27;, length=64, default=lambda:str(uuid.uuid4())),</div><div class="">     Field(&#x27;modified_on&#x27;, &#x27;datetime&#x27;, default=now),</div><div class="">     Field(&#x27;name&#x27;),</div><div class="">     format=&#x27;%(name)s&#x27;)</div><div class=""> </div><div class=""> db.define_table(&#x27;thing&#x27;,</div><div class="">     Field(&#x27;uuid&#x27;, length=64, default=lambda:str(uuid.uuid4())),</div><div class="">     Field(&#x27;modified_on&#x27;, &#x27;datetime&#x27;, default=now),</div><div class="insert">    Field(&#x27;owner<span class="highlight">_id</span>&#x27;, length=64),</div><div class="">     Field(&#x27;name&#x27;),</div><div class="">     format=&#x27;%(name)s&#x27;)</div><div class=""> </div><div class="insert">db.thing.owner<span class="highlight">_id</span>.requires = IS_IN_DB(db,&#x27;person.uuid&#x27;,&#x27;%(name)s&#x27;)</div><div class=""> </div><div class=""> if not db(db.person.id).count():</div><div class="">     id = uuid.uuid4()</div><div class="">     db.person.insert(name=&quot;Massimo&quot;, uuid=id)</div><div class="insert">    db.thing.insert(owner<span class="highlight">_id</span>=id, name=&quot;Chair&quot;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> -------</div><div class=""> Notice that in the above table definitions, the default value for the two ``uuid`` fields is set to a lambda function, which returns a UUID (converted to a string). The lambda function is called once for each record inserted, ensuring that each record gets a unique UUID, even if multiple records are inserted in a single transaction.</div><div class=""> -------</div><div class=""> </div><div class=""> Create a controller action to export the database:</div><div class=""> </div><div class=""> ``</div><div class=""> def export():</div><div class="">     s = StringIO.StringIO()</div><div class="">     db.export_to_csv_file(s)</div><div class="">     response.headers[&#x27;Content-Type&#x27;] = &#x27;text/csv&#x27;</div><div class="">     return s.getvalue()</div><div class=""> ``:code</div><div class=""> </div><div class=""> Create a controller action to import a saved copy of the other database and sync records:</div><div class=""> </div><div class=""> ``</div><div class=""> def import_and_sync():</div><div class=""> Alternatively, you can use XML-RPC to export/import the file.</div><div class=""> </div><div class=""> If the records reference uploaded files, you also need to export/import the content of the uploads folder. Notice that files therein are already labeled by UUIDs so you do not need to worry about naming conflicts and references.</div><div class=""> </div><div class=""> #### HTML and XML (one Table at a time)</div><div class=""> </div><div class=""> ``Rows objects``:inxx</div><div class=""> Rows objects also have an ``xml`` method (like helpers) that serializes it to XML/HTML:</div><div class=""> </div><div class=""> ``HTML``:inxx</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows = db(db.person.id &gt; 0).select()</div><div class=""> &gt;&gt;&gt; print rows.xml()</div><div class=""> &lt;table&gt;</div><div class="">   &lt;thead&gt;</div><div class="">     &lt;tr&gt;</div><div class="">       &lt;th&gt;person.id&lt;/th&gt;</div><div class="">       &lt;th&gt;person.name&lt;/th&gt;</div><div class="">       &lt;th&gt;thing.id&lt;/th&gt;</div><div class="">       &lt;th&gt;thing.name&lt;/th&gt;</div><div class="insert">      &lt;th&gt;thing.owner<span class="highlight">_id</span>&lt;/th&gt;</div><div class="">     &lt;/tr&gt;</div><div class="">   &lt;/thead&gt;</div><div class="">   &lt;tbody&gt;</div><div class="">     &lt;tr class=&quot;even&quot;&gt;</div><div class="">       &lt;td&gt;1&lt;/td&gt;</div><div class="">       &lt;td&gt;Alex&lt;/td&gt;</div><div class="">       &lt;td&gt;1&lt;/td&gt;</div><div class="">       &lt;td&gt;Boat&lt;/td&gt;</div><div class="">       &lt;td&gt;1&lt;/td&gt;</div><div class="">     &lt;/tr&gt;</div><div class="">     ...</div><div class="">   &lt;/tbody&gt;</div><div class=""> &lt;/table&gt;</div><div class=""> ``:code</div></div></div>
    <div class="span6"><div class="diff"><div class=""> Consider the previous table person and a new table &quot;thing&quot; referencing a &quot;person&quot;:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;thing&#x27;,</div><div class="">         Field(&#x27;name&#x27;),</div><div class="delete">        Field(&#x27;owner<span class="highlight"></span>&#x27;,&#x27;reference person&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class=""> and a simple select from this table:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; things = db(db.thing).select()</div><div class=""> ``:code</div><div class=""> </div><div class=""> which is equivalent to</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; things = db(db.thing._id&gt;0).select()</div><div class=""> ``:code</div><div class=""> </div><div class=""> where ``._id`` is a reference to the primary key of the table. Normally ``db.thing._id`` is the same as ``db.thing.id`` and we will assume that in most of this book. ``_id``:inxx</div><div class=""> </div><div class=""> </div><div class=""> For each Row of things it is possible to fetch not just fields from the selected table (thing) but also from linked tables (recursively):</div><div class=""> ``</div><div class="delete">&gt;&gt;&gt; for thing in things: print thing.name, thing.owner<span class="highlight"></span>.name</div><div class=""> ``:code</div><div class=""> </div><div class="delete">Here ``thing.owner<span class="highlight"></span>.name`` requires one database select for each thing in things and it is therefore inefficient. We suggest using joins whenever possible instead of recursive selects, nevertheless this is convenient and practical when accessing individual records.</div><div class=""> </div><div class=""> You can also do it backwards, by selecting the things referenced by a person:</div><div class=""> </div><div class=""> ``</div><div class=""> person =  db.person(id)</div><div class=""> for thing in person.thing.select(orderby=db.thing.name):</div><div class="">     print person.name, &#x27;owns&#x27;, thing.name</div><div class=""> ``:code</div><div class=""> </div><div class=""> In this last expressions ``person.thing`` is a shortcut for</div><div class=""> </div><div class=""> ``</div><div class="delete">db(db.thing.owner<span class="highlight"></span>==person.id)</div><div class=""> ``:code</div><div class=""> </div><div class=""> i.e. the Set of ``thing``s referenced by the current ``person``. This syntax breaks down if the referencing table has multiple references to the referenced table. In this case one needs to be more explicit and use a full Query.</div><div class=""> </div><div class=""> </div><div class=""> #### Serializing ``Rows`` in views</div><div class=""> </div><div class=""> Given the following action containing a query</div><div class=""> ``SQLTABLE``:inxx</div><div class=""> </div><div class=""> ``</div><div class=""> def index()</div><div class="">     return dict(rows = db(query).select())</div><div class=""> ``:code</div><div class=""> </div><div class=""> The result of a select can be displayed in a view with the following syntax:</div><div class=""> ``</div><div class=""> {{extend &#x27;layout.html&#x27;}}</div><div class=""> &lt;h1&gt;Records&lt;/h1&gt;</div><div class=""> {{=rows}}</div><div class=""> Virtual fields can be &#x27;&#x27;lazy&#x27;&#x27;; all they need to do is return a function and acc</div><div class=""> ``:code</div><div class=""> </div><div class=""> or shorter using a lambda function:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; class MyVirtualFields(object):</div><div class="">         def lazy_total_price(self):</div><div class="">             return lambda self=self: self.item.unit_price \</div><div class="">                 * self.item.quantity</div><div class=""> ``:code</div><div class=""> </div><div class=""> ### One to many relation</div><div class=""> ``one to many``:inxx</div><div class=""> </div><div class=""> To illustrate how to implement one to many relations with the web2py DAL, define another table &quot;thing&quot; that refers to the table &quot;person&quot; which we redefine here:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;,</div><div class="">                     Field(&#x27;name&#x27;),</div><div class="">                     format=&#x27;%(name)s&#x27;)</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;thing&#x27;,</div><div class="">                     Field(&#x27;name&#x27;),</div><div class="delete">                    Field(&#x27;owner<span class="highlight"></span>&#x27;, &#x27;reference person&#x27;),</div><div class="">                     format=&#x27;%(name)s&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class="delete">Table &quot;thing&quot; has two fields, the name of the thing and the owner of the thing. The &quot;owner<span class="highlight"></span>&quot; field id a reference field. A reference type can be specified in two equivalent ways:</div><div class=""> </div><div class=""> ``</div><div class="delete">-Field(&#x27;owner&#x27;, &#x27;reference person&#x27;)</div><div class="delete">-Field(&#x27;owner&#x27;, db.person)</div><div class=""> ``:code</div><div class=""> </div><div class=""> The latter is always converted to the former. They are equivalent except in the case of lazy tables, self references or other types of cyclic references where the former notation is the only allowed notation.</div><div class=""> </div><div class=""> When a field type is another table, it is intended that the field reference the other table by its id. In fact, you can print the actual type value and get:</div><div class=""> ``</div><div class="delete">&gt;&gt;&gt; print db.thing.owner<span class="highlight"></span>.type</div><div class=""> reference person</div><div class=""> ``:code</div><div class=""> </div><div class=""> Now, insert three things, two owned by Alex and one by Bob:</div><div class=""> ``</div><div class="delete">&gt;&gt;&gt; db.thing.insert(name=&#x27;Boat&#x27;, owner<span class="highlight"></span>=1)</div><div class=""> 1</div><div class="delete">&gt;&gt;&gt; db.thing.insert(name=&#x27;Chair&#x27;, owner<span class="highlight"></span>=1)</div><div class=""> 2</div><div class="delete">&gt;&gt;&gt; db.thing.insert(name=&#x27;Shoes&#x27;, owner<span class="highlight"></span>=2)</div><div class=""> 3</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can select as you did for any other table:</div><div class=""> ``</div><div class="delete">&gt;&gt;&gt; for row in db(db.thing.owner<span class="highlight"></span>==1).select():</div><div class="">         print row.name</div><div class=""> Boat</div><div class=""> Chair</div><div class=""> ``:code</div><div class=""> </div><div class=""> Because a thing has a reference to a person, a person can have many things, so a record of table person now acquires a new attribute thing, which is a Set, that defines the things of that person. This allows looping over all persons and fetching their things easily:</div><div class=""> </div><div class=""> ``referencing``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for person in db().select(db.person.ALL):</div><div class="">         print person.name</div><div class="">         for thing in person.thing.select():</div><div class="">             print &#x27;    &#x27;, thing.name</div><div class=""> Alex</div><div class="">      Boat</div><div class="">      Chair</div><div class=""> Bob</div><div class="">      Shoes</div><div class=""> Carl</div><div class=""> ``:code</div><div class=""> </div><div class=""> #### Inner joins</div><div class=""> </div><div class=""> Another way to achieve a similar result is by using a join, specifically an INNER JOIN. web2py performs joins automatically and transparently when the query links two or more tables as in the following example:</div><div class=""> </div><div class=""> ``Rows``:inxx ``inner join``:inxx ``join``:inxx</div><div class=""> ``</div><div class="delete">&gt;&gt;&gt; rows = db(db.person.id==db.thing.owner<span class="highlight"></span>).select()</div><div class=""> &gt;&gt;&gt; for row in rows:</div><div class="">         print row.person.name, &#x27;has&#x27;, row.thing.name</div><div class=""> Alex has Boat</div><div class=""> Alex has Chair</div><div class=""> Bob has Shoes</div><div class=""> ``:code</div><div class=""> </div><div class=""> Observe that web2py did a join, so the rows now contain two records, one from each table, linked together. Because the two records may have fields with conflicting names, you need to specify the table when extracting a field value from a row. This means that while before you could do:</div><div class=""> ``</div><div class=""> row.name</div><div class=""> ``:code</div><div class=""> </div><div class=""> and it was obvious whether this was the name of a person or a thing, in the result of a join you have to be more explicit and say:</div><div class=""> ``</div><div class=""> row.person.name</div><div class=""> ``:code</div><div class=""> </div><div class=""> or:</div><div class=""> ``</div><div class=""> row.thing.name</div><div class=""> ``:code</div><div class=""> </div><div class=""> There is an alternative syntax for INNER JOINS:</div><div class=""> ``</div><div class="delete">&gt;&gt;&gt; rows = db(db.person).select(join=db.thing.on(db.person.id==db.thing.owner<span class="highlight"></span>))</div><div class=""> &gt;&gt;&gt; for row in rows:</div><div class="">     print row.person.name, &#x27;has&#x27;, row.thing.name</div><div class=""> Alex has Boat</div><div class=""> Alex has Chair</div><div class=""> Bob has Shoes</div><div class=""> ``:code</div><div class=""> </div><div class=""> While the output is the same, the generated SQL in the two cases can be different. The latter syntax removes possible ambiguities when the same table is joined twice and aliased:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;thing&#x27;,</div><div class="">         Field(&#x27;name&#x27;),</div><div class="delete">-        Field(&#x27;owner1&#x27;,&#x27;reference person&#x27;),</div><div class="delete">-        Field(&#x27;owner2&#x27;,&#x27;reference person&#x27;))</div><div class=""> &gt;&gt;&gt; rows = db(db.person).select(</div><div class="delete">-    join=[db.person.with_alias(&#x27;owner1&#x27;).on(db.person.id==db.thing.owner1).</div><div class="delete">-          db.person.with_alias(&#x27;owner2&#x27;).on(db.person.id==db.thing.owner2)])</div><div class=""> ``</div><div class=""> </div><div class=""> The value of ``join`` can be list of ``db.table.on(...)`` to join.</div><div class=""> </div><div class=""> #### Left outer join</div><div class=""> </div><div class=""> Notice that Carl did not appear in the list above because he has no things. If you intend to select on persons (whether they have things or not) and their things (if they have any), then you need to perform a LEFT OUTER JOIN. This is done using the argument &quot;left&quot; of the select command. Here is an example:</div><div class=""> </div><div class=""> ``Rows``:inxx ``left outer join``:inxx ``outer join``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows=db().select(</div><div class="">         db.person.ALL, db.thing.ALL,</div><div class="delete">        left=db.thing.on(db.person.id==db.thing.owner<span class="highlight"></span>))</div><div class=""> &gt;&gt;&gt; for row in rows:</div><div class="">         print row.person.name, &#x27;has&#x27;, row.thing.name</div><div class=""> Alex has Boat</div><div class=""> Alex has Chair</div><div class=""> Bob has Shoes</div><div class=""> Carl has None</div><div class=""> ``:code</div><div class=""> </div><div class=""> where:</div><div class=""> ``</div><div class=""> left = db.thing.on(...)</div><div class=""> ``:code</div><div class=""> </div><div class=""> does the left join query. Here the argument of ``db.thing.on`` is the condition required for the join (the same used above for the inner join). In the case of a left join, it is necessary to be explicit about which fields to select.</div><div class=""> </div><div class=""> Multiple left joins can be combined by passing a list or tuple of ``db.mytable.on(...)`` to the  ``left`` attribute.</div><div class=""> </div><div class=""> #### Grouping and counting</div><div class=""> </div><div class=""> When doing joins, sometimes you want to group rows according to certain criteria and count them. For example, count the number of things owned by every person. web2py allows this as well. First, you need a count operator. Second, you want to join the person table with the thing table by owner. Third, you want to select all rows (person + thing), group them by person, and count them while grouping:</div><div class=""> </div><div class=""> ``grouping``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; count = db.person.id.count()</div><div class="delete">&gt;&gt;&gt; for row in db(db.person.id==db.thing.owner<span class="highlight"></span>).select(</div><div class="">         db.person.name, count, groupby=db.person.name):</div><div class="">         print row.person.name, row[count]</div><div class=""> Alex 2</div><div class=""> Bob 1</div><div class=""> ``:code</div><div class=""> </div><div class=""> Notice the count operator (which is built-in) is used as a field. The only issue here is in how to retrieve the information. Each row clearly contains a person and the count, but the count is not a field of a person nor is it a table. So where does it go? It goes into the storage object representing the record with a key equal to the query expression itself. The count method of the Field object has an optional ``distinct`` argument. When set to ``True`` it specifies that only distinct values of the field in question are to be counted.</div><div class=""> </div><div class=""> ### Many to many</div><div class=""> ``many-to-many``:inxx</div><div class=""> In the previous examples, we allowed a thing to have one owner but one person could have many things. What if Boat was owned by Alex and Curt? This requires a many-to-many relation, and it is realized via an intermediate table that links a person to a thing via an ownership relation.</div><div class=""> </div><div class=""> Here is how to do it:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;,</div><div class="">                     Field(&#x27;name&#x27;))</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;thing&#x27;,</div><div class="">                     Field(&#x27;name&#x27;))</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;ownership&#x27;,</div><div class="">                     Field(&#x27;person&#x27;, &#x27;reference person&#x27;),</div><div class=""> The SQL IN operator is realized via the belongs method which returns true when t</div><div class=""> port scan</div><div class=""> xss injection</div><div class=""> ``:code</div><div class=""> </div><div class=""> The DAL also allows a nested select as the argument of the belongs operator. The only caveat is that the nested select has to be a ``_select``, not a ``select``, and only one field has to be selected explicitly, the one that defines the set.</div><div class=""> </div><div class=""> ``nested select``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; bad_days = db(db.log.severity==3)._select(db.log.event_time)</div><div class=""> &gt;&gt;&gt; for row in db(db.log.event_time.belongs(bad_days)).select():</div><div class="">         print row.event</div><div class=""> port scan</div><div class=""> xss injection</div><div class=""> unauthorized login</div><div class=""> ``:code</div><div class=""> </div><div class=""> In those cases where a nested select is required and the look-up field is a reference we can also use a query as argument. For example:</div><div class=""> </div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;,Field(&#x27;name&#x27;))</div><div class="delete">-db.define_table(&#x27;thing&#x27;,Field(&#x27;owner&#x27;),Field(&#x27;owner&#x27;,&#x27;reference thing&#x27;))</div><div class="delete">-db(db.thing.owner.belongs(db.person.name==&#x27;Jonathan&#x27;)).select()</div><div class=""> ``:code</div><div class=""> </div><div class="delete">In this case it is obvious that the next select only needs the field referenced by the ``db.thing.owner<span class="highlight"></span>`` field so we do not need the more verbose ``_select`` notation.</div><div class=""> </div><div class=""> ``nested_select``:inxx</div><div class=""> </div><div class=""> A nested select can also be used as insert/update value but in this case the syntax is different:</div><div class=""> </div><div class=""> ``</div><div class=""> lazy = db(db.person.name==&#x27;Jonathan&#x27;).nested_select(db.person.id)</div><div class="delete">db(db.thing.id==1).update(owner<span class="highlight"></span> = lazy)</div><div class=""> ``:code</div><div class=""> </div><div class=""> In this case ``lazy`` is a nested expression that computes the ``id`` of person &quot;Jonathan&quot;. The two lines result in one single SQL query.</div><div class=""> </div><div class=""> #### ``sum``, ``avg``, ``min``, ``max`` and ``len``</div><div class=""> </div><div class=""> ``sum``:inxx ``avg``:inxx ``min``:inxx ``max``:inxx</div><div class=""> Previously, you have used the count operator to count records. Similarly, you can use the sum operator to add (sum) the values of a specific field from a group of records. As in the case of count, the result of a sum is retrieved via the store object:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; sum = db.log.severity.sum()</div><div class=""> &gt;&gt;&gt; print db().select(sum).first()[sum]</div><div class=""> 6</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can also use ``avg``, ``min``, and ``max`` to the average, minimum, and maximum value respectively for the selected records. For example:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; max = db.log.severity.max()</div><div class=""> &gt;&gt;&gt; print db().select(max).first()[max]</div><div class=""> 3</div><div class=""> And finally, here is ``_update`` ``_update``:inxx</div><div class=""> &gt;&gt;&gt; print db(db.person.name==&#x27;Alex&#x27;)._update()</div><div class=""> UPDATE person SET  WHERE person.name=&#x27;Alex&#x27;;</div><div class=""> ``:code</div><div class=""> </div><div class=""> -----</div><div class=""> Moreover you can always use ``db._lastsql`` to return the most recent</div><div class=""> SQL code, whether it was executed manually using executesql or was SQL</div><div class=""> generated by the DAL.</div><div class=""> -----</div><div class=""> </div><div class=""> ### Exporting and importing data</div><div class=""> ``export``:inxx ``import``:inxx</div><div class=""> </div><div class=""> #### CSV (one Table at a time)</div><div class=""> </div><div class=""> When a Rows object is converted to a string it is automatically</div><div class=""> serialized in CSV:</div><div class=""> </div><div class=""> ``csv``:inxx</div><div class=""> ``</div><div class="delete">&gt;&gt;&gt; rows = db(db.person.id==db.thing.owner<span class="highlight"></span>).select()</div><div class=""> &gt;&gt;&gt; print rows</div><div class="delete">person.id,person.name,thing.id,thing.name,thing.owner<span class="highlight"></span></div><div class=""> 1,Alex,1,Boat,1</div><div class=""> 1,Alex,2,Chair,1</div><div class=""> 2,Bob,3,Shoes,2</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can serialize a single table in CSV and store it in a file &quot;test.csv&quot;:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; open(&#x27;test.csv&#x27;, &#x27;wb&#x27;).write(str(db(db.person.id).select()))</div><div class=""> ``:code</div><div class=""> </div><div class=""> This is equivalent to</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows = db(db.person.id).select()</div><div class=""> &gt;&gt;&gt; rows.export_to_csv_file(open(&#x27;test.csv&#x27;, &#x27;wb&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can read the CSV file back with:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.person.import_from_csv_file(open(&#x27;test.csv&#x27;, &#x27;r&#x27;))</div><div class=""> END</div><div class=""> ``:code</div><div class=""> </div><div class=""> The file does not include uploaded files if these are not stored in the database. In any case it is easy enough to zip the &quot;uploads&quot; folder separately.</div><div class=""> </div><div class=""> When importing, the new records will be appended to the database if it is not empty. In general the new imported records will not have the same record id as the original (saved) records but web2py will restore references so they are not broken, even if the id values may change.</div><div class=""> </div><div class=""> If a table contains a field called</div><div class=""> &quot;uuid&quot;, this field will be used to identify duplicates.  Also, if an</div><div class=""> imported record has the same &quot;uuid&quot; as an existing record, the</div><div class=""> previous record will be updated.</div><div class=""> </div><div class=""> #### CSV and remote database synchronization</div><div class=""> </div><div class=""> Consider the following model:</div><div class=""> ``</div><div class=""> db = DAL(&#x27;sqlite:memory:&#x27;)</div><div class=""> db.define_table(&#x27;person&#x27;,</div><div class="">     Field(&#x27;name&#x27;),</div><div class="">     format=&#x27;%(name)s&#x27;)</div><div class=""> db.define_table(&#x27;thing&#x27;,</div><div class="delete">    Field(&#x27;owner<span class="highlight"></span>&#x27;, &#x27;reference person&#x27;),</div><div class="">     Field(&#x27;name&#x27;),</div><div class="">     format=&#x27;%(name)s&#x27;)</div><div class=""> </div><div class=""> if not db(db.person).count():</div><div class="">     id = db.person.insert(name=&quot;Massimo&quot;)</div><div class="delete">    db.thing.insert(owner<span class="highlight"></span>=id, name=&quot;Chair&quot;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> Each record is identified by an ID and referenced by that ID. If you</div><div class=""> have two copies of the database used by distinct web2py installations,</div><div class=""> the ID is unique only within each database and not across the databases.</div><div class=""> This is a problem when merging records from different databases.</div><div class=""> </div><div class=""> In order to make a record uniquely identifiable across databases, they</div><div class=""> must:</div><div class=""> - have a unique id (UUID),</div><div class=""> - have an event_time (to figure out which one is more recent if multiple copies),</div><div class=""> - reference the UUID instead of the id.</div><div class=""> </div><div class=""> This can be achieved without modifying web2py. Here is what to do:</div><div class=""> </div><div class=""> Change the above model into:</div><div class=""> </div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;,</div><div class="">     Field(&#x27;uuid&#x27;, length=64, default=lambda:str(uuid.uuid4())),</div><div class="">     Field(&#x27;modified_on&#x27;, &#x27;datetime&#x27;, default=now),</div><div class="">     Field(&#x27;name&#x27;),</div><div class="">     format=&#x27;%(name)s&#x27;)</div><div class=""> </div><div class=""> db.define_table(&#x27;thing&#x27;,</div><div class="">     Field(&#x27;uuid&#x27;, length=64, default=lambda:str(uuid.uuid4())),</div><div class="">     Field(&#x27;modified_on&#x27;, &#x27;datetime&#x27;, default=now),</div><div class="delete">    Field(&#x27;owner<span class="highlight"></span>&#x27;, length=64),</div><div class="">     Field(&#x27;name&#x27;),</div><div class="">     format=&#x27;%(name)s&#x27;)</div><div class=""> </div><div class="delete">db.thing.owner<span class="highlight"></span>.requires = IS_IN_DB(db,&#x27;person.uuid&#x27;,&#x27;%(name)s&#x27;)</div><div class=""> </div><div class=""> if not db(db.person.id).count():</div><div class="">     id = uuid.uuid4()</div><div class="">     db.person.insert(name=&quot;Massimo&quot;, uuid=id)</div><div class="delete">    db.thing.insert(owner<span class="highlight"></span>=id, name=&quot;Chair&quot;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> -------</div><div class=""> Notice that in the above table definitions, the default value for the two ``uuid`` fields is set to a lambda function, which returns a UUID (converted to a string). The lambda function is called once for each record inserted, ensuring that each record gets a unique UUID, even if multiple records are inserted in a single transaction.</div><div class=""> -------</div><div class=""> </div><div class=""> Create a controller action to export the database:</div><div class=""> </div><div class=""> ``</div><div class=""> def export():</div><div class="">     s = StringIO.StringIO()</div><div class="">     db.export_to_csv_file(s)</div><div class="">     response.headers[&#x27;Content-Type&#x27;] = &#x27;text/csv&#x27;</div><div class="">     return s.getvalue()</div><div class=""> ``:code</div><div class=""> </div><div class=""> Create a controller action to import a saved copy of the other database and sync records:</div><div class=""> </div><div class=""> ``</div><div class=""> def import_and_sync():</div><div class=""> Alternatively, you can use XML-RPC to export/import the file.</div><div class=""> </div><div class=""> If the records reference uploaded files, you also need to export/import the content of the uploads folder. Notice that files therein are already labeled by UUIDs so you do not need to worry about naming conflicts and references.</div><div class=""> </div><div class=""> #### HTML and XML (one Table at a time)</div><div class=""> </div><div class=""> ``Rows objects``:inxx</div><div class=""> Rows objects also have an ``xml`` method (like helpers) that serializes it to XML/HTML:</div><div class=""> </div><div class=""> ``HTML``:inxx</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows = db(db.person.id &gt; 0).select()</div><div class=""> &gt;&gt;&gt; print rows.xml()</div><div class=""> &lt;table&gt;</div><div class="">   &lt;thead&gt;</div><div class="">     &lt;tr&gt;</div><div class="">       &lt;th&gt;person.id&lt;/th&gt;</div><div class="">       &lt;th&gt;person.name&lt;/th&gt;</div><div class="">       &lt;th&gt;thing.id&lt;/th&gt;</div><div class="">       &lt;th&gt;thing.name&lt;/th&gt;</div><div class="delete">      &lt;th&gt;thing.owner<span class="highlight"></span>&lt;/th&gt;</div><div class="">     &lt;/tr&gt;</div><div class="">   &lt;/thead&gt;</div><div class="">   &lt;tbody&gt;</div><div class="">     &lt;tr class=&quot;even&quot;&gt;</div><div class="">       &lt;td&gt;1&lt;/td&gt;</div><div class="">       &lt;td&gt;Alex&lt;/td&gt;</div><div class="">       &lt;td&gt;1&lt;/td&gt;</div><div class="">       &lt;td&gt;Boat&lt;/td&gt;</div><div class="">       &lt;td&gt;1&lt;/td&gt;</div><div class="">     &lt;/tr&gt;</div><div class="">     ...</div><div class="">   &lt;/tbody&gt;</div><div class=""> &lt;/table&gt;</div><div class=""> ``:code</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/9f8f7358720ecddc06a79b90a68cc94ae5b28603">9f8f735</a><ul><li>Date : 2013-02-25</li><li>some edits</li></ul></li></ul>
<div class="row-fluid" id="com_9f8f7358720ecddc06a79b90a68cc94ae5b28603">
    <div class="span6"><div class="diff"><div class="insert">web2py comes with a Database Abstraction Layer (DAL), an API that maps Python objects into database objects such as queries, tables, and records. The DAL dynamically generates the SQL in real time using the specified dialect for the database back end, so that you do not have to write SQL code or learn different SQL dialects (the term SQL is used generically), and the application will be portable among different types of databases. A<span class="highlight"> partial list of</span> supported databases <span class="highlight">is show in the table below</span>. Please check on the web2py web site and mailing list for more recent adapters. Google NoSQL is treated as a particular case in Chapter 13.</div><div class=""> </div><div class=""> The Windows binary distribution works out of the box with SQLite and MySQL. The Mac binary distribution works out of the box with SQLite.</div><div class=""> To use any other database back-end, run from the source distribution and install the appropriate driver for the required back end.</div><div class=""> ``database drivers``:inxx</div><div class=""> </div><div class=""> Once the proper driver is installed, start web2py from source, and it will find the driver. Here is a list of drivers:</div><div class=""> </div><div class=""> ``DAL``:inxx ``SQLite``:inxx ``MySQL``:inxx ``PostgresSQL``:inxx ``Oracle``:inxx ``MSSQL``:inxx ``FireBird``:inxx ``DB2``:inxx ``Informix``:inxx ``Sybase``:inxx ``Teradata``:inxx ``MongoDB``:inxx ``CouchDB``:inxx ``SAPDB``:inxx ``Cubrid``:inxx</div><div class=""> </div><div class=""> ----------</div><div class=""> database | drivers (source)</div><div class=""> SQLite | sqlite3 or pysqlite2 or zxJDBC ``zxjdbc``:cite  (on Jython)</div><div class=""> PostgreSQL | psycopg2 ``psycopg2``:cite  or pg8000 ``pg8000``:cite or zxJDBC ``zxjdbc``:cite  (on Jython)</div><div class=""> MySQL | pymysql ``pymysql``:cite or MySQLdb ``mysqldb``:cite</div><div class=""> Oracle | cx_Oracle ``cxoracle``:cite</div><div class=""> MSSQL | pyodbc ``pyodbc``:cite</div><div class=""> FireBird | kinterbasdb ``kinterbasdb``:cite or fdb or pyodbc</div><div class=""> DB2 | pyodbc ``pyodbc``:cite</div><div class=""> Informix | informixdb ``informixdb``:cite</div><div class=""> Ingres | ingresdbi ``ingresdbi``:cite</div><div class=""> Cubrid | cubriddb ``cubridb``:cite ``cubridb``:cite</div><div class=""> Sybase | Sybase ``Sybase``:cite</div><div class=""> Teradata | pyodbc ``Teradata``:cite</div><div class=""> SAPDB    | sapdb ``SAPDB``:cite</div><div class=""> MongoDB | pymongo ``pymongo``:cite</div><div class=""> IMAP | imaplib ``IMAP``:cite</div><div class=""> ---------</div><div class=""> </div><div class=""> ``sqlite3``, ``pymysql``, ``pg8000``, and ``imaplib`` ship with web2py. Support of MongoDB is experimental. The IMAP option allows to use DAL to access IMAP.</div><div class=""> </div><div class=""> web2py defines the following classes that make up the DAL:</div><div class=""> </div><div class="insert"><span class="highlight">The </span>**DAL**<span class="highlight"> object</span> represents a database connection. For example:</div><div class=""> ``sqlite``:inxx</div><div class=""> ``</div><div class=""> db = DAL(&#x27;sqlite://storage.db&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> ``define_table``:inxx</div><div class=""> **Table** represents a database table.  You do not directly instantiate Table; instead, ``DAL.define_table`` instantiates it.</div><div class=""> ``</div><div class=""> db.define_table(&#x27;mytable&#x27;, Field(&#x27;myfield&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class=""> The most important methods of a Table are:</div><div class=""> ``insert``:inxx</div><div class=""> ``truncate``:inxx</div><div class=""> ``drop``:inxx</div><div class=""> ``import_from_csv_file``:inxx</div><div class=""> ``count``:inxx</div><div class=""> ``.insert``, ``.truncate``, ``.drop``, and ``.import_from_csv_file``.</div><div class=""> </div><div class=""> ``Field``:inxx</div><div class=""> Some times you may need to generate SQL as if you had a connection but without a</div><div class=""> </div><div class=""> ``</div><div class=""> db = DAL(&#x27;...&#x27;, do_connect=False)</div><div class=""> ``:code</div><div class=""> </div><div class=""> In this case you will be able to call ``_select``, ``_insert``, ``_update``, and ``_delete`` to generate SQL but not call ``select``, ``insert``, ``update``, and ``delete``. In most of the cases you can use ``do_connect=False`` even without having the required database drivers.</div><div class=""> </div><div class=""> Notice that by default web2py uses utf8 character encoding for databases. If you work with existing databases that behave differently, you have to change it with the optional parameter ``db_codec`` like</div><div class=""> </div><div class=""> ``</div><div class=""> db = DAL(&#x27;...&#x27;, db_codec=&#x27;latin1&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> otherwise you&#x27;ll get UnicodeDecodeErrors tickets.</div><div class=""> </div><div class=""> #### Connection pooling</div><div class=""> ``connection pooling``:inxx</div><div class=""> </div><div class=""> The second argument of the DAL constructor is the ``pool_size``; it defaults to zero.</div><div class=""> </div><div class="insert">As it is rather slow to establish a new database connection for each request, web2py implements a mechanism for connection pooling. Once a connection is established and the page has been served and the transaction completed, the connection is not closed but goes into a pool. When the next http request arrives, web2py tries to <span class="highlight">recycle</span> a connection from the pool and use that for the new transaction. If there are no available connections in the pool, a new connection is established.</div><div class=""> </div><div class="insert"><span class="highlight">When web2py starts, the pool is always empty. </span>The <span class="highlight">pool grows up to the minimum between the value of </span>``pool_size`` <span class="highlight">and the max number of concurrent requests. This means that if ``pool_size=10`` but our server never receives more than 5 concurrent requests, then the actual pool size will only </span>g<span class="highlight">row to 5. If ``pool_size=0`` then connection pooling is not us</span>ed<span class="highlight"></span>.</div><div class=""> </div><div class=""> Connections in the pools are shared sequentially among threads, in the sense that they may be used by two different but not simultaneous threads. There is only one pool for each web2py process.</div><div class=""> </div><div class="insert"><span class="highlight">The ``pool_size`` parameter is ignored by SQLite and Google App Engine.</span></div><div class=""> Connection pooling is ignored for SQLite, since it would not yield any benefit.</div><div class=""> </div><div class=""> #### Connection failures</div><div class=""> </div><div class=""> If web2py fails to connect to the database it waits 1 seconds and tries again up to 5 times before declaring a failure. In case of connection pooling it is possible that a pooled connection that stays open but unused for some time is closed by the database end. Thanks to the retry feature web2py tries to re-establish these dropped connections.</div><div class=""> </div><div class=""> #### Replicated databases</div><div class=""> </div><div class=""> The first argument of ``DAL(...)`` can be a list of URIs. In this case web2py tries to connect to each of them. The main purpose for this is to deal with multiple database servers and distribute the workload among them). Here is a typical use case:</div><div class=""> </div><div class=""> ``</div><div class=""> db = DAL([&#x27;mysql://...1&#x27;,&#x27;mysql://...2&#x27;,&#x27;mysql://...3&#x27;])</div><div class=""> ``:code</div><div class=""> </div><div class=""> In this case the DAL tries to connect to the first and, on failure, it</div><div class=""> will try the second and the third. This can also be used to distribute load</div><div class=""> in a database master-slave configuration. We will talk more about this</div><div class=""> in Chapter 13 in the context of scalability.</div><div class=""> </div><div class=""> ### Reserved keywords</div><div class=""> ``reserved Keywords``:inxx</div><div class=""> </div><div class="insert"><span class="highlight">``c</span>he<span class="highlight">ck_</span>re<span class="highlight">served``</span> is <span class="highlight">yet</span> another argument that can be passed to the DAL constructor<span class="highlight">. It tells it</span> to check table names and column names against reserved SQL keywords in target back-end databases.</div><div class=""> </div><div class=""> This argument is ``check_reserved`` and it defaults to None.</div><div class=""> </div><div class=""> This is a list of strings that contain the database back-end adapter names.</div><div class=""> </div><div class=""> The adapter name is the same as used in the DAL connection string. So if you want to check against PostgreSQL and MSSQL then your connection string would look as follows:</div><div class=""> ``</div><div class=""> db = DAL(&#x27;sqlite://storage.db&#x27;,</div><div class="">          check_reserved=[&#x27;postgres&#x27;, &#x27;mssql&#x27;])</div><div class=""> ``:code</div><div class=""> </div><div class=""> The DAL will scan the keywords in the same order as of the list.</div><div class=""> </div><div class=""> There are two extra options &quot;all&quot; and &quot;common&quot;. If you specify all, it will check against all known SQL keywords. If you specify common, it will only check against common SQL keywords such as ``SELECT``, ``INSERT``, ``UPDATE``, etc.</div><div class=""> </div><div class=""> For supported back-ends you may also specify if you would like to check against the non-reserved SQL keywords as well. In this case you would append ``_nonreserved`` to the name. For example:</div><div class=""> ``</div><div class=""> check_reserved=[&#x27;postgres&#x27;, &#x27;postgres_nonreserved&#x27;]</div><div class=""> ``:code</div><div class=""> </div><div class=""> The following database backends support reserved words checking.</div><div class=""> </div><div class=""> -----</div><div class=""> **PostgreSQL** | ``postgres(_nonreserved)``</div><div class=""> **MySQL** | ``mysql``</div><div class=""> **FireBird** | ``firebird(_nonreserved)``</div><div class=""> **MSSQL** | ``mssql``</div><div class=""> **Oracle** | ``oracle``</div><div class=""> -----</div><div class=""> </div><div class=""> ### ``DAL``, ``Table``, ``Field``</div><div class=""> </div><div class="insert"><span class="highlight">You can </span>e<span class="highlight">xp</span>e<span class="highlight">rimen</span>t w<span class="highlight">i</span>t<span class="highlight">h</span> the DAL API <span class="highlight">u</span>s<span class="highlight"></span>in<span class="highlight">g</span> the web2py shell<span class="highlight"></span>.</div><div class=""> </div><div class=""> Start by creating a connection. For the sake of example, you can use SQLite. Nothing in this discussion changes when you change the back-end engine.</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db = DAL(&#x27;sqlite://storage.db&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> The database is now connected and the connection is stored in the global variable ``db``.</div><div class=""> </div><div class=""> At any time you can retrieve the connection string.</div><div class=""> ``_uri``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; print db._uri</div><div class=""> sqlite://storage.db</div><div class=""> ``:code</div><div class=""> </div><div class=""> and the database name</div><div class=""> ``_dbname``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; print db._dbname</div><div class=""> Not all of them are relevant for every field. &quot;length&quot; is relevant only for fiel</div><div class=""> ``decimal(n,m)`` | ``IS_DECIMAL_IN_RANGE(-1e100, 1e100)``</div><div class=""> ``date`` | ``IS_DATE()``</div><div class=""> ``time`` | ``IS_TIME()``</div><div class=""> ``datetime`` | ``IS_DATETIME()``</div><div class=""> ``password`` | ``None``</div><div class=""> ``upload`` | ``None``</div><div class=""> ``reference &lt;table&gt;``  | ``IS_IN_DB(db,table.field,format)``</div><div class=""> ``list:string`` | ``None``</div><div class=""> ``list:integer`` | ``None``</div><div class=""> ``list:reference &lt;table&gt;`` | ``IS_IN_DB(db,table.field,format,multiple=True)``</div><div class=""> ``json`` | ``IS_JSON()``</div><div class=""> ``bigint`` | ``None``</div><div class=""> ``big-id`` | ``None``</div><div class=""> ``big-reference`` | ``None``</div><div class=""> ---------</div><div class=""> </div><div class=""> Decimal requires and returns values as ``Decimal`` objects, as defined in the Python ``decimal`` module. SQLite does not handle the ``decimal`` type so internally we treat it as a ``double``. The (n,m) are the number of digits in total and the number of digits after the decimal point respectively.</div><div class=""> </div><div class=""> The ``big-id`` and, ``big-reference`` are only supported by some of the database engines and are experimental. They are not normally used as field types unless for legacy tables, however, the DAL constructor has a ``bigint_id`` argument that when set to ``True`` makes the ``id`` fields and ``reference`` fields ``big-id`` and ``big-reference`` respectively.</div><div class=""> </div><div class="insert">The ``list:<span class="highlight">&lt;type&gt;</span>`` fields are special because they are designed to take advantage of certain denormalization features on NoSQL (in the case of Google App Engine NoSQL, the field types ``ListProperty`` and ``StringListProperty``) and back-port them all the other supported relational databases. On relational databases lists are stored as a ``text`` field. The items are separated by a ``|`` and each ``|`` in string item is escaped as a ``||``. They are discussed in their own section.</div><div class=""> </div><div class=""> The ``json`` field type is pretty much explanatory. It can store any json serializable object. It is designed to work specifically for MongoDB and backported to the other database adapters for portability.</div><div class=""> </div><div class=""> -------</div><div class=""> Notice that ``requires=...`` is enforced at the level of forms, ``required=True`` is enforced at the level of the DAL (insert), while ``notnull``, ``unique`` and ``ondelete`` are enforced at the level of the database. While they sometimes may seem redundant, it is important to maintain the distinction when programming with the DAL.</div><div class=""> -------</div><div class=""> </div><div class=""> ``ondelete``:inxx</div><div class=""> </div><div class=""> - ``ondelete`` translates into the &quot;ON DELETE&quot; SQL statement. By default it is set to &quot;CASCADE&quot;. This tells the database that when it deletes a record, it should also delete all records that refer to it. To disable this feature, set ``ondelete`` to &quot;NO ACTION&quot; or &quot;SET NULL&quot;.</div><div class=""> - ``notnull=True`` translates into the &quot;NOT NULL&quot; SQL statement. It prevents the database from inserting null values for the field.</div><div class=""> - ``unique=True`` translates into the &quot;UNIQUE&quot; SQL statement and it makes sure that values of this field are unique within the table. It is enforced at the database level.</div><div class=""> - ``uploadfield`` applies only to fields of type &quot;upload&quot;. A field of type &quot;upload&quot; stores the name of a file saved somewhere else, by default on the filesystem under the application &quot;uploads/&quot; folder. If ``uploadfield`` is set, then the file is stored in a blob field within the same table and the value of ``uploadfield`` is the name of the blob field. This will be discussed in more detail later in the context of SQLFORM.</div><div class="insert">+- ``uploadfolder`` defaults to the application&#x27;s &quot;uploads/&quot; folder. If set to a different path, files will uploaded to a different folder. For example,</div><div class="insert">+``</div><div class="insert">+Field(...,uploadfolder=os.path.join(request.folder,&#x27;static/temp&#x27;))</div><div class="insert">+``:code</div><div class="insert">+will upload files to the &quot;web2py/applications/myapp/static/temp&quot; folder.</div><div class="insert">+- ``uploadseparate`` if set to True will upload files under different subfolders of the &#x27;&#x27;uploadfolder&#x27;&#x27; folder. This is optimized to avoid too many files under the same folder/subfolder. ATTENTION: You cannot change the value of ``uploadseparate`` from True to False without breaking links to existing uploads. web2py either uses the separate subfolders or it does not. Changing the behavior after files have been uploaded will prevent web2py from being able to retrieve those files. If this happens it is possible to move files and fix the problem but this is not described here.</div><div class="insert">+- ``uploadfs`` allows you specify a different file system where to upload files, including an Amazon S3 storage or a remote SFTP storage. This option requires PyFileSystem installed. ``uploadfs`` must point to ``PyFileSystem``. ``PyFileSystem``:inxx ``uploadfs``:idxx</div><div class=""> - ``widget`` must be one of the available widget objects, including custom widgets, for example: ``SQLFORM.widgets.string.widget``. A list of available widgets will be discussed later. Each field type has a default widget.</div><div class="insert">+- ``label`` is a string (or a helper or something that can be serialized to a string) that contains the label to be used for this field in auto-generated forms.</div><div class="insert">+- ``comment``  is a string (or a helper or something that can be serialized to a string) that contains a comment associated with this field, and will be displayed to the right of the input field in the autogenerated forms.</div><div class="insert">+- ``writable`` declares whether a field is writable in forms.</div><div class="insert">+- ``readable`` declares whether a field is readable in forms. If a field is neither readable nor writable, it will not be displayed in create and update forms.</div><div class=""> - ``update`` contains the default value for this field when the record is updated.</div><div class=""> - ``compute`` is an optional function. If a record is inserted or updated, the compute function will be executed and the field will be populated with the function result. The record is passed to the compute function as a ``dict``, and the dict will not include the current value of that, or any other compute field.</div><div class=""> - ``authorize`` can be used to require access control on the corresponding field, for &quot;upload&quot; fields only. It will be discussed more in detail in the context of Authentication and Authorization.</div><div class=""> - ``autodelete`` determines if the corresponding uploaded file should be deleted when the record referencing the file is deleted. For &quot;upload&quot; fields only.</div><div class=""> - ``represent`` can be None or can point to a function that takes a field value and returns an alternate representation for the field value. Examples:</div><div class=""> ``</div><div class=""> db.mytable.name.represent = lambda name,row: name.capitalize()</div><div class=""> db.mytable.other_id.represent = lambda id,row: row.myfield</div><div class=""> db.mytable.some_uploadfield.represent = lambda value,row: \</div><div class="">     A(&#x27;get it&#x27;, _href=URL(&#x27;download&#x27;, args=value))</div><div class=""> ``:code</div><div class=""> </div><div class=""> ``blob``:inxx</div><div class=""> &quot;blob&quot; fields are also special. By default, binary data is encoded in base64 before being stored into the actual database field, and it is decoded when extracted. This has the negative effect of using 25% more storage space than necessary in blob fields, but has two advantages. On average it reduces the amount of data communicated between web2py and the database server, and it makes the communication independent of back-end-specific escaping conventions.</div><div class=""> </div><div class=""> Most attributes of fields and tables can be modified after they are defined:</div><div class=""> </div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;,Field(&#x27;name&#x27;,default=&#x27;&#x27;),format=&#x27;%(name)s&#x27;)</div><div class=""> db.person._format = &#x27;%(name)s/%(id)s&#x27;</div><div class=""> We refer to this behavior as a &quot;migration&quot;. web2py logs all migrations and migra</div><div class=""> </div><div class=""> The first argument of ``define_table`` is always the table name. The other unnamed arguments are the fields (Field). The function also takes an optional last argument called &quot;migrate&quot; which must be referred to explicitly by name as in:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;), migrate=&#x27;person.table&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> The value of migrate is the filename (in the &quot;databases&quot; folder for the application) where web2py stores internal migration information for this table. </div><div class=""> These files are very important and should never be removed while the corresponding tables exist.  In cases where a table has been dropped and the corresponding file still exist, it can be removed manually. By default, migrate is set to True. This causes web2py to generate the filename from a hash of the connection string. If migrate is set to False, the migration is not performed, and web2py assumes that the table exists in the datastore and it contains (at least) the fields listed in ``define_table``.</div><div class=""> The best practice is to give an explicit name to the migrate table.</div><div class=""> </div><div class=""> There may not be two tables in the same application with the same migrate filename.</div><div class=""> </div><div class=""> The DAL class also takes a &quot;migrate&quot; argument, which determines the default value of migrate for calls to ``define_table``. For example,</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db = DAL(&#x27;sqlite://storage.db&#x27;, migrate=False)</div><div class=""> ``:code</div><div class=""> </div><div class=""> will set the default value of migrate to False whenever ``db.define_table`` is called without a migrate argument.</div><div class=""> </div><div class=""> ------</div><div class="insert">Notice that web2py only migrates new columns, removed columns, and changes in column type (<span class="highlight">excep</span>t in sqlite). web2py does not migrate changes in attributes such as changes in the values of ``default``, ``unique``, ``notnull``, and ``ondelete``.</div><div class=""> ------</div><div class=""> </div><div class="insert">Migrations can be disabled for all tables at <span class="highlight"></span>on<span class="highlight">c</span>e<span class="highlight"></span>:</div><div class=""> </div><div class=""> ``</div><div class=""> db = DAL(...,migrate_enabled=False)</div><div class=""> ``</div><div class=""> </div><div class=""> This is the recommended behavior when two apps share the same database. Only one of the two apps should perform migrations, the other should disabled them.</div><div class=""> </div><div class=""> ### Fixing broken migrations</div><div class=""> ``fake_migrate``:inxx</div><div class=""> </div><div class=""> There are two common problems with migrations and there are ways to recover from them.</div><div class=""> </div><div class=""> One problem is specific with SQLite. SQLite does not enforce column types and cannot drop columns. This means that if you have a column of type string and you remove it, it is not really removed. If you add the column again with a different type (for example datetime) you end up with a datetime column that contains strings (junk for practical purposes). web2py does not complain about this because it does not know what is in the database, until it tries to retrieve records and fails.</div><div class=""> </div><div class=""> If web2py returns an error in the gluon.sql.parse function when selecting records, this is the problem: corrupted data in a column because of the above issue.</div><div class=""> </div><div class=""> The solution consists in updating all records of the table and updating the values in the column in question with None.</div><div class=""> </div><div class=""> The other problem is more generic but typical with MySQL. MySQL does not allow more than one ALTER TABLE in a transaction. This means that web2py must break complex transactions into smaller ones (one ALTER TABLE at the time) and commit one piece at the time. It is therefore possible that part of a complex transaction gets committed and one part fails, leaving web2py in a corrupted state. Why would part of a transaction fail? Because, for example, it involves altering a table and converting a string column into a datetime column, web2py tries to convert the data, but the data cannot be converted. What happens to web2py? It gets confused about what exactly is the table structure actually stored in the database.</div><div class=""> </div><div class=""> The solution consists of disabling migrations for all tables and enabling fake migrations:</div><div class=""> ``</div><div class=""> db.define_table(....,migrate=False,fake_migrate=True)</div><div class=""> ``:code</div><div class=""> </div><div class=""> This will rebuild web2py metadata about the table according to the table definition. Try multiple table definitions to see which one works (the one before the failed migration and the one after the failed migration). Once successful remove the ``fake_migrate=True`` attribute.</div><div class=""> </div><div class=""> Before attempting to fix migration problems it is prudent to make a copy of &quot;applications/yourapp/databases/*.table&quot; files.</div><div class=""> </div><div class=""> Migration problems can also be fixed for all tables at once:</div><div class=""> </div><div class=""> ``</div><div class=""> db = DAL(...,fake_migrate_all=True)</div><div class=""> ``:code</div><div class=""> </div><div class="insert">+This also fails if the model describes tables that do not exist in the database,</div><div class="insert">+but it can help narrowing down the problem.</div><div class=""> </div><div class=""> ### ``insert``</div><div class=""> </div><div class=""> Given a table, you can insert records</div><div class=""> </div><div class=""> ``insert``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.person.insert(name=&quot;Alex&quot;)</div><div class=""> 1</div><div class=""> &gt;&gt;&gt; db.person.insert(name=&quot;Bob&quot;)</div><div class=""> 2</div><div class=""> ``:code</div><div class=""> </div><div class=""> Insert returns the unique &quot;id&quot; value of each record inserted.</div><div class=""> </div><div class=""> You can truncate the table, i.e., delete all records and reset the counter of the id.</div><div class=""> </div><div class=""> ``truncate``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.person.truncate()</div><div class=""> Finally, you can drop tables and all data will be lost:</div><div class=""> </div><div class=""> Currently the DAL API does not provide a command to create indexes on tables, but this can be done using the ``executesql`` command. This is because the existence of indexes can make migrations complex, and it is better to deal with them explicitly. Indexes may be needed for those fields that are used in recurrent queries.</div><div class=""> </div><div class=""> Here is an example of how to [[create an index using SQL in SQLite http://www.sqlite.org/lang_createindex.html]]:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db = DAL(&#x27;sqlite://storage.db&#x27;)</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;))</div><div class=""> &gt;&gt;&gt; db.executesql(&#x27;CREATE INDEX IF NOT EXISTS myidx ON person (name);&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> Other database dialects have very similar syntaxes but may not support the optional &quot;IF NOT EXISTS&quot; directive.</div><div class=""> </div><div class=""> ### Legacy databases and keyed tables</div><div class=""> </div><div class=""> web2py can connect to legacy databases under some conditions.</div><div class=""> </div><div class=""> The easiest way is when these conditions are met:</div><div class=""> - Each table must have a unique auto-increment integer field called &quot;id&quot;</div><div class=""> - Records must be referenced exclusively using the &quot;id&quot; field.</div><div class=""> </div><div class=""> When accessing an existing table, i.e., a table not created by web2py in the current application, always set ``migrate=False``.</div><div class=""> </div><div class=""> If the legacy table has an auto-increment integer field but it is not called &quot;id&quot;, web2py can still access it but the table definition must contain explicitly as ``Field(&#x27;....&#x27;,&#x27;id&#x27;)`` where ... is the name of the auto-increment integer field.</div><div class=""> </div><div class=""> ``keyed table``:inxx</div><div class=""> </div><div class=""> Finally if the legacy table uses a primary key that is not an auto-increment id field it is possible to use a &quot;keyed table&quot;, for example:</div><div class=""> ``</div><div class=""> db.define_table(&#x27;account&#x27;,</div><div class="">     Field(&#x27;accnum&#x27;,&#x27;integer&#x27;),</div><div class="">     Field(&#x27;acctype&#x27;),</div><div class="">     Field(&#x27;accdesc&#x27;),</div><div class="">     primarykey=[&#x27;accnum&#x27;,&#x27;acctype&#x27;],</div><div class="">     migrate=False)</div><div class=""> ``:code</div><div class=""> </div><div class=""> - ``primarykey`` is a list of the field names that make up the primary key.</div><div class=""> - All primarykey fields have a ``NOT NULL`` set even if not specified.</div><div class=""> - Keyed tables can only reference other keyed tables.</div><div class=""> - Referencing fields must use the ``reference tablename.fieldname`` format.</div><div class=""> - The ``update_record`` function is not available for Rows of keyed tables.</div><div class=""> </div><div class=""> -------</div><div class="insert"><span class="highlight">C</span>urrently <span class="highlight">keyed </span>t<span class="highlight">able</span>s <span class="highlight">are</span> only <span class="highlight">support</span>e<span class="highlight">d</span> for DB2, MS-SQL, Ingres and Informix, but others <span class="highlight">e</span>n<span class="highlight">gines will</span> be<span class="highlight"></span> added.</div><div class=""> -------</div><div class=""> </div><div class=""> At the time of writing, we cannot guarantee that the ``primarykey`` attribute works with every existing legacy table and every supported database backend.</div><div class=""> For simplicity, we recommend, if possible, creating a database view that has an auto-increment id field.</div><div class=""> </div><div class=""> </div><div class=""> ### Distributed transaction</div><div class=""> ``distributed transactions``:inxx</div><div class=""> </div><div class=""> ------</div><div class=""> At the time of writing this feature is only supported</div><div class=""> by PostgreSQL, MySQL and Firebird, since they expose API for two-phase commits.</div><div class=""> ------</div><div class=""> </div><div class=""> Assuming you have two (or more) connections to distinct PostgreSQL databases, for example:</div><div class=""> ``</div><div class=""> db_a = DAL(&#x27;postgres://...&#x27;)</div><div class=""> db_b = DAL(&#x27;postgres://...&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> Alex</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can have the fetched records appear in random order:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db().select(</div><div class="">         db.person.ALL, orderby=&#x27;&lt;random&gt;&#x27;):</div><div class="">         print row.name</div><div class=""> Carl</div><div class=""> Alex</div><div class=""> Bob</div><div class=""> ``:code</div><div class=""> </div><div class=""> -----</div><div class=""> The use of ``orderby=&#x27;&lt;random&gt;&#x27;`` is not supported on Google NoSQL.  However, in this situation and likewise in many others where built-ins are insufficient, imports can be used:</div><div class=""> ``</div><div class=""> import random</div><div class=""> rows=db(...).select().sort(lambda row: random.random())</div><div class=""> ``:code</div><div class=""> -----</div><div class=""> </div><div class="insert"><span class="highlight">Y</span>ou can sort the records according to multiple fields by concatenating them with a &quot;|&quot;:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db().select(</div><div class="">         db.person.ALL, orderby=db.person.name|db.person.id):</div><div class="">         print row.name</div><div class=""> Carl</div><div class=""> Bob</div><div class=""> Alex</div><div class=""> ``:code</div><div class=""> </div><div class=""> Using ``groupby`` together with ``orderby``, you can group records with the same value for the specified field (this is back-end specific, and is not on the Google NoSQL):</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db().select(</div><div class="">         db.person.ALL,</div><div class="">         orderby=db.person.name, groupby=db.person.name):</div><div class="">         print row.name</div><div class=""> Alex</div><div class=""> Bob</div><div class=""> Carl</div><div class=""> ``:code</div><div class=""> </div><div class=""> web2py also allows updating a single record that is already in memory using ``up</div><div class=""> because for a single row, the method ``update`` updates the row object but not the database record, as in the case of ``update_record``.</div><div class=""> </div><div class=""> It is also possible to change the attributes of a row (one at a time) and then call ``update_record()`` without arguments to save the changes:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; row = db(db.person.id &gt; 2).select().first()</div><div class=""> &gt;&gt;&gt; row.name = &#x27;Curt&#x27;</div><div class=""> &gt;&gt;&gt; row.update_record() # saves above change</div><div class=""> ``:code</div><div class=""> </div><div class=""> The ``update_record`` method is available only if the table&#x27;s ``id`` field is included in the select, and ``cacheable`` is not set to ``True``.</div><div class=""> </div><div class=""> #### Inserting and updating from a dictionary</div><div class=""> </div><div class=""> A common issue consists of needing to insert or update records in a table where the name of the table, the field to be updated, and the value for the field are all stored in variables. For example: ``tablename``, ``fieldname``, and ``value``.</div><div class=""> </div><div class=""> The insert can be done using the following syntax:</div><div class=""> </div><div class=""> ``</div><div class=""> db[tablename].insert(**{fieldname:value})</div><div class="insert">``:<span class="highlight">code</span></div><div class=""> </div><div class=""> The update of record with given id can be done with: ``_id``:inxx</div><div class=""> </div><div class=""> ``</div><div class=""> db(db[tablename]._id==id).update(**{fieldname:value})</div><div class=""> ``:code</div><div class=""> </div><div class=""> Notice we used ``table._id`` instead of ``table.id``. In this way the query works even for tables with a field of type &quot;id&quot; which has a name other than &quot;id&quot;.</div><div class=""> </div><div class=""> </div><div class=""> #### ``first`` and ``last``</div><div class=""> ``first``:inxx ``last``:inxx</div><div class=""> </div><div class=""> Given a Rows object containing records:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows = db(query).select()</div><div class=""> &gt;&gt;&gt; first_row = rows.first()</div><div class=""> &gt;&gt;&gt; last_row = rows.last()</div><div class=""> ``:code</div><div class=""> name</div><div class=""> Max</div><div class=""> Tim</div><div class=""> John</div><div class=""> Tim</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can do a union of the records removing duplicates:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows3 = rows1 | rows2</div><div class=""> &gt;&gt;&gt; print rows3</div><div class=""> name</div><div class=""> Max</div><div class=""> Tim</div><div class=""> John</div><div class=""> ``:code</div><div class=""> </div><div class=""> #### ``find``, ``exclude``, ``sort``</div><div class=""> ``find``:inxx ``exclude``:inxx ``sort``:inxx</div><div class=""> </div><div class="insert"><span class="highlight">So</span>me<span class="highlight"> times you</span> to perform two selects and one contains a subset of a previous select. In this case it is pointless to access the database again. The ``find``, ``exclude`` and ``sort`` objects allow you to manipulate a Rows objects and generate another one without accessing the database. More specifically:</div><div class=""> - ``find`` returns a new set of Rows filtered by a condition and leaves the original unchanged.</div><div class=""> - ``exclude`` returns a new set of Rows filtered by a condition and removes them from the original Rows.</div><div class=""> - ``sort`` returns a new set of Rows sorted by a condition and leaves the original unchanged.</div><div class=""> </div><div class=""> All these methods take a single argument, a function that acts on each individual row.</div><div class=""> </div><div class=""> Here is an example of usage:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;,Field(&#x27;name&#x27;))</div><div class=""> &gt;&gt;&gt; db.person.insert(name=&#x27;John&#x27;)</div><div class=""> &gt;&gt;&gt; db.person.insert(name=&#x27;Max&#x27;)</div><div class=""> &gt;&gt;&gt; db.person.insert(name=&#x27;Alex&#x27;)</div><div class=""> &gt;&gt;&gt; rows = db(db.person).select()</div><div class=""> &gt;&gt;&gt; for row in rows.find(lambda row: row.name[0]==&#x27;M&#x27;):</div><div class="">         print row.name</div><div class=""> Max</div><div class=""> &gt;&gt;&gt; print len(rows)</div><div class=""> 3</div><div class=""> &gt;&gt;&gt; for row in rows.exclude(lambda row: row.name[0]==&#x27;M&#x27;):</div><div class="">         print row.name</div><div class=""> Here is ``_delete`` ``_delete``:inxx</div><div class=""> DELETE FROM person WHERE person.name=&#x27;Alex&#x27;;</div><div class=""> ``:code</div><div class=""> </div><div class=""> And finally, here is ``_update`` ``_update``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; print db(db.person.name==&#x27;Alex&#x27;)._update()</div><div class=""> UPDATE person SET  WHERE person.name=&#x27;Alex&#x27;;</div><div class=""> ``:code</div><div class=""> </div><div class=""> -----</div><div class=""> Moreover you can always use ``db._lastsql`` to return the most recent</div><div class=""> SQL code, whether it was executed manually using executesql or was SQL</div><div class=""> generated by the DAL.</div><div class=""> -----</div><div class=""> </div><div class=""> ### Exporting and importing data</div><div class=""> ``export``:inxx ``import``:inxx</div><div class=""> </div><div class=""> #### CSV (one Table at a time)</div><div class=""> </div><div class="insert">When a <span class="highlight"></span>Rows object is converted to a string it is automatically</div><div class=""> serialized in CSV:</div><div class=""> </div><div class=""> ``csv``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows = db(db.person.id==db.thing.owner).select()</div><div class=""> &gt;&gt;&gt; print rows</div><div class=""> person.id,person.name,thing.id,thing.name,thing.owner</div><div class=""> 1,Alex,1,Boat,1</div><div class=""> 1,Alex,2,Chair,1</div><div class=""> 2,Bob,3,Shoes,2</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can serialize a single table in CSV and store it in a file &quot;test.csv&quot;:</div><div class=""> ``</div><div class="insert">&gt;&gt;&gt; open(&#x27;test.csv&#x27;, &#x27;w<span class="highlight">b</span>&#x27;).write(str(db(db.person.id).select()))</div><div class=""> ``:code</div><div class=""> </div><div class=""> This is equivalent to</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows = db(db.person.id).select()</div><div class="insert">&gt;&gt;&gt; rows.export_to_csv_file(open(&#x27;test.csv&#x27;, &#x27;w<span class="highlight">b</span>&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can read the CSV file back with:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.person.import_from_csv_file(open(&#x27;test.csv&#x27;, &#x27;r&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class=""> When importing, web2py looks for the field names in the CSV header. In this example, it finds two columns: &quot;person.id&quot; and &quot;person.name&quot;. It ignores the &quot;person.&quot; prefix, and it ignores the &quot;id&quot; fields. Then all records are appended and assigned new ids. Both of these operations can be performed via the appadmin web interface.</div><div class=""> </div><div class=""> #### CSV (all tables at once)</div><div class=""> </div><div class=""> In web2py, you can backup/restore an entire database with two commands:</div><div class=""> </div><div class=""> To export:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.export_to_csv_file(open(&#x27;somefile.csv&#x27;, &#x27;wb&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class=""> To import:</div><div class=""> ``</div><div class=""> db.define_table(&#x27;thing&#x27;,</div><div class="">     format=&#x27;%(name)s&#x27;)</div><div class=""> </div><div class=""> if not db(db.person).count():</div><div class="">     id = db.person.insert(name=&quot;Massimo&quot;)</div><div class="">     db.thing.insert(owner=id, name=&quot;Chair&quot;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> Each record is identified by an ID and referenced by that ID. If you</div><div class=""> have two copies of the database used by distinct web2py installations,</div><div class=""> the ID is unique only within each database and not across the databases.</div><div class=""> This is a problem when merging records from different databases.</div><div class=""> </div><div class=""> In order to make a record uniquely identifiable across databases, they</div><div class=""> must:</div><div class=""> - have a unique id (UUID),</div><div class=""> - have an event_time (to figure out which one is more recent if multiple copies),</div><div class=""> - reference the UUID instead of the id.</div><div class=""> </div><div class=""> This can be achieved without modifying web2py. Here is what to do:</div><div class=""> </div><div class="insert"><span class="highlight"></span>Change the above model into:</div><div class=""> </div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;,</div><div class="">     Field(&#x27;uuid&#x27;, length=64, default=lambda:str(uuid.uuid4())),</div><div class="">     Field(&#x27;modified_on&#x27;, &#x27;datetime&#x27;, default=now),</div><div class="">     Field(&#x27;name&#x27;),</div><div class="">     format=&#x27;%(name)s&#x27;)</div><div class=""> </div><div class=""> db.define_table(&#x27;thing&#x27;,</div><div class="">     Field(&#x27;uuid&#x27;, length=64, default=lambda:str(uuid.uuid4())),</div><div class="">     Field(&#x27;modified_on&#x27;, &#x27;datetime&#x27;, default=now),</div><div class="">     Field(&#x27;owner&#x27;, length=64),</div><div class="">     Field(&#x27;name&#x27;),</div><div class="">     format=&#x27;%(name)s&#x27;)</div><div class=""> </div><div class=""> db.thing.owner.requires = IS_IN_DB(db,&#x27;person.uuid&#x27;,&#x27;%(name)s&#x27;)</div><div class=""> </div><div class=""> if not db(db.person.id).count():</div><div class="">     id = uuid.uuid4()</div><div class="">     db.person.insert(name=&quot;Massimo&quot;, uuid=id)</div><div class="">     db.thing.insert(owner=id, name=&quot;Chair&quot;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> -------</div><div class="insert">Not<span class="highlight">ice that in the above table definitions</span>, <span class="highlight">the default </span>v<span class="highlight"></span>alue for the two <span class="highlight">``uuid``</span> fields is set to a lambda function, which returns a UUID (converted to a string). The lambda function is called once for each record inserted, ensuring that each record gets a unique UUID, even if multiple records are inserted in a single transaction.</div><div class=""> -------</div><div class=""> </div><div class="insert"><span class="highlight"></span>Create a controller action to export the database:</div><div class=""> </div><div class=""> ``</div><div class=""> def export():</div><div class="">     s = StringIO.StringIO()</div><div class="">     db.export_to_csv_file(s)</div><div class="">     response.headers[&#x27;Content-Type&#x27;] = &#x27;text/csv&#x27;</div><div class="">     return s.getvalue()</div><div class=""> ``:code</div><div class=""> </div><div class="insert"><span class="highlight"></span>Create a controller action to import a saved copy of the other database and sync records:</div><div class=""> </div><div class=""> ``</div><div class=""> def import_and_sync():</div><div class="">     form = FORM(INPUT(_type=&#x27;file&#x27;, _name=&#x27;data&#x27;), INPUT(_type=&#x27;submit&#x27;))</div><div class="insert">    if form.process(<span class="highlight"></span>).accepted:</div><div class="">         db.import_from_csv_file(form.vars.data.file,unique=False)</div><div class="">         # for every table</div><div class="">         for table in db.tables:</div><div class="">             # for every uuid, delete all but the latest</div><div class="">             items = db(db[table]).select(db[table].id,</div><div class="">                        db[table].uuid,</div><div class="">                        orderby=db[table].modified_on,</div><div class="">                        groupby=db[table].uuid)</div><div class="">             for item in items:</div><div class="">                 db((db[table].uuid==item.uuid)&amp;\</div><div class="">                    (db[table].id!=item.id)).delete()</div><div class="">     return dict(form=form)</div><div class=""> ``:code</div><div class=""> </div><div class="insert"><span class="highlight">Optionally</span> <span class="highlight">you should c</span>reate an index manually to make the search by uuid faster.</div><div class=""> </div><div class=""> </div><div class=""> ``XML-RPC``:inxx</div><div class=""> Alternatively, you can use XML-RPC to export/import the file.</div><div class=""> </div><div class=""> If the records reference uploaded files, you also need to export/import the content of the uploads folder. Notice that files therein are already labeled by UUIDs so you do not need to worry about naming conflicts and references.</div><div class=""> </div><div class=""> #### HTML and XML (one Table at a time)</div><div class=""> </div><div class="insert">+``Rows objects``:inxx</div><div class="insert">+Rows objects also have an ``xml`` method (like helpers) that serializes it to XML/HTML:</div><div class=""> </div><div class=""> ``HTML``:inxx</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows = db(db.person.id &gt; 0).select()</div><div class=""> &gt;&gt;&gt; print rows.xml()</div><div class=""> &lt;table&gt;</div><div class="">   &lt;thead&gt;</div><div class="">     &lt;tr&gt;</div><div class="">       &lt;th&gt;person.id&lt;/th&gt;</div><div class="">       &lt;th&gt;person.name&lt;/th&gt;</div><div class="">       &lt;th&gt;thing.id&lt;/th&gt;</div><div class="">       &lt;th&gt;thing.name&lt;/th&gt;</div><div class="">       &lt;th&gt;thing.owner&lt;/th&gt;</div><div class="">     &lt;/tr&gt;</div><div class="">   &lt;/thead&gt;</div><div class="">   &lt;tbody&gt;</div><div class="">     &lt;tr class=&quot;even&quot;&gt;</div><div class="">       &lt;td&gt;1&lt;/td&gt;</div><div class="">       &lt;td&gt;Alex&lt;/td&gt;</div><div class="">       &lt;td&gt;1&lt;/td&gt;</div><div class="">       &lt;td&gt;Boat&lt;/td&gt;</div><div class="">       &lt;td&gt;1&lt;/td&gt;</div><div class="">     &lt;/tr&gt;</div><div class="">     ...</div><div class="">   &lt;/tbody&gt;</div><div class=""> &lt;/table&gt;</div><div class=""> ``:code</div><div class=""> </div><div class="insert">+``Rows custom tags``:inxx</div><div class="insert">+If you need to serialize the Rows in any other XML format with custom tags, you can easily do that using the universal TAG helper and the * notation:</div><div class=""> ``XML``:inxx</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows = db(db.person.id &gt; 0).select()</div><div class=""> &gt;&gt;&gt; print TAG.result(*[TAG.row(*[TAG.field(r[f], _name=f) \</div><div class="">           for f in db.person.fields]) for r in rows])</div><div class=""> &lt;result&gt;</div><div class="">   &lt;row&gt;</div><div class="">     &lt;field name=&quot;id&quot;&gt;1&lt;/field&gt;</div><div class="">     &lt;field name=&quot;name&quot;&gt;Alex&lt;/field&gt;</div><div class="">   &lt;/row&gt;</div><div class="">   ...</div><div class=""> &lt;/result&gt;</div><div class=""> ``:code</div><div class=""> </div><div class=""> #### Data representation</div><div class=""> </div><div class=""> ``export_to_csv_file``:inxx</div><div class=""> The ``export_to_csv_file`` function accepts a keyword argument named ``represent``. When ``True`` it will use the columns ``represent`` function while exporting the data instead of the raw data.</div><div class=""> </div><div class=""> The select method also takes a cache argument, which defaults to None. For cachi</div><div class=""> </div><div class=""> In the following example, you see a controller that caches a select on the previously defined db.log table. The actual select fetches data from the back-end database no more frequently than once every 60 seconds and stores the result in cache.ram. If the next call to this controller occurs in less than 60 seconds since the last database IO, it simply fetches the previous data from cache.ram.</div><div class=""> </div><div class=""> ``cache select``:inxx</div><div class=""> ``</div><div class=""> def cache_db_select():</div><div class="">     logs = db().select(db.log.ALL, cache=(cache.ram, 60))</div><div class="">     return dict(logs=logs)</div><div class=""> ``:code</div><div class=""> </div><div class=""> ``cacheable``:inxx</div><div class=""> </div><div class=""> The ``select`` method has an optional ``cacheable`` argument, normally set to ``False``. When ``cacheable=True`` the resulting ``Rows`` is serializable but The ``Row``s lack ``update_record`` and ``delete_record`` methods.</div><div class=""> </div><div class=""> If you do not need these methods you can speed up selects a lot by setting the cacheable attribute:</div><div class=""> </div><div class=""> ``</div><div class=""> rows = db(query).select(cacheable=True)</div><div class=""> ``:code</div><div class=""> </div><div class=""> When the ``cache`` argument is set but ``cacheable=False`` (default) only the database results are cached, not the actual Rows object. When the ``cache`` argument is used in conjunction with ``cacheable=True`` the entire Rows object is cached and this results in much faster caching:</div><div class=""> </div><div class=""> ``</div><div class=""> rows = db(query).select(cache=(cache.ram,3600),cacheable=True)</div><div class=""> ``:code</div><div class=""> </div><div class=""> ### Self-Reference and aliases</div><div class=""> </div><div class=""> ``self reference``:inxx</div><div class=""> ``alias``:inxx</div><div class=""> It is possible to define tables with fields that refer to themselves, here is an example:</div><div class=""> ``reference table``:inxx</div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;,</div><div class="">     Field(&#x27;name&#x27;),</div><div class="">     Field(&#x27;father_id&#x27;, &#x27;reference person&#x27;),</div><div class="">     Field(&#x27;mother_id&#x27;, &#x27;reference person&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class=""> Notice that the alternative notation of using a table object as field type will fail in this case, because it uses a variable ``db.person`` before it is defined:</div><div class=""> Here ``f`` is a dict of fields passed to insert or update, ``id`` is the id of t</div><div class=""> &gt;&gt;&gt; db(db.person.id==1).update(name=&#x27;Tim&#x27;)</div><div class=""> (&lt;Set (person.id = 1)&gt;, {&#x27;name&#x27;: &#x27;Tim&#x27;})</div><div class=""> (&lt;Set (person.id = 1)&gt;, {&#x27;name&#x27;: &#x27;Tim&#x27;})</div><div class=""> &gt;&gt;&gt; db(db.person.id==1).delete()</div><div class=""> (&lt;Set (person.id = 1)&gt;,)</div><div class=""> (&lt;Set (person.id = 1)&gt;,)</div><div class=""> ``:code</div><div class=""> </div><div class=""> The return values of these callback should be ``None`` or ``False``. If any of the ``_before_*`` callback returns a ``True`` value it will abort the actual insert/update/delete operation.</div><div class=""> </div><div class=""> ``update_naive``:inxx.</div><div class=""> </div><div class=""> Some times a callback may need to perform an update in the same of a different table and one wants to avoid callbacks calling themselves recursively.</div><div class=""> </div><div class=""> For this purpose there the Set objects have an ``update_naive`` method that works like ``update`` but ignores before and after callbacks.</div><div class=""> </div><div class=""> #### Record versioning</div><div class=""> </div><div class=""> ``_enable_record_versioning``:inxx</div><div class=""> </div><div class="insert">It is possible to ask web2py to save every copy of a record when the record is<span class="highlight"> individually</span> modified. There are different ways to do it and it can be done for all tables at once using the syntax:</div><div class=""> </div><div class=""> ``</div><div class=""> auth.enable_record_versioning(db)</div><div class=""> ``:code</div><div class=""> </div><div class=""> this requires Auth and it is discussed in the chapter about authentication.</div><div class=""> It can also be done for each individual table as discussed below.</div><div class=""> </div><div class=""> Consider the following table:</div><div class=""> </div><div class=""> ``</div><div class=""> db.define_table(&#x27;stored_item&#x27;,</div><div class="">     Field(&#x27;name&#x27;),</div><div class="">     Field(&#x27;quantity&#x27;,&#x27;integer&#x27;),</div><div class="">     Field(&#x27;is_active&#x27;,&#x27;boolean&#x27;,</div><div class="">           writable=False,readable=False,default=True))</div><div class=""> ``:code</div><div class=""> </div><div class=""> Notice the hidden boolean field called ``is_active`` and defaulting to</div><div class=""> True.</div><div class=""> Any select, delete or update in this table, will include only public blog posts.</div><div class=""> </div><div class=""> ``</div><div class=""> db.blog_post._common_filter = lambda query: db.blog_post.is_public == True</div><div class=""> ``</div><div class=""> </div><div class=""> It serves both as a way to avoid repeating the &quot;db.blog_post.is_public==True&quot; phrase in each blog post search, and also as a security enhancement, that prevents you from forgetting to disallow viewing of none public posts.</div><div class=""> </div><div class=""> In case you actually do want items left out by the common filter (for example, allowing the admin to see none public posts), you can either remove the filter:</div><div class=""> ``</div><div class=""> db.blog_post._common_filter = None</div><div class=""> ``</div><div class=""> or ignore it:</div><div class=""> ``</div><div class=""> db(query, ignore_common_filters=True).select(...)</div><div class=""> ``</div><div class=""> </div><div class=""> #### Custom ``Field`` types (experimental)</div><div class=""> </div><div class=""> ``SQLCustomType``:inxx</div><div class=""> </div><div class="insert">+Aside for using ``filter_in`` and ``filter_out``, it is possible to define new/custom field types.</div><div class="insert">+For example we consider here the example if a field that contains binary data in compressed form:</div><div class=""> </div><div class=""> ``</div><div class=""> from gluon.dal import SQLCustomType</div><div class=""> import zlib</div><div class=""> </div><div class=""> compressed = SQLCustomType(</div><div class="">      type =&#x27;text&#x27;,</div><div class="">      native=&#x27;text&#x27;,</div><div class="">      encoder =(lambda x: zlib.compress(x or &#x27;&#x27;)),</div><div class="">      decoder = (lambda x: zlib.decompress(x))</div><div class=""> )</div><div class=""> </div><div class=""> db.define_table(&#x27;example&#x27;, Field(&#x27;data&#x27;,type=compressed))</div><div class=""> ``:code</div><div class=""> </div><div class=""> ``SQLCustomType`` is a field type factory. Its ``type`` argument must be one of the standard web2py types. It tells web2py how to treat the field values at the web2py level. ``native`` is the name of the field as far as the database is concerned. Allowed names depend on the database engine. ``encoder`` is an optional transformation function applied when the data is stored and ``decoder`` is the optional reversed transformation function.</div><div class=""> </div><div class=""> This feature is marked as experimental. In practice it has been in web2py for a long time and it works but it can make the code not portable, for example when the native type is database specific. It does not work on Google App Engine NoSQL.</div><div class=""> </div><div class=""> #### Using DAL without define tables</div><div class=""> To access the data and its attributes we still have to define all the tables we</div><div class=""> </div><div class=""> If we just need access to the data but not to the web2py table attributes, we get away without re-defining the tables but simply asking web2py to read the necessary info from the metadata in the .table files:</div><div class=""> </div><div class=""> ``</div><div class=""> from gluon import DAL, Field</div><div class=""> db = DAL(&#x27;sqlite://storage.sqlite&#x27;,folder=&#x27;path/to/app/databases&#x27;,</div><div class="">          auto_import=True))</div><div class=""> ``:code</div><div class=""> </div><div class=""> This allows us to access any ``db.table`` without need to re-define it.</div><div class=""> </div><div class=""> #### PostGIS, SpatiaLite, and MS Geo (experimental)</div><div class=""> </div><div class=""> ``PostGIS``:inxx ``StatiaLite``:inxx ``Geo Extensions``:inxx</div><div class=""> ``geometry``:inxx ``geoPoint``:inxx ``geoLine``:inxx ``geoPolygon``:inxx</div><div class=""> </div><div class=""> The DAL supports geographical APIs using PostGIS (for PostgreSQL), spatialite (for SQLite), and MSSQL and Spatial Extensions. This is a feature that was sponsored by the Sahana project and implemented by Denes Lengyel.</div><div class=""> </div><div class=""> DAL provides geometry and geography fields types and the following functions:</div><div class=""> </div><div class="insert">``st_asgeojson``:inxx ``st_astext``:inxx ``st_contain<span class="highlight"></span>s``:inxx</div><div class=""> ``st_distance``:inxx ``st_equals``:inxx ``st_intersects``:inxx ``st_overlaps``:inxx</div><div class=""> ``st_simplify``:inxx ``st_touches``:inxx ``st_within``:inxx</div><div class=""> </div><div class=""> ``</div><div class=""> st_asgeojson (PostGIS only)</div><div class=""> st_astext</div><div class=""> st_contains</div><div class=""> st_distance</div><div class=""> st_equals</div><div class=""> st_intersects</div><div class=""> st_overlaps</div><div class=""> st_simplify (PostGIS only)</div><div class=""> st_touches</div><div class=""> st_within</div><div class=""> st_x</div><div class=""> st_y</div><div class=""> ``</div><div class=""> </div><div class=""> Here are some examples:</div><div class=""> </div><div class=""> calls</div><div class=""> </div><div class=""> ``</div><div class=""> Table.insert(myfield=&#x27;myvalue&#x27;)</div><div class=""> ``</div><div class=""> </div><div class=""> which delegates the adapter by returning:</div><div class=""> </div><div class=""> ``</div><div class=""> db._adapter.insert(db.mytable,db.mytable._listify(dict(myfield=&#x27;myvalue&#x27;)))</div><div class=""> ``</div><div class=""> </div><div class=""> Here ``db.mytable._listify`` converts the dict of arguments into a list of ``(field,value)`` and calls the ``insert`` method of the ``adapter``. ``db._adapter`` does more or less the following:</div><div class=""> </div><div class=""> ``</div><div class=""> query = db._adapter._insert(db.mytable,list_of_fields)</div><div class=""> db._adapter.execute(query)</div><div class=""> ``</div><div class=""> </div><div class=""> where the first line builds the query and the second executes it.</div><div class=""> </div><div class="insert">``BaseAdapter`` define<span class="highlight">s</span> the interface for all adapters.</div><div class=""> </div><div class=""> &quot;gluon/dal.py&quot; at the moment of writing this book, contains the following adapters:</div><div class=""> </div><div class=""> ``</div><div class=""> SQLiteAdapter extends BaseAdapter</div><div class=""> JDBCSQLiteAdapter extends SQLiteAdapter</div><div class=""> MySQLAdapter extends BaseAdapter</div><div class=""> PostgreSQLAdapter extends BaseAdapter</div><div class=""> JDBCPostgreSQLAdapter extends PostgreSQLAdapter</div><div class=""> OracleAdapter extends BaseAdapter</div><div class=""> MSSQLAdapter extends BaseAdapter</div><div class=""> MSSQL2Adapter extends MSSQLAdapter</div><div class=""> FireBirdAdapter extends BaseAdapter</div><div class=""> FireBirdEmbeddedAdapter extends FireBirdAdapter</div><div class=""> InformixAdapter extends BaseAdapter</div><div class=""> DB2Adapter extends BaseAdapter</div><div class=""> IngresAdapter extends BaseAdapter</div><div class=""> IngresUnicodeAdapter extends IngresAdapter</div><div class=""> GoogleSQLAdapter extends MySQLAdapter</div><div class=""> NoSQLAdapter extends BaseAdapter</div><div class=""> class MySQLAdapter(BaseAdapter):</div><div class="">                 credential_decoder=lambda x:x, driver_args={},</div><div class="">                 adapter_args={}):</div><div class="">         # parse uri string and store parameters in driver_args</div><div class="">         ...</div><div class="">         # define a connection function</div><div class="">         def connect(driver_args=driver_args):</div><div class="">             return self.driver.connect(**driver_args)</div><div class="">         # place it in the pool</div><div class="">         self.pool_connection(connect)</div><div class="">         # set optional parameters (after connection)</div><div class="">         self.execute(&#x27;SET FOREIGN_KEY_CHECKS=1;&#x27;)</div><div class="">         self.execute(&quot;SET sql_mode=&#x27;NO_BACKSLASH_ESCAPES&#x27;;&quot;)</div><div class=""> </div><div class="">    # override BaseAdapter methods as needed</div><div class="">    def lastrowid(self,table):</div><div class="">         self.execute(&#x27;select last_insert_id();&#x27;)</div><div class="">         return int(self.cursor.fetchone()[0])</div><div class=""> </div><div class=""> ``:code</div><div class=""> </div><div class="insert">Looking at the various adapters as example<span class="highlight"></span> should be easy to write new ones.</div></div></div>
    <div class="span6"><div class="diff"><div class="delete">web2py comes with a Database Abstraction Layer (DAL), an API that maps Python objects into database objects such as queries, tables, and records. The DAL dynamically generates the SQL in real time using the specified dialect for the database back end, so that you do not have to write SQL code or learn different SQL dialects (the term SQL is used generically), and the application will be portable among different types of databases. A<span class="highlight">t the time of this writing, the</span> supported databases <span class="highlight">are SQLite (which comes with Python and thus web2py), PostgreSQL, MySQL, Oracle, MSSQL, FireBird, DB2, Informix, Ingres, MongoDB, and the Google App Engine (SQL and NoSQL). Experimentally we support more databases</span>. Please check on the web2py web site and mailing list for more recent adapters. Google NoSQL is treated as a particular case in Chapter 13.</div><div class=""> </div><div class=""> The Windows binary distribution works out of the box with SQLite and MySQL. The Mac binary distribution works out of the box with SQLite.</div><div class=""> To use any other database back-end, run from the source distribution and install the appropriate driver for the required back end.</div><div class=""> ``database drivers``:inxx</div><div class=""> </div><div class=""> Once the proper driver is installed, start web2py from source, and it will find the driver. Here is a list of drivers:</div><div class=""> </div><div class=""> ``DAL``:inxx ``SQLite``:inxx ``MySQL``:inxx ``PostgresSQL``:inxx ``Oracle``:inxx ``MSSQL``:inxx ``FireBird``:inxx ``DB2``:inxx ``Informix``:inxx ``Sybase``:inxx ``Teradata``:inxx ``MongoDB``:inxx ``CouchDB``:inxx ``SAPDB``:inxx ``Cubrid``:inxx</div><div class=""> </div><div class=""> ----------</div><div class=""> database | drivers (source)</div><div class=""> SQLite | sqlite3 or pysqlite2 or zxJDBC ``zxjdbc``:cite  (on Jython)</div><div class=""> PostgreSQL | psycopg2 ``psycopg2``:cite  or pg8000 ``pg8000``:cite or zxJDBC ``zxjdbc``:cite  (on Jython)</div><div class=""> MySQL | pymysql ``pymysql``:cite or MySQLdb ``mysqldb``:cite</div><div class=""> Oracle | cx_Oracle ``cxoracle``:cite</div><div class=""> MSSQL | pyodbc ``pyodbc``:cite</div><div class=""> FireBird | kinterbasdb ``kinterbasdb``:cite or fdb or pyodbc</div><div class=""> DB2 | pyodbc ``pyodbc``:cite</div><div class=""> Informix | informixdb ``informixdb``:cite</div><div class=""> Ingres | ingresdbi ``ingresdbi``:cite</div><div class=""> Cubrid | cubriddb ``cubridb``:cite ``cubridb``:cite</div><div class=""> Sybase | Sybase ``Sybase``:cite</div><div class=""> Teradata | pyodbc ``Teradata``:cite</div><div class=""> SAPDB    | sapdb ``SAPDB``:cite</div><div class=""> MongoDB | pymongo ``pymongo``:cite</div><div class=""> IMAP | imaplib ``IMAP``:cite</div><div class=""> ---------</div><div class=""> </div><div class=""> ``sqlite3``, ``pymysql``, ``pg8000``, and ``imaplib`` ship with web2py. Support of MongoDB is experimental. The IMAP option allows to use DAL to access IMAP.</div><div class=""> </div><div class=""> web2py defines the following classes that make up the DAL:</div><div class=""> </div><div class="delete"><span class="highlight"></span>**DAL**<span class="highlight"></span> represents a database connection. For example:</div><div class=""> ``sqlite``:inxx</div><div class=""> ``</div><div class=""> db = DAL(&#x27;sqlite://storage.db&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> ``define_table``:inxx</div><div class=""> **Table** represents a database table.  You do not directly instantiate Table; instead, ``DAL.define_table`` instantiates it.</div><div class=""> ``</div><div class=""> db.define_table(&#x27;mytable&#x27;, Field(&#x27;myfield&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class=""> The most important methods of a Table are:</div><div class=""> ``insert``:inxx</div><div class=""> ``truncate``:inxx</div><div class=""> ``drop``:inxx</div><div class=""> ``import_from_csv_file``:inxx</div><div class=""> ``count``:inxx</div><div class=""> ``.insert``, ``.truncate``, ``.drop``, and ``.import_from_csv_file``.</div><div class=""> </div><div class=""> ``Field``:inxx</div><div class=""> Some times you may need to generate SQL as if you had a connection but without a</div><div class=""> </div><div class=""> ``</div><div class=""> db = DAL(&#x27;...&#x27;, do_connect=False)</div><div class=""> ``:code</div><div class=""> </div><div class=""> In this case you will be able to call ``_select``, ``_insert``, ``_update``, and ``_delete`` to generate SQL but not call ``select``, ``insert``, ``update``, and ``delete``. In most of the cases you can use ``do_connect=False`` even without having the required database drivers.</div><div class=""> </div><div class=""> Notice that by default web2py uses utf8 character encoding for databases. If you work with existing databases that behave differently, you have to change it with the optional parameter ``db_codec`` like</div><div class=""> </div><div class=""> ``</div><div class=""> db = DAL(&#x27;...&#x27;, db_codec=&#x27;latin1&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> otherwise you&#x27;ll get UnicodeDecodeErrors tickets.</div><div class=""> </div><div class=""> #### Connection pooling</div><div class=""> ``connection pooling``:inxx</div><div class=""> </div><div class=""> The second argument of the DAL constructor is the ``pool_size``; it defaults to zero.</div><div class=""> </div><div class="delete">As it is rather slow to establish a new database connection for each request, web2py implements a mechanism for connection pooling. Once a connection is established and the page has been served and the transaction completed, the connection is not closed but goes into a pool. When the next http request arrives, web2py tries to <span class="highlight">obtain</span> a connection from the pool and use that for the new transaction. If there are no available connections in the pool, a new connection is established.</div><div class=""> </div><div class="delete"><span class="highlight"></span>The <span class="highlight"></span>``pool_size`` <span class="highlight">parameter is i</span>g<span class="highlight">nor</span>ed<span class="highlight"> by SQLite and Google App Engine</span>.</div><div class=""> </div><div class=""> Connections in the pools are shared sequentially among threads, in the sense that they may be used by two different but not simultaneous threads. There is only one pool for each web2py process.</div><div class=""> </div><div class="delete">-When web2py starts, the pool is always empty. The pool grows up to the minimum between the value of ``pool_size`` and the max number of concurrent requests. This means that if ``pool_size=10`` but our server never receives more than 5 concurrent requests, then the actual pool size will only grow to 5. If ``pool_size=0`` then connection pooling is not used.</div><div class="delete"><span class="highlight"></span></div><div class=""> Connection pooling is ignored for SQLite, since it would not yield any benefit.</div><div class=""> </div><div class=""> #### Connection failures</div><div class=""> </div><div class=""> If web2py fails to connect to the database it waits 1 seconds and tries again up to 5 times before declaring a failure. In case of connection pooling it is possible that a pooled connection that stays open but unused for some time is closed by the database end. Thanks to the retry feature web2py tries to re-establish these dropped connections.</div><div class=""> </div><div class="delete">-When using connection pooling a connection is used, put back in the pool and then recycled. It is possible that while the connection is idle in pool the connection is closed by the database server. This can be because of a malfunction or a timeout. When this happens web2py detects it and re-establish the connection.</div><div class="delete">-</div><div class=""> #### Replicated databases</div><div class=""> </div><div class=""> The first argument of ``DAL(...)`` can be a list of URIs. In this case web2py tries to connect to each of them. The main purpose for this is to deal with multiple database servers and distribute the workload among them). Here is a typical use case:</div><div class=""> </div><div class=""> ``</div><div class=""> db = DAL([&#x27;mysql://...1&#x27;,&#x27;mysql://...2&#x27;,&#x27;mysql://...3&#x27;])</div><div class=""> ``:code</div><div class=""> </div><div class=""> In this case the DAL tries to connect to the first and, on failure, it</div><div class=""> will try the second and the third. This can also be used to distribute load</div><div class=""> in a database master-slave configuration. We will talk more about this</div><div class=""> in Chapter 13 in the context of scalability.</div><div class=""> </div><div class=""> ### Reserved keywords</div><div class=""> ``reserved Keywords``:inxx</div><div class=""> </div><div class="delete"><span class="highlight">T</span>he<span class="highlight"></span>re<span class="highlight"></span> is <span class="highlight">also</span> another argument that can be passed to the DAL constructor<span class="highlight"></span> to check table names and column names against reserved SQL keywords in target back-end databases.</div><div class=""> </div><div class=""> This argument is ``check_reserved`` and it defaults to None.</div><div class=""> </div><div class=""> This is a list of strings that contain the database back-end adapter names.</div><div class=""> </div><div class=""> The adapter name is the same as used in the DAL connection string. So if you want to check against PostgreSQL and MSSQL then your connection string would look as follows:</div><div class=""> ``</div><div class=""> db = DAL(&#x27;sqlite://storage.db&#x27;,</div><div class="">          check_reserved=[&#x27;postgres&#x27;, &#x27;mssql&#x27;])</div><div class=""> ``:code</div><div class=""> </div><div class=""> The DAL will scan the keywords in the same order as of the list.</div><div class=""> </div><div class=""> There are two extra options &quot;all&quot; and &quot;common&quot;. If you specify all, it will check against all known SQL keywords. If you specify common, it will only check against common SQL keywords such as ``SELECT``, ``INSERT``, ``UPDATE``, etc.</div><div class=""> </div><div class=""> For supported back-ends you may also specify if you would like to check against the non-reserved SQL keywords as well. In this case you would append ``_nonreserved`` to the name. For example:</div><div class=""> ``</div><div class=""> check_reserved=[&#x27;postgres&#x27;, &#x27;postgres_nonreserved&#x27;]</div><div class=""> ``:code</div><div class=""> </div><div class=""> The following database backends support reserved words checking.</div><div class=""> </div><div class=""> -----</div><div class=""> **PostgreSQL** | ``postgres(_nonreserved)``</div><div class=""> **MySQL** | ``mysql``</div><div class=""> **FireBird** | ``firebird(_nonreserved)``</div><div class=""> **MSSQL** | ``mssql``</div><div class=""> **Oracle** | ``oracle``</div><div class=""> -----</div><div class=""> </div><div class=""> ### ``DAL``, ``Table``, ``Field``</div><div class=""> </div><div class="delete"><span class="highlight">Th</span>e<span class="highlight"> b</span>e<span class="highlight">s</span>t w<span class="highlight">ay </span>t<span class="highlight">o understand</span> the DAL API <span class="highlight">i</span>s<span class="highlight"> to try each function yourself. This can be done </span>in<span class="highlight">teractively via</span> the web2py shell<span class="highlight">, although ultimately, DAL code goes in the models and controllers</span>.</div><div class=""> </div><div class=""> Start by creating a connection. For the sake of example, you can use SQLite. Nothing in this discussion changes when you change the back-end engine.</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db = DAL(&#x27;sqlite://storage.db&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> The database is now connected and the connection is stored in the global variable ``db``.</div><div class=""> </div><div class=""> At any time you can retrieve the connection string.</div><div class=""> ``_uri``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; print db._uri</div><div class=""> sqlite://storage.db</div><div class=""> ``:code</div><div class=""> </div><div class=""> and the database name</div><div class=""> ``_dbname``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; print db._dbname</div><div class=""> Not all of them are relevant for every field. &quot;length&quot; is relevant only for fiel</div><div class=""> ``decimal(n,m)`` | ``IS_DECIMAL_IN_RANGE(-1e100, 1e100)``</div><div class=""> ``date`` | ``IS_DATE()``</div><div class=""> ``time`` | ``IS_TIME()``</div><div class=""> ``datetime`` | ``IS_DATETIME()``</div><div class=""> ``password`` | ``None``</div><div class=""> ``upload`` | ``None``</div><div class=""> ``reference &lt;table&gt;``  | ``IS_IN_DB(db,table.field,format)``</div><div class=""> ``list:string`` | ``None``</div><div class=""> ``list:integer`` | ``None``</div><div class=""> ``list:reference &lt;table&gt;`` | ``IS_IN_DB(db,table.field,format,multiple=True)``</div><div class=""> ``json`` | ``IS_JSON()``</div><div class=""> ``bigint`` | ``None``</div><div class=""> ``big-id`` | ``None``</div><div class=""> ``big-reference`` | ``None``</div><div class=""> ---------</div><div class=""> </div><div class=""> Decimal requires and returns values as ``Decimal`` objects, as defined in the Python ``decimal`` module. SQLite does not handle the ``decimal`` type so internally we treat it as a ``double``. The (n,m) are the number of digits in total and the number of digits after the decimal point respectively.</div><div class=""> </div><div class=""> The ``big-id`` and, ``big-reference`` are only supported by some of the database engines and are experimental. They are not normally used as field types unless for legacy tables, however, the DAL constructor has a ``bigint_id`` argument that when set to ``True`` makes the ``id`` fields and ``reference`` fields ``big-id`` and ``big-reference`` respectively.</div><div class=""> </div><div class="delete">The ``list:<span class="highlight"></span>`` fields are special because they are designed to take advantage of certain denormalization features on NoSQL (in the case of Google App Engine NoSQL, the field types ``ListProperty`` and ``StringListProperty``) and back-port them all the other supported relational databases. On relational databases lists are stored as a ``text`` field. The items are separated by a ``|`` and each ``|`` in string item is escaped as a ``||``. They are discussed in their own section.</div><div class=""> </div><div class=""> The ``json`` field type is pretty much explanatory. It can store any json serializable object. It is designed to work specifically for MongoDB and backported to the other database adapters for portability.</div><div class=""> </div><div class=""> -------</div><div class=""> Notice that ``requires=...`` is enforced at the level of forms, ``required=True`` is enforced at the level of the DAL (insert), while ``notnull``, ``unique`` and ``ondelete`` are enforced at the level of the database. While they sometimes may seem redundant, it is important to maintain the distinction when programming with the DAL.</div><div class=""> -------</div><div class=""> </div><div class=""> ``ondelete``:inxx</div><div class=""> </div><div class=""> - ``ondelete`` translates into the &quot;ON DELETE&quot; SQL statement. By default it is set to &quot;CASCADE&quot;. This tells the database that when it deletes a record, it should also delete all records that refer to it. To disable this feature, set ``ondelete`` to &quot;NO ACTION&quot; or &quot;SET NULL&quot;.</div><div class=""> - ``notnull=True`` translates into the &quot;NOT NULL&quot; SQL statement. It prevents the database from inserting null values for the field.</div><div class=""> - ``unique=True`` translates into the &quot;UNIQUE&quot; SQL statement and it makes sure that values of this field are unique within the table. It is enforced at the database level.</div><div class=""> - ``uploadfield`` applies only to fields of type &quot;upload&quot;. A field of type &quot;upload&quot; stores the name of a file saved somewhere else, by default on the filesystem under the application &quot;uploads/&quot; folder. If ``uploadfield`` is set, then the file is stored in a blob field within the same table and the value of ``uploadfield`` is the name of the blob field. This will be discussed in more detail later in the context of SQLFORM.</div><div class="delete">-- ``uploadfolder`` defaults to the application&#x27;s &quot;uploads/&quot; folder. If set to a different path, files will uploaded to a different folder. For example, uploadfolder=os.path.join(request.folder,&#x27;static/temp&#x27;) will upload files to the web2py/applications/myapp/static/temp folder.</div><div class="delete">-- ``uploadseparate`` if set to True will upload files under different subfolders of the &#x27;&#x27;uploadfolder&#x27;&#x27; folder. This is optimized to avoid too many files under the same folder/subfolder. ATTENTION: You cannot change the value of ``uploadseparate`` from True to False without breaking the system. web2py either uses the separate subfolders or it does not. Changing the behavior after files have been uploaded will prevent web2py from being able to retrieve those files. If this happens it is possible to move files and fix the problem but this is not described here.</div><div class="delete">-- ``uploadfs`` allows you specify a different file system where to upload files, including an Amazon S3 storage or a remote FTP storage. This option requires PyFileSystem installed. ``uploadfs`` must point to ``PyFileSystem``. ``PyFileSystem``:inxx ``uploadfs``:idxx</div><div class=""> - ``widget`` must be one of the available widget objects, including custom widgets, for example: ``SQLFORM.widgets.string.widget``. A list of available widgets will be discussed later. Each field type has a default widget.</div><div class="delete">-- ``label`` is a string (or something that can be serialized to a string) that contains the label to be used for this field in auto-generated forms.</div><div class="delete">-- ``comment``  is a string (or something that can be serialized to a string) that contains a comment associated with this field, and will be displayed to the right of the input field in the autogenerated forms.</div><div class="delete">-- ``writable`` if a field is writable, it can be edited in autogenerated create and update forms.</div><div class="delete">-- ``readable`` if a field is readable, it will be visible in read-only forms. If a field is neither readable nor writable, it will not be displayed in create and update forms.</div><div class=""> - ``update`` contains the default value for this field when the record is updated.</div><div class=""> - ``compute`` is an optional function. If a record is inserted or updated, the compute function will be executed and the field will be populated with the function result. The record is passed to the compute function as a ``dict``, and the dict will not include the current value of that, or any other compute field.</div><div class=""> - ``authorize`` can be used to require access control on the corresponding field, for &quot;upload&quot; fields only. It will be discussed more in detail in the context of Authentication and Authorization.</div><div class=""> - ``autodelete`` determines if the corresponding uploaded file should be deleted when the record referencing the file is deleted. For &quot;upload&quot; fields only.</div><div class=""> - ``represent`` can be None or can point to a function that takes a field value and returns an alternate representation for the field value. Examples:</div><div class=""> ``</div><div class=""> db.mytable.name.represent = lambda name,row: name.capitalize()</div><div class=""> db.mytable.other_id.represent = lambda id,row: row.myfield</div><div class=""> db.mytable.some_uploadfield.represent = lambda value,row: \</div><div class="">     A(&#x27;get it&#x27;, _href=URL(&#x27;download&#x27;, args=value))</div><div class=""> ``:code</div><div class=""> </div><div class=""> ``blob``:inxx</div><div class=""> &quot;blob&quot; fields are also special. By default, binary data is encoded in base64 before being stored into the actual database field, and it is decoded when extracted. This has the negative effect of using 25% more storage space than necessary in blob fields, but has two advantages. On average it reduces the amount of data communicated between web2py and the database server, and it makes the communication independent of back-end-specific escaping conventions.</div><div class=""> </div><div class=""> Most attributes of fields and tables can be modified after they are defined:</div><div class=""> </div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;,Field(&#x27;name&#x27;,default=&#x27;&#x27;),format=&#x27;%(name)s&#x27;)</div><div class=""> db.person._format = &#x27;%(name)s/%(id)s&#x27;</div><div class=""> We refer to this behavior as a &quot;migration&quot;. web2py logs all migrations and migra</div><div class=""> </div><div class=""> The first argument of ``define_table`` is always the table name. The other unnamed arguments are the fields (Field). The function also takes an optional last argument called &quot;migrate&quot; which must be referred to explicitly by name as in:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;), migrate=&#x27;person.table&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> The value of migrate is the filename (in the &quot;databases&quot; folder for the application) where web2py stores internal migration information for this table. </div><div class=""> These files are very important and should never be removed while the corresponding tables exist.  In cases where a table has been dropped and the corresponding file still exist, it can be removed manually. By default, migrate is set to True. This causes web2py to generate the filename from a hash of the connection string. If migrate is set to False, the migration is not performed, and web2py assumes that the table exists in the datastore and it contains (at least) the fields listed in ``define_table``.</div><div class=""> The best practice is to give an explicit name to the migrate table.</div><div class=""> </div><div class=""> There may not be two tables in the same application with the same migrate filename.</div><div class=""> </div><div class=""> The DAL class also takes a &quot;migrate&quot; argument, which determines the default value of migrate for calls to ``define_table``. For example,</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db = DAL(&#x27;sqlite://storage.db&#x27;, migrate=False)</div><div class=""> ``:code</div><div class=""> </div><div class=""> will set the default value of migrate to False whenever ``db.define_table`` is called without a migrate argument.</div><div class=""> </div><div class=""> ------</div><div class="delete">Notice that web2py only migrates new columns, removed columns, and changes in column type (<span class="highlight">no</span>t in sqlite). web2py does not migrate changes in attributes such as changes in the values of ``default``, ``unique``, ``notnull``, and ``ondelete``.</div><div class=""> ------</div><div class=""> </div><div class="delete">Migrations can be disabled for all tables at <span class="highlight">the moment of c</span>on<span class="highlight">n</span>e<span class="highlight">ction</span>:</div><div class=""> </div><div class=""> ``</div><div class=""> db = DAL(...,migrate_enabled=False)</div><div class=""> ``</div><div class=""> </div><div class=""> This is the recommended behavior when two apps share the same database. Only one of the two apps should perform migrations, the other should disabled them.</div><div class=""> </div><div class=""> ### Fixing broken migrations</div><div class=""> ``fake_migrate``:inxx</div><div class=""> </div><div class=""> There are two common problems with migrations and there are ways to recover from them.</div><div class=""> </div><div class=""> One problem is specific with SQLite. SQLite does not enforce column types and cannot drop columns. This means that if you have a column of type string and you remove it, it is not really removed. If you add the column again with a different type (for example datetime) you end up with a datetime column that contains strings (junk for practical purposes). web2py does not complain about this because it does not know what is in the database, until it tries to retrieve records and fails.</div><div class=""> </div><div class=""> If web2py returns an error in the gluon.sql.parse function when selecting records, this is the problem: corrupted data in a column because of the above issue.</div><div class=""> </div><div class=""> The solution consists in updating all records of the table and updating the values in the column in question with None.</div><div class=""> </div><div class=""> The other problem is more generic but typical with MySQL. MySQL does not allow more than one ALTER TABLE in a transaction. This means that web2py must break complex transactions into smaller ones (one ALTER TABLE at the time) and commit one piece at the time. It is therefore possible that part of a complex transaction gets committed and one part fails, leaving web2py in a corrupted state. Why would part of a transaction fail? Because, for example, it involves altering a table and converting a string column into a datetime column, web2py tries to convert the data, but the data cannot be converted. What happens to web2py? It gets confused about what exactly is the table structure actually stored in the database.</div><div class=""> </div><div class=""> The solution consists of disabling migrations for all tables and enabling fake migrations:</div><div class=""> ``</div><div class=""> db.define_table(....,migrate=False,fake_migrate=True)</div><div class=""> ``:code</div><div class=""> </div><div class=""> This will rebuild web2py metadata about the table according to the table definition. Try multiple table definitions to see which one works (the one before the failed migration and the one after the failed migration). Once successful remove the ``fake_migrate=True`` attribute.</div><div class=""> </div><div class=""> Before attempting to fix migration problems it is prudent to make a copy of &quot;applications/yourapp/databases/*.table&quot; files.</div><div class=""> </div><div class=""> Migration problems can also be fixed for all tables at once:</div><div class=""> </div><div class=""> ``</div><div class=""> db = DAL(...,fake_migrate_all=True)</div><div class=""> ``:code</div><div class=""> </div><div class="delete">-Although if this fails, it will not help in narrowing down the problem.</div><div class=""> </div><div class=""> ### ``insert``</div><div class=""> </div><div class=""> Given a table, you can insert records</div><div class=""> </div><div class=""> ``insert``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.person.insert(name=&quot;Alex&quot;)</div><div class=""> 1</div><div class=""> &gt;&gt;&gt; db.person.insert(name=&quot;Bob&quot;)</div><div class=""> 2</div><div class=""> ``:code</div><div class=""> </div><div class=""> Insert returns the unique &quot;id&quot; value of each record inserted.</div><div class=""> </div><div class=""> You can truncate the table, i.e., delete all records and reset the counter of the id.</div><div class=""> </div><div class=""> ``truncate``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.person.truncate()</div><div class=""> Finally, you can drop tables and all data will be lost:</div><div class=""> </div><div class=""> Currently the DAL API does not provide a command to create indexes on tables, but this can be done using the ``executesql`` command. This is because the existence of indexes can make migrations complex, and it is better to deal with them explicitly. Indexes may be needed for those fields that are used in recurrent queries.</div><div class=""> </div><div class=""> Here is an example of how to [[create an index using SQL in SQLite http://www.sqlite.org/lang_createindex.html]]:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db = DAL(&#x27;sqlite://storage.db&#x27;)</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;))</div><div class=""> &gt;&gt;&gt; db.executesql(&#x27;CREATE INDEX IF NOT EXISTS myidx ON person (name);&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> Other database dialects have very similar syntaxes but may not support the optional &quot;IF NOT EXISTS&quot; directive.</div><div class=""> </div><div class=""> ### Legacy databases and keyed tables</div><div class=""> </div><div class=""> web2py can connect to legacy databases under some conditions.</div><div class=""> </div><div class=""> The easiest way is when these conditions are met:</div><div class=""> - Each table must have a unique auto-increment integer field called &quot;id&quot;</div><div class=""> - Records must be referenced exclusively using the &quot;id&quot; field.</div><div class=""> </div><div class=""> When accessing an existing table, i.e., a table not created by web2py in the current application, always set ``migrate=False``.</div><div class=""> </div><div class=""> If the legacy table has an auto-increment integer field but it is not called &quot;id&quot;, web2py can still access it but the table definition must contain explicitly as ``Field(&#x27;....&#x27;,&#x27;id&#x27;)`` where ... is the name of the auto-increment integer field.</div><div class=""> </div><div class=""> ``keyed table``:inxx</div><div class=""> </div><div class=""> Finally if the legacy table uses a primary key that is not an auto-increment id field it is possible to use a &quot;keyed table&quot;, for example:</div><div class=""> ``</div><div class=""> db.define_table(&#x27;account&#x27;,</div><div class="">     Field(&#x27;accnum&#x27;,&#x27;integer&#x27;),</div><div class="">     Field(&#x27;acctype&#x27;),</div><div class="">     Field(&#x27;accdesc&#x27;),</div><div class="">     primarykey=[&#x27;accnum&#x27;,&#x27;acctype&#x27;],</div><div class="">     migrate=False)</div><div class=""> ``:code</div><div class=""> </div><div class=""> - ``primarykey`` is a list of the field names that make up the primary key.</div><div class=""> - All primarykey fields have a ``NOT NULL`` set even if not specified.</div><div class=""> - Keyed tables can only reference other keyed tables.</div><div class=""> - Referencing fields must use the ``reference tablename.fieldname`` format.</div><div class=""> - The ``update_record`` function is not available for Rows of keyed tables.</div><div class=""> </div><div class=""> -------</div><div class="delete"><span class="highlight">Note that c</span>urrently <span class="highlight"></span>t<span class="highlight">hi</span>s <span class="highlight">is</span> only <span class="highlight">availabl</span>e<span class="highlight"></span> for DB2, MS-SQL, Ingres and Informix, but others <span class="highlight">ca</span>n<span class="highlight"></span> be<span class="highlight"> easily</span> added.</div><div class=""> -------</div><div class=""> </div><div class=""> At the time of writing, we cannot guarantee that the ``primarykey`` attribute works with every existing legacy table and every supported database backend.</div><div class=""> For simplicity, we recommend, if possible, creating a database view that has an auto-increment id field.</div><div class=""> </div><div class=""> </div><div class=""> ### Distributed transaction</div><div class=""> ``distributed transactions``:inxx</div><div class=""> </div><div class=""> ------</div><div class=""> At the time of writing this feature is only supported</div><div class=""> by PostgreSQL, MySQL and Firebird, since they expose API for two-phase commits.</div><div class=""> ------</div><div class=""> </div><div class=""> Assuming you have two (or more) connections to distinct PostgreSQL databases, for example:</div><div class=""> ``</div><div class=""> db_a = DAL(&#x27;postgres://...&#x27;)</div><div class=""> db_b = DAL(&#x27;postgres://...&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> Alex</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can have the fetched records appear in random order:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db().select(</div><div class="">         db.person.ALL, orderby=&#x27;&lt;random&gt;&#x27;):</div><div class="">         print row.name</div><div class=""> Carl</div><div class=""> Alex</div><div class=""> Bob</div><div class=""> ``:code</div><div class=""> </div><div class=""> -----</div><div class=""> The use of ``orderby=&#x27;&lt;random&gt;&#x27;`` is not supported on Google NoSQL.  However, in this situation and likewise in many others where built-ins are insufficient, imports can be used:</div><div class=""> ``</div><div class=""> import random</div><div class=""> rows=db(...).select().sort(lambda row: random.random())</div><div class=""> ``:code</div><div class=""> -----</div><div class=""> </div><div class="delete"><span class="highlight">And y</span>ou can sort the records according to multiple fields by concatenating them with a &quot;|&quot;:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db().select(</div><div class="">         db.person.ALL, orderby=db.person.name|db.person.id):</div><div class="">         print row.name</div><div class=""> Carl</div><div class=""> Bob</div><div class=""> Alex</div><div class=""> ``:code</div><div class=""> </div><div class=""> Using ``groupby`` together with ``orderby``, you can group records with the same value for the specified field (this is back-end specific, and is not on the Google NoSQL):</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db().select(</div><div class="">         db.person.ALL,</div><div class="">         orderby=db.person.name, groupby=db.person.name):</div><div class="">         print row.name</div><div class=""> Alex</div><div class=""> Bob</div><div class=""> Carl</div><div class=""> ``:code</div><div class=""> </div><div class=""> web2py also allows updating a single record that is already in memory using ``up</div><div class=""> because for a single row, the method ``update`` updates the row object but not the database record, as in the case of ``update_record``.</div><div class=""> </div><div class=""> It is also possible to change the attributes of a row (one at a time) and then call ``update_record()`` without arguments to save the changes:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; row = db(db.person.id &gt; 2).select().first()</div><div class=""> &gt;&gt;&gt; row.name = &#x27;Curt&#x27;</div><div class=""> &gt;&gt;&gt; row.update_record() # saves above change</div><div class=""> ``:code</div><div class=""> </div><div class=""> The ``update_record`` method is available only if the table&#x27;s ``id`` field is included in the select, and ``cacheable`` is not set to ``True``.</div><div class=""> </div><div class=""> #### Inserting and updating from a dictionary</div><div class=""> </div><div class=""> A common issue consists of needing to insert or update records in a table where the name of the table, the field to be updated, and the value for the field are all stored in variables. For example: ``tablename``, ``fieldname``, and ``value``.</div><div class=""> </div><div class=""> The insert can be done using the following syntax:</div><div class=""> </div><div class=""> ``</div><div class=""> db[tablename].insert(**{fieldname:value})</div><div class="delete">``:<span class="highlight"></span></div><div class=""> </div><div class=""> The update of record with given id can be done with: ``_id``:inxx</div><div class=""> </div><div class=""> ``</div><div class=""> db(db[tablename]._id==id).update(**{fieldname:value})</div><div class=""> ``:code</div><div class=""> </div><div class=""> Notice we used ``table._id`` instead of ``table.id``. In this way the query works even for tables with a field of type &quot;id&quot; which has a name other than &quot;id&quot;.</div><div class=""> </div><div class=""> </div><div class=""> #### ``first`` and ``last``</div><div class=""> ``first``:inxx ``last``:inxx</div><div class=""> </div><div class=""> Given a Rows object containing records:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows = db(query).select()</div><div class=""> &gt;&gt;&gt; first_row = rows.first()</div><div class=""> &gt;&gt;&gt; last_row = rows.last()</div><div class=""> ``:code</div><div class=""> name</div><div class=""> Max</div><div class=""> Tim</div><div class=""> John</div><div class=""> Tim</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can do a union of the records removing duplicates:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows3 = rows1 | rows2</div><div class=""> &gt;&gt;&gt; print rows3</div><div class=""> name</div><div class=""> Max</div><div class=""> Tim</div><div class=""> John</div><div class=""> ``:code</div><div class=""> </div><div class=""> #### ``find``, ``exclude``, ``sort``</div><div class=""> ``find``:inxx ``exclude``:inxx ``sort``:inxx</div><div class=""> </div><div class="delete"><span class="highlight">There are ti</span>me<span class="highlight">s when one needs</span> to perform two selects and one contains a subset of a previous select. In this case it is pointless to access the database again. The ``find``, ``exclude`` and ``sort`` objects allow you to manipulate a Rows objects and generate another one without accessing the database. More specifically:</div><div class=""> - ``find`` returns a new set of Rows filtered by a condition and leaves the original unchanged.</div><div class=""> - ``exclude`` returns a new set of Rows filtered by a condition and removes them from the original Rows.</div><div class=""> - ``sort`` returns a new set of Rows sorted by a condition and leaves the original unchanged.</div><div class=""> </div><div class=""> All these methods take a single argument, a function that acts on each individual row.</div><div class=""> </div><div class=""> Here is an example of usage:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;,Field(&#x27;name&#x27;))</div><div class=""> &gt;&gt;&gt; db.person.insert(name=&#x27;John&#x27;)</div><div class=""> &gt;&gt;&gt; db.person.insert(name=&#x27;Max&#x27;)</div><div class=""> &gt;&gt;&gt; db.person.insert(name=&#x27;Alex&#x27;)</div><div class=""> &gt;&gt;&gt; rows = db(db.person).select()</div><div class=""> &gt;&gt;&gt; for row in rows.find(lambda row: row.name[0]==&#x27;M&#x27;):</div><div class="">         print row.name</div><div class=""> Max</div><div class=""> &gt;&gt;&gt; print len(rows)</div><div class=""> 3</div><div class=""> &gt;&gt;&gt; for row in rows.exclude(lambda row: row.name[0]==&#x27;M&#x27;):</div><div class="">         print row.name</div><div class=""> Here is ``_delete`` ``_delete``:inxx</div><div class=""> DELETE FROM person WHERE person.name=&#x27;Alex&#x27;;</div><div class=""> ``:code</div><div class=""> </div><div class=""> And finally, here is ``_update`` ``_update``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; print db(db.person.name==&#x27;Alex&#x27;)._update()</div><div class=""> UPDATE person SET  WHERE person.name=&#x27;Alex&#x27;;</div><div class=""> ``:code</div><div class=""> </div><div class=""> -----</div><div class=""> Moreover you can always use ``db._lastsql`` to return the most recent</div><div class=""> SQL code, whether it was executed manually using executesql or was SQL</div><div class=""> generated by the DAL.</div><div class=""> -----</div><div class=""> </div><div class=""> ### Exporting and importing data</div><div class=""> ``export``:inxx ``import``:inxx</div><div class=""> </div><div class=""> #### CSV (one Table at a time)</div><div class=""> </div><div class="delete">When a <span class="highlight">DAL</span>Rows object is converted to a string it is automatically</div><div class=""> serialized in CSV:</div><div class=""> </div><div class=""> ``csv``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows = db(db.person.id==db.thing.owner).select()</div><div class=""> &gt;&gt;&gt; print rows</div><div class=""> person.id,person.name,thing.id,thing.name,thing.owner</div><div class=""> 1,Alex,1,Boat,1</div><div class=""> 1,Alex,2,Chair,1</div><div class=""> 2,Bob,3,Shoes,2</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can serialize a single table in CSV and store it in a file &quot;test.csv&quot;:</div><div class=""> ``</div><div class="delete">&gt;&gt;&gt; open(&#x27;test.csv&#x27;, &#x27;w<span class="highlight"></span>&#x27;).write(str(db(db.person.id).select()))</div><div class=""> ``:code</div><div class=""> </div><div class=""> This is equivalent to</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows = db(db.person.id).select()</div><div class="delete">&gt;&gt;&gt; rows.export_to_csv_file(open(&#x27;test.csv&#x27;, &#x27;w<span class="highlight"></span>&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can read the CSV file back with:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.person.import_from_csv_file(open(&#x27;test.csv&#x27;, &#x27;r&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class=""> When importing, web2py looks for the field names in the CSV header. In this example, it finds two columns: &quot;person.id&quot; and &quot;person.name&quot;. It ignores the &quot;person.&quot; prefix, and it ignores the &quot;id&quot; fields. Then all records are appended and assigned new ids. Both of these operations can be performed via the appadmin web interface.</div><div class=""> </div><div class=""> #### CSV (all tables at once)</div><div class=""> </div><div class=""> In web2py, you can backup/restore an entire database with two commands:</div><div class=""> </div><div class=""> To export:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.export_to_csv_file(open(&#x27;somefile.csv&#x27;, &#x27;wb&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class=""> To import:</div><div class=""> ``</div><div class=""> db.define_table(&#x27;thing&#x27;,</div><div class="">     format=&#x27;%(name)s&#x27;)</div><div class=""> </div><div class=""> if not db(db.person).count():</div><div class="">     id = db.person.insert(name=&quot;Massimo&quot;)</div><div class="">     db.thing.insert(owner=id, name=&quot;Chair&quot;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> Each record is identified by an ID and referenced by that ID. If you</div><div class=""> have two copies of the database used by distinct web2py installations,</div><div class=""> the ID is unique only within each database and not across the databases.</div><div class=""> This is a problem when merging records from different databases.</div><div class=""> </div><div class=""> In order to make a record uniquely identifiable across databases, they</div><div class=""> must:</div><div class=""> - have a unique id (UUID),</div><div class=""> - have an event_time (to figure out which one is more recent if multiple copies),</div><div class=""> - reference the UUID instead of the id.</div><div class=""> </div><div class=""> This can be achieved without modifying web2py. Here is what to do:</div><div class=""> </div><div class="delete"><span class="highlight">**1.** </span>Change the above model into:</div><div class=""> </div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;,</div><div class="">     Field(&#x27;uuid&#x27;, length=64, default=lambda:str(uuid.uuid4())),</div><div class="">     Field(&#x27;modified_on&#x27;, &#x27;datetime&#x27;, default=now),</div><div class="">     Field(&#x27;name&#x27;),</div><div class="">     format=&#x27;%(name)s&#x27;)</div><div class=""> </div><div class=""> db.define_table(&#x27;thing&#x27;,</div><div class="">     Field(&#x27;uuid&#x27;, length=64, default=lambda:str(uuid.uuid4())),</div><div class="">     Field(&#x27;modified_on&#x27;, &#x27;datetime&#x27;, default=now),</div><div class="">     Field(&#x27;owner&#x27;, length=64),</div><div class="">     Field(&#x27;name&#x27;),</div><div class="">     format=&#x27;%(name)s&#x27;)</div><div class=""> </div><div class=""> db.thing.owner.requires = IS_IN_DB(db,&#x27;person.uuid&#x27;,&#x27;%(name)s&#x27;)</div><div class=""> </div><div class=""> if not db(db.person.id).count():</div><div class="">     id = uuid.uuid4()</div><div class="">     db.person.insert(name=&quot;Massimo&quot;, uuid=id)</div><div class="">     db.thing.insert(owner=id, name=&quot;Chair&quot;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> -------</div><div class="delete">Not<span class="highlight">e</span>, <span class="highlight">in the abo</span>v<span class="highlight">e table definitions, the default v</span>alue for the two <span class="highlight">&#x27;uuid&#x27;</span> fields is set to a lambda function, which returns a UUID (converted to a string). The lambda function is called once for each record inserted, ensuring that each record gets a unique UUID, even if multiple records are inserted in a single transaction.</div><div class=""> -------</div><div class=""> </div><div class="delete"><span class="highlight">**2.** </span>Create a controller action to export the database:</div><div class=""> </div><div class=""> ``</div><div class=""> def export():</div><div class="">     s = StringIO.StringIO()</div><div class="">     db.export_to_csv_file(s)</div><div class="">     response.headers[&#x27;Content-Type&#x27;] = &#x27;text/csv&#x27;</div><div class="">     return s.getvalue()</div><div class=""> ``:code</div><div class=""> </div><div class="delete"><span class="highlight">**3.** </span>Create a controller action to import a saved copy of the other database and sync records:</div><div class=""> </div><div class=""> ``</div><div class=""> def import_and_sync():</div><div class="">     form = FORM(INPUT(_type=&#x27;file&#x27;, _name=&#x27;data&#x27;), INPUT(_type=&#x27;submit&#x27;))</div><div class="delete">    if form.process(<span class="highlight">session=None</span>).accepted:</div><div class="">         db.import_from_csv_file(form.vars.data.file,unique=False)</div><div class="">         # for every table</div><div class="">         for table in db.tables:</div><div class="">             # for every uuid, delete all but the latest</div><div class="">             items = db(db[table]).select(db[table].id,</div><div class="">                        db[table].uuid,</div><div class="">                        orderby=db[table].modified_on,</div><div class="">                        groupby=db[table].uuid)</div><div class="">             for item in items:</div><div class="">                 db((db[table].uuid==item.uuid)&amp;\</div><div class="">                    (db[table].id!=item.id)).delete()</div><div class="">     return dict(form=form)</div><div class=""> ``:code</div><div class=""> </div><div class="delete">-Notice that ``session=None`` disables the CSRF protection since this URL is intended to be accessed from outside.</div><div class="delete">-</div><div class="delete"><span class="highlight">**4.**</span> <span class="highlight">C</span>reate an index manually to make the search by uuid faster.</div><div class=""> </div><div class="delete">-Notice that steps 2 and 3 work for every database model; they are not</div><div class="delete">-specific for this example.</div><div class=""> </div><div class=""> ``XML-RPC``:inxx</div><div class=""> Alternatively, you can use XML-RPC to export/import the file.</div><div class=""> </div><div class=""> If the records reference uploaded files, you also need to export/import the content of the uploads folder. Notice that files therein are already labeled by UUIDs so you do not need to worry about naming conflicts and references.</div><div class=""> </div><div class=""> #### HTML and XML (one Table at a time)</div><div class=""> </div><div class="delete">-``DALRows objects``:inxx</div><div class="delete">-DALRows objects also have an ``xml`` method (like helpers) that serializes it to XML/HTML:</div><div class=""> </div><div class=""> ``HTML``:inxx</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows = db(db.person.id &gt; 0).select()</div><div class=""> &gt;&gt;&gt; print rows.xml()</div><div class=""> &lt;table&gt;</div><div class="">   &lt;thead&gt;</div><div class="">     &lt;tr&gt;</div><div class="">       &lt;th&gt;person.id&lt;/th&gt;</div><div class="">       &lt;th&gt;person.name&lt;/th&gt;</div><div class="">       &lt;th&gt;thing.id&lt;/th&gt;</div><div class="">       &lt;th&gt;thing.name&lt;/th&gt;</div><div class="">       &lt;th&gt;thing.owner&lt;/th&gt;</div><div class="">     &lt;/tr&gt;</div><div class="">   &lt;/thead&gt;</div><div class="">   &lt;tbody&gt;</div><div class="">     &lt;tr class=&quot;even&quot;&gt;</div><div class="">       &lt;td&gt;1&lt;/td&gt;</div><div class="">       &lt;td&gt;Alex&lt;/td&gt;</div><div class="">       &lt;td&gt;1&lt;/td&gt;</div><div class="">       &lt;td&gt;Boat&lt;/td&gt;</div><div class="">       &lt;td&gt;1&lt;/td&gt;</div><div class="">     &lt;/tr&gt;</div><div class="">     ...</div><div class="">   &lt;/tbody&gt;</div><div class=""> &lt;/table&gt;</div><div class=""> ``:code</div><div class=""> </div><div class="delete">-``DALRows custom tags``:inxx</div><div class="delete">-If you need to serialize the DALRows in any other XML format with custom tags, you can easily do that using the universal TAG helper and the * notation:</div><div class=""> ``XML``:inxx</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows = db(db.person.id &gt; 0).select()</div><div class=""> &gt;&gt;&gt; print TAG.result(*[TAG.row(*[TAG.field(r[f], _name=f) \</div><div class="">           for f in db.person.fields]) for r in rows])</div><div class=""> &lt;result&gt;</div><div class="">   &lt;row&gt;</div><div class="">     &lt;field name=&quot;id&quot;&gt;1&lt;/field&gt;</div><div class="">     &lt;field name=&quot;name&quot;&gt;Alex&lt;/field&gt;</div><div class="">   &lt;/row&gt;</div><div class="">   ...</div><div class=""> &lt;/result&gt;</div><div class=""> ``:code</div><div class=""> </div><div class=""> #### Data representation</div><div class=""> </div><div class=""> ``export_to_csv_file``:inxx</div><div class=""> The ``export_to_csv_file`` function accepts a keyword argument named ``represent``. When ``True`` it will use the columns ``represent`` function while exporting the data instead of the raw data.</div><div class=""> </div><div class=""> The select method also takes a cache argument, which defaults to None. For cachi</div><div class=""> </div><div class=""> In the following example, you see a controller that caches a select on the previously defined db.log table. The actual select fetches data from the back-end database no more frequently than once every 60 seconds and stores the result in cache.ram. If the next call to this controller occurs in less than 60 seconds since the last database IO, it simply fetches the previous data from cache.ram.</div><div class=""> </div><div class=""> ``cache select``:inxx</div><div class=""> ``</div><div class=""> def cache_db_select():</div><div class="">     logs = db().select(db.log.ALL, cache=(cache.ram, 60))</div><div class="">     return dict(logs=logs)</div><div class=""> ``:code</div><div class=""> </div><div class=""> ``cacheable``:inxx</div><div class=""> </div><div class=""> The ``select`` method has an optional ``cacheable`` argument, normally set to ``False``. When ``cacheable=True`` the resulting ``Rows`` is serializable but The ``Row``s lack ``update_record`` and ``delete_record`` methods.</div><div class=""> </div><div class=""> If you do not need these methods you can speed up selects a lot by setting the cacheable attribute:</div><div class=""> </div><div class=""> ``</div><div class=""> rows = db(query).select(cacheable=True)</div><div class=""> ``:code</div><div class=""> </div><div class="delete">-The results of a ``select`` are normally complex, un-pickleable objects; they cannot be stored in a session and cannot be cached in any other way than the one explained here unless the ``cache`` attribute is set or ``cacheable=True``.</div><div class="delete">-</div><div class=""> When the ``cache`` argument is set but ``cacheable=False`` (default) only the database results are cached, not the actual Rows object. When the ``cache`` argument is used in conjunction with ``cacheable=True`` the entire Rows object is cached and this results in much faster caching:</div><div class=""> </div><div class=""> ``</div><div class=""> rows = db(query).select(cache=(cache.ram,3600),cacheable=True)</div><div class=""> ``:code</div><div class=""> </div><div class=""> ### Self-Reference and aliases</div><div class=""> </div><div class=""> ``self reference``:inxx</div><div class=""> ``alias``:inxx</div><div class=""> It is possible to define tables with fields that refer to themselves, here is an example:</div><div class=""> ``reference table``:inxx</div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;,</div><div class="">     Field(&#x27;name&#x27;),</div><div class="">     Field(&#x27;father_id&#x27;, &#x27;reference person&#x27;),</div><div class="">     Field(&#x27;mother_id&#x27;, &#x27;reference person&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class=""> Notice that the alternative notation of using a table object as field type will fail in this case, because it uses a variable ``db.person`` before it is defined:</div><div class=""> Here ``f`` is a dict of fields passed to insert or update, ``id`` is the id of t</div><div class=""> &gt;&gt;&gt; db(db.person.id==1).update(name=&#x27;Tim&#x27;)</div><div class=""> (&lt;Set (person.id = 1)&gt;, {&#x27;name&#x27;: &#x27;Tim&#x27;})</div><div class=""> (&lt;Set (person.id = 1)&gt;, {&#x27;name&#x27;: &#x27;Tim&#x27;})</div><div class=""> &gt;&gt;&gt; db(db.person.id==1).delete()</div><div class=""> (&lt;Set (person.id = 1)&gt;,)</div><div class=""> (&lt;Set (person.id = 1)&gt;,)</div><div class=""> ``:code</div><div class=""> </div><div class=""> The return values of these callback should be ``None`` or ``False``. If any of the ``_before_*`` callback returns a ``True`` value it will abort the actual insert/update/delete operation.</div><div class=""> </div><div class=""> ``update_naive``:inxx.</div><div class=""> </div><div class=""> Some times a callback may need to perform an update in the same of a different table and one wants to avoid callbacks calling themselves recursively.</div><div class=""> </div><div class=""> For this purpose there the Set objects have an ``update_naive`` method that works like ``update`` but ignores before and after callbacks.</div><div class=""> </div><div class=""> #### Record versioning</div><div class=""> </div><div class=""> ``_enable_record_versioning``:inxx</div><div class=""> </div><div class="delete">It is possible to ask web2py to save every copy of a record when the record is<span class="highlight"></span> modified. There are different ways to do it and it can be done for all tables at once using the syntax:</div><div class=""> </div><div class=""> ``</div><div class=""> auth.enable_record_versioning(db)</div><div class=""> ``:code</div><div class=""> </div><div class=""> this requires Auth and it is discussed in the chapter about authentication.</div><div class=""> It can also be done for each individual table as discussed below.</div><div class=""> </div><div class=""> Consider the following table:</div><div class=""> </div><div class=""> ``</div><div class=""> db.define_table(&#x27;stored_item&#x27;,</div><div class="">     Field(&#x27;name&#x27;),</div><div class="">     Field(&#x27;quantity&#x27;,&#x27;integer&#x27;),</div><div class="">     Field(&#x27;is_active&#x27;,&#x27;boolean&#x27;,</div><div class="">           writable=False,readable=False,default=True))</div><div class=""> ``:code</div><div class=""> </div><div class=""> Notice the hidden boolean field called ``is_active`` and defaulting to</div><div class=""> True.</div><div class=""> Any select, delete or update in this table, will include only public blog posts.</div><div class=""> </div><div class=""> ``</div><div class=""> db.blog_post._common_filter = lambda query: db.blog_post.is_public == True</div><div class=""> ``</div><div class=""> </div><div class=""> It serves both as a way to avoid repeating the &quot;db.blog_post.is_public==True&quot; phrase in each blog post search, and also as a security enhancement, that prevents you from forgetting to disallow viewing of none public posts.</div><div class=""> </div><div class=""> In case you actually do want items left out by the common filter (for example, allowing the admin to see none public posts), you can either remove the filter:</div><div class=""> ``</div><div class=""> db.blog_post._common_filter = None</div><div class=""> ``</div><div class=""> or ignore it:</div><div class=""> ``</div><div class=""> db(query, ignore_common_filters=True).select(...)</div><div class=""> ``</div><div class=""> </div><div class=""> #### Custom ``Field`` types (experimental)</div><div class=""> </div><div class=""> ``SQLCustomType``:inxx</div><div class=""> </div><div class="delete">-It is possible to define new/custom field types. For example we consider here the example if a field that contains binary data in compressed form:</div><div class=""> </div><div class=""> ``</div><div class=""> from gluon.dal import SQLCustomType</div><div class=""> import zlib</div><div class=""> </div><div class=""> compressed = SQLCustomType(</div><div class="">      type =&#x27;text&#x27;,</div><div class="">      native=&#x27;text&#x27;,</div><div class="">      encoder =(lambda x: zlib.compress(x or &#x27;&#x27;)),</div><div class="">      decoder = (lambda x: zlib.decompress(x))</div><div class=""> )</div><div class=""> </div><div class=""> db.define_table(&#x27;example&#x27;, Field(&#x27;data&#x27;,type=compressed))</div><div class=""> ``:code</div><div class=""> </div><div class=""> ``SQLCustomType`` is a field type factory. Its ``type`` argument must be one of the standard web2py types. It tells web2py how to treat the field values at the web2py level. ``native`` is the name of the field as far as the database is concerned. Allowed names depend on the database engine. ``encoder`` is an optional transformation function applied when the data is stored and ``decoder`` is the optional reversed transformation function.</div><div class=""> </div><div class=""> This feature is marked as experimental. In practice it has been in web2py for a long time and it works but it can make the code not portable, for example when the native type is database specific. It does not work on Google App Engine NoSQL.</div><div class=""> </div><div class=""> #### Using DAL without define tables</div><div class=""> To access the data and its attributes we still have to define all the tables we</div><div class=""> </div><div class=""> If we just need access to the data but not to the web2py table attributes, we get away without re-defining the tables but simply asking web2py to read the necessary info from the metadata in the .table files:</div><div class=""> </div><div class=""> ``</div><div class=""> from gluon import DAL, Field</div><div class=""> db = DAL(&#x27;sqlite://storage.sqlite&#x27;,folder=&#x27;path/to/app/databases&#x27;,</div><div class="">          auto_import=True))</div><div class=""> ``:code</div><div class=""> </div><div class=""> This allows us to access any ``db.table`` without need to re-define it.</div><div class=""> </div><div class=""> #### PostGIS, SpatiaLite, and MS Geo (experimental)</div><div class=""> </div><div class=""> ``PostGIS``:inxx ``StatiaLite``:inxx ``Geo Extensions``:inxx</div><div class=""> ``geometry``:inxx ``geoPoint``:inxx ``geoLine``:inxx ``geoPolygon``:inxx</div><div class=""> </div><div class=""> The DAL supports geographical APIs using PostGIS (for PostgreSQL), spatialite (for SQLite), and MSSQL and Spatial Extensions. This is a feature that was sponsored by the Sahana project and implemented by Denes Lengyel.</div><div class=""> </div><div class=""> DAL provides geometry and geography fields types and the following functions:</div><div class=""> </div><div class="delete">``st_asgeojson``:inxx ``st_astext``:inxx ``st_contain<span class="highlight">ed``:inxx ``st_contain</span>s``:inxx</div><div class=""> ``st_distance``:inxx ``st_equals``:inxx ``st_intersects``:inxx ``st_overlaps``:inxx</div><div class=""> ``st_simplify``:inxx ``st_touches``:inxx ``st_within``:inxx</div><div class=""> </div><div class=""> ``</div><div class=""> st_asgeojson (PostGIS only)</div><div class=""> st_astext</div><div class=""> st_contains</div><div class=""> st_distance</div><div class=""> st_equals</div><div class=""> st_intersects</div><div class=""> st_overlaps</div><div class=""> st_simplify (PostGIS only)</div><div class=""> st_touches</div><div class=""> st_within</div><div class=""> st_x</div><div class=""> st_y</div><div class=""> ``</div><div class=""> </div><div class=""> Here are some examples:</div><div class=""> </div><div class=""> calls</div><div class=""> </div><div class=""> ``</div><div class=""> Table.insert(myfield=&#x27;myvalue&#x27;)</div><div class=""> ``</div><div class=""> </div><div class=""> which delegates the adapter by returning:</div><div class=""> </div><div class=""> ``</div><div class=""> db._adapter.insert(db.mytable,db.mytable._listify(dict(myfield=&#x27;myvalue&#x27;)))</div><div class=""> ``</div><div class=""> </div><div class=""> Here ``db.mytable._listify`` converts the dict of arguments into a list of ``(field,value)`` and calls the ``insert`` method of the ``adapter``. ``db._adapter`` does more or less the following:</div><div class=""> </div><div class=""> ``</div><div class=""> query = db._adapter._insert(db.mytable,list_of_fields)</div><div class=""> db._adapter.execute(query)</div><div class=""> ``</div><div class=""> </div><div class=""> where the first line builds the query and the second executes it.</div><div class=""> </div><div class="delete">``BaseAdapter`` define<span class="highlight"></span> the interface for all adapters.</div><div class=""> </div><div class=""> &quot;gluon/dal.py&quot; at the moment of writing this book, contains the following adapters:</div><div class=""> </div><div class=""> ``</div><div class=""> SQLiteAdapter extends BaseAdapter</div><div class=""> JDBCSQLiteAdapter extends SQLiteAdapter</div><div class=""> MySQLAdapter extends BaseAdapter</div><div class=""> PostgreSQLAdapter extends BaseAdapter</div><div class=""> JDBCPostgreSQLAdapter extends PostgreSQLAdapter</div><div class=""> OracleAdapter extends BaseAdapter</div><div class=""> MSSQLAdapter extends BaseAdapter</div><div class=""> MSSQL2Adapter extends MSSQLAdapter</div><div class=""> FireBirdAdapter extends BaseAdapter</div><div class=""> FireBirdEmbeddedAdapter extends FireBirdAdapter</div><div class=""> InformixAdapter extends BaseAdapter</div><div class=""> DB2Adapter extends BaseAdapter</div><div class=""> IngresAdapter extends BaseAdapter</div><div class=""> IngresUnicodeAdapter extends IngresAdapter</div><div class=""> GoogleSQLAdapter extends MySQLAdapter</div><div class=""> NoSQLAdapter extends BaseAdapter</div><div class=""> class MySQLAdapter(BaseAdapter):</div><div class="">                 credential_decoder=lambda x:x, driver_args={},</div><div class="">                 adapter_args={}):</div><div class="">         # parse uri string and store parameters in driver_args</div><div class="">         ...</div><div class="">         # define a connection function</div><div class="">         def connect(driver_args=driver_args):</div><div class="">             return self.driver.connect(**driver_args)</div><div class="">         # place it in the pool</div><div class="">         self.pool_connection(connect)</div><div class="">         # set optional parameters (after connection)</div><div class="">         self.execute(&#x27;SET FOREIGN_KEY_CHECKS=1;&#x27;)</div><div class="">         self.execute(&quot;SET sql_mode=&#x27;NO_BACKSLASH_ESCAPES&#x27;;&quot;)</div><div class=""> </div><div class="">    # override BaseAdapter methods as needed</div><div class="">    def lastrowid(self,table):</div><div class="">         self.execute(&#x27;select last_insert_id();&#x27;)</div><div class="">         return int(self.cursor.fetchone()[0])</div><div class=""> </div><div class=""> ``:code</div><div class=""> </div><div class="delete">Looking at the various adapters as example<span class="highlight">s</span> should be easy to write new ones.</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/83521b165c2d34b0f5904766b5cf9d6f9cf3660a">83521b1</a><ul><li>Date : 2013-02-04</li><li>added pythonanywhere screenshots</li></ul></li></ul>
<div class="row-fluid" id="com_83521b165c2d34b0f5904766b5cf9d6f9cf3660a">
    <div class="span6"><div class="diff"><div class=""> - ``ondelete`` translates into the &quot;ON DELETE&quot; SQL statement. By default it is set to &quot;CASCADE&quot;. This tells the database that when it deletes a record, it should also delete all records that refer to it. To disable this feature, set ``ondelete`` to &quot;NO ACTION&quot; or &quot;SET NULL&quot;.</div><div class=""> - ``notnull=True`` translates into the &quot;NOT NULL&quot; SQL statement. It prevents the database from inserting null values for the field.</div><div class=""> - ``unique=True`` translates into the &quot;UNIQUE&quot; SQL statement and it makes sure that values of this field are unique within the table. It is enforced at the database level.</div><div class=""> - ``uploadfield`` applies only to fields of type &quot;upload&quot;. A field of type &quot;upload&quot; stores the name of a file saved somewhere else, by default on the filesystem under the application &quot;uploads/&quot; folder. If ``uploadfield`` is set, then the file is stored in a blob field within the same table and the value of ``uploadfield`` is the name of the blob field. This will be discussed in more detail later in the context of SQLFORM.</div><div class=""> - ``uploadfolder`` defaults to the application&#x27;s &quot;uploads/&quot; folder. If set to a different path, files will uploaded to a different folder. For example, uploadfolder=os.path.join(request.folder,&#x27;static/temp&#x27;) will upload files to the web2py/applications/myapp/static/temp folder.</div><div class=""> - ``uploadseparate`` if set to True will upload files under different subfolders of the &#x27;&#x27;uploadfolder&#x27;&#x27; folder. This is optimized to avoid too many files under the same folder/subfolder. ATTENTION: You cannot change the value of ``uploadseparate`` from True to False without breaking the system. web2py either uses the separate subfolders or it does not. Changing the behavior after files have been uploaded will prevent web2py from being able to retrieve those files. If this happens it is possible to move files and fix the problem but this is not described here.</div><div class=""> - ``uploadfs`` allows you specify a different file system where to upload files, including an Amazon S3 storage or a remote FTP storage. This option requires PyFileSystem installed. ``uploadfs`` must point to ``PyFileSystem``. ``PyFileSystem``:inxx ``uploadfs``:idxx</div><div class=""> - ``widget`` must be one of the available widget objects, including custom widgets, for example: ``SQLFORM.widgets.string.widget``. A list of available widgets will be discussed later. Each field type has a default widget.</div><div class="insert">- ``label`` is a string (or something that can be serialized to a string) that contains the label to be used for this field in auto<span class="highlight">-</span>generated forms.</div><div class=""> - ``comment``  is a string (or something that can be serialized to a string) that contains a comment associated with this field, and will be displayed to the right of the input field in the autogenerated forms.</div><div class=""> - ``writable`` if a field is writable, it can be edited in autogenerated create and update forms.</div><div class="insert">- ``readable`` if a field is readable, it will be visible in read<span class="highlight">-</span>only forms. If a field is neither readable nor writable, it will not be displayed in create and update forms.</div><div class=""> - ``update`` contains the default value for this field when the record is updated.</div><div class=""> - ``compute`` is an optional function. If a record is inserted or updated, the compute function will be executed and the field will be populated with the function result. The record is passed to the compute function as a ``dict``, and the dict will not include the current value of that, or any other compute field.</div><div class=""> - ``authorize`` can be used to require access control on the corresponding field, for &quot;upload&quot; fields only. It will be discussed more in detail in the context of Authentication and Authorization.</div><div class=""> - ``autodelete`` determines if the corresponding uploaded file should be deleted when the record referencing the file is deleted. For &quot;upload&quot; fields only.</div><div class=""> - ``represent`` can be None or can point to a function that takes a field value and returns an alternate representation for the field value. Examples:</div><div class=""> ``</div><div class=""> db.mytable.name.represent = lambda name,row: name.capitalize()</div><div class=""> db.mytable.other_id.represent = lambda id,row: row.myfield</div><div class=""> db.mytable.some_uploadfield.represent = lambda value,row: \</div><div class="">     A(&#x27;get it&#x27;, _href=URL(&#x27;download&#x27;, args=value))</div><div class=""> ``:code</div><div class=""> </div><div class=""> ``blob``:inxx</div><div class=""> &quot;blob&quot; fields are also special. By default, binary data is encoded in base64 before being stored into the actual database field, and it is decoded when extracted. This has the negative effect of using 25% more storage space than necessary in blob fields, but has two advantages. On average it reduces the amount of data communicated between web2py and the database server, and it makes the communication independent of back-end-specific escaping conventions.</div><div class=""> </div><div class=""> Most attributes of fields and tables can be modified after they are defined:</div><div class=""> </div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;,Field(&#x27;name&#x27;,default=&#x27;&#x27;),format=&#x27;%(name)s&#x27;)</div><div class=""> db.person._format = &#x27;%(name)s/%(id)s&#x27;</div><div class=""> Given a field, you can access the attributes set in its definition:</div><div class=""> &gt;&gt;&gt; print db.person.name.type</div><div class=""> string</div><div class=""> &gt;&gt;&gt; print db.person.name.unique</div><div class=""> False</div><div class=""> &gt;&gt;&gt; print db.person.name.notnull</div><div class=""> False</div><div class=""> &gt;&gt;&gt; print db.person.name.length</div><div class=""> 32</div><div class=""> ``:code</div><div class=""> </div><div class=""> including its parent table, tablename, and parent connection:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.person.name._table == db.person</div><div class=""> True</div><div class=""> &gt;&gt;&gt; db.person.name._tablename == &#x27;person&#x27;</div><div class=""> True</div><div class=""> &gt;&gt;&gt; db.person.name._db == db</div><div class=""> True</div><div class=""> ``:code</div><div class=""> </div><div class="insert">A field also has methods. Some of them are used to build queries and we will see<span class="highlight"></span> them later.</div><div class=""> A special method of the field object is ``validate`` and it calls the validators for the field.</div><div class=""> </div><div class=""> ``</div><div class=""> print db.person.name.validate(&#x27;John&#x27;)</div><div class=""> ``</div><div class=""> </div><div class=""> which returns a tuple ``(value, error)``. ``error`` is ``None`` if the input passes validation.</div><div class=""> </div><div class=""> ### Migrations</div><div class=""> ``migrations``:inxx</div><div class=""> </div><div class=""> ``define_table`` checks whether or not the corresponding table exists. If it does not, it generates the SQL to create it and executes the SQL. If the table does exist but differs from the one being defined, it generates the SQL to alter the table and executes it. If a field has changed type but not name, it will try to convert the data (If you do not want this, you need to redefine the table twice, the first time, letting web2py drop the field by removing it, and the second time adding the newly defined field so that web2py can create it.). If the table exists and matches the current definition, it will leave it alone. In all cases it will create the ``db.person`` object that represents the table.</div><div class=""> </div><div class=""> We refer to this behavior as a &quot;migration&quot;. web2py logs all migrations and migration attempts in the file &quot;databases/sql.log&quot;.</div><div class=""> </div><div class=""> The first argument of ``define_table`` is always the table name. The other unnamed arguments are the fields (Field). The function also takes an optional last argument called &quot;migrate&quot; which must be referred to explicitly by name as in:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;), migrate=&#x27;person.table&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can even build a query (using operators like ==, !=, &lt;, &gt;, &lt;=, &gt;=, like, bel</div><div class=""> When you call ``db`` with a query, you define a set of records. You can store it in a variable ``s`` and write:</div><div class=""> </div><div class=""> ``Set``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; s = db(q)</div><div class=""> ``:code</div><div class=""> </div><div class=""> Notice that no database query has been performed so far. DAL + Query simply define a set of records in this db that match the query.</div><div class=""> web2py determines from the query which table (or tables) are involved and, in fact, there is no need to specify that.</div><div class=""> </div><div class=""> ### ``select``</div><div class=""> </div><div class=""> Given a Set, ``s``, you can fetch the records with the command ``select``:</div><div class=""> </div><div class=""> ``Rows``:inxx ``select``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows = s.select()</div><div class=""> ``:code</div><div class=""> </div><div class=""> ``Row``:inxx</div><div class="insert">It returns an iterable object of class ``gluon.sql.Rows`` whose elements are Row objects. ``gluon.sql.Row`` objects act like dictionaries, but their elements can also be accessed as attributes, like ``gluon.storage.Storage``.The former differ from the latter because its values are read<span class="highlight">-</span>only.</div><div class=""> </div><div class=""> The Rows object allows looping over the result of the select and printing the selected field values for each row:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in rows:</div><div class="">         print row.id, row.name</div><div class=""> 1 Alex</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can do all the steps in one statement:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db(db.person.name==&#x27;Alex&#x27;).select():</div><div class="">         print row.name</div><div class=""> Alex</div><div class=""> ``:code</div><div class=""> </div><div class=""> ``ALL``:inxx</div><div class=""> </div><div class=""> The select command can take arguments. All unnamed arguments are interpreted as the names of the fields that you want to fetch. For example, you can be explicit on fetching field &quot;id&quot; and field &quot;name&quot;:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db().select(db.person.id, db.person.name):</div><div class=""> Here we will consider the same example as in the previous subsection. In particu</div><div class=""> One can define a ``total_price`` virtual field as</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.item.total_price = Field.Virtual(</div><div class="">     lambda row: row.item.unit_price*row.item.quantity)</div><div class=""> ``:code</div><div class=""> </div><div class=""> i.e. by simply defining a new field ``total_price`` to be a ``Field.Virtual``. The only argument of the constructor is a function that takes a row and returns the computed values.</div><div class=""> </div><div class=""> A virtual field defined as the one above is automatically computed for all records when the records are selected:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db(db.item).select(): print row.total_price</div><div class=""> ``</div><div class=""> </div><div class=""> It is also possible to define method fields which are calculated on-demand, when called.</div><div class=""> For example:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.item.discounted_total = Field.Method(lambda row, discount=0.0: \</div><div class="insert">       row.item.unit_price*row.item.quantity*(1.0-discount/100<span class="highlight"></span>))</div><div class=""> ``:code</div><div class=""> </div><div class=""> In this case ``row.discounted_total`` is not a value but a function. The function takes the same arguments as the function passed to the ``Method`` constructor except for ``row`` which is implicit (think of it as ``self`` for rows objects).</div><div class=""> </div><div class=""> The lazy field in the example above allows one to compute the total price for each ``item``:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db(db.item).select(): print row.discounted_total()</div><div class=""> ``</div><div class=""> </div><div class=""> And it also allows to pass an optional ``discount`` percentage (15%):</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db(db.item).select(): print row.discounted_total(15)</div><div class=""> ``</div><div class=""> </div><div class=""> Virtual and Method fields can also be defined in place when a table is defined:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;item&#x27;,</div><div class=""> that produces a ``SELECT/OPTION`` multiple drop-box in forms.</div><div class=""> Also notice that this field gets a default ``represent`` attribute which represents the list of references as a comma-separated list of formatted references. This is used in read forms and ``SQLTABLE``s.</div><div class=""> </div><div class=""> -----</div><div class=""> While ``list:reference`` has a default validator and a default representation, ``list:integer`` and ``list:string`` do not. So these two need an ``IS_IN_SET`` or an ``IS_IN_DB`` validator if you want to use them in forms.</div><div class=""> -----</div><div class=""> </div><div class=""> </div><div class=""> ### Other operators</div><div class=""> </div><div class=""> web2py has other operators that provide an API to access equivalent SQL operators.</div><div class=""> Let&#x27;s define another table &quot;log&quot; to store security events, their event_time and severity, where the severity is an integer number.</div><div class=""> </div><div class=""> ``date``:inxx ``datetime``:inxx ``time``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;log&#x27;, Field(&#x27;event&#x27;),</div><div class="">                            Field(&#x27;event_time&#x27;, &#x27;datetime&#x27;),</div><div class="">                            Field(&#x27;severity&#x27;, &#x27;integer&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class=""> As before, insert a few events, a &quot;port scan&quot;, an &quot;xss injection&quot; and an &quot;unauthorized login&quot;.</div><div class="insert">For the sake of the example, you can log events with the same event_time but with different severities (1, 2, <span class="highlight">and </span>3 respectively).</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; import datetime</div><div class=""> &gt;&gt;&gt; now = datetime.datetime.now()</div><div class=""> &gt;&gt;&gt; print db.log.insert(</div><div class="">         event=&#x27;port scan&#x27;, event_time=now, severity=1)</div><div class=""> 1</div><div class=""> &gt;&gt;&gt; print db.log.insert(</div><div class="">         event=&#x27;xss injection&#x27;, event_time=now, severity=2)</div><div class=""> 2</div><div class=""> &gt;&gt;&gt; print db.log.insert(</div><div class="">         event=&#x27;unauthorized login&#x27;, event_time=now, severity=3)</div><div class=""> 3</div><div class=""> ``:code</div><div class=""> </div><div class=""> #### ``like``, ``regexp``, ``startswith``, ``contains``, ``upper``, ``lower``</div><div class=""> </div><div class=""> ``like``:inxx ``startswith``:inxx ``regexp``:inxx</div><div class=""> ``contains``:inxx ``upper``:inxx ``lower``:inxx</div><div class=""> </div><div class=""> Fields have a like operator that you can use to match strings:</div><div class=""> In the following example, you see a controller that caches a select on the previ</div><div class=""> ``</div><div class=""> def cache_db_select():</div><div class="">     logs = db().select(db.log.ALL, cache=(cache.ram, 60))</div><div class="">     return dict(logs=logs)</div><div class=""> ``:code</div><div class=""> </div><div class=""> ``cacheable``:inxx</div><div class=""> </div><div class=""> The ``select`` method has an optional ``cacheable`` argument, normally set to ``False``. When ``cacheable=True`` the resulting ``Rows`` is serializable but The ``Row``s lack ``update_record`` and ``delete_record`` methods.</div><div class=""> </div><div class=""> If you do not need these methods you can speed up selects a lot by setting the cacheable attribute:</div><div class=""> </div><div class=""> ``</div><div class=""> rows = db(query).select(cacheable=True)</div><div class=""> ``:code</div><div class=""> </div><div class=""> -------</div><div class=""> The results of a ``select`` are normally complex, un-pickleable objects; they cannot be stored in a session and cannot be cached in any other way than the one explained here unless the ``cache`` attribute is set or ``cacheable=True``.</div><div class=""> -------</div><div class=""> </div><div class="insert">When the ``cache`` argument is set but ``cacheable=False`` (default) only the database results are cached, not the actual Rows object. When the ``cache`` argument is used in conjunction with ``cacheable=True`` the entire Rows object is cached and this results in much <span class="highlight">f</span>aster caching:</div><div class=""> </div><div class=""> ``</div><div class=""> rows = db(query).select(cache=(cache.ram,3600),cacheable=True)</div><div class=""> ``:code</div><div class=""> </div><div class=""> ### Self-Reference and aliases</div><div class=""> </div><div class=""> ``self reference``:inxx</div><div class=""> ``alias``:inxx</div><div class=""> It is possible to define tables with fields that refer to themselves, here is an example:</div><div class=""> ``reference table``:inxx</div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;,</div><div class="">     Field(&#x27;name&#x27;),</div><div class="">     Field(&#x27;father_id&#x27;, &#x27;reference person&#x27;),</div><div class="">     Field(&#x27;mother_id&#x27;, &#x27;reference person&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class=""> Notice that the alternative notation of using a table object as field type will fail in this case, because it uses a variable ``db.person`` before it is defined:</div><div class=""> ``</div><div class=""> db.stored_item._enable_record_versioning()</div><div class=""> or in a more verbose syntax:</div><div class=""> </div><div class=""> ``</div><div class=""> db.stored_item._enable_record_versioning(</div><div class="">     archive_db = db,</div><div class="">     archive_name = &#x27;stored_item_archive&#x27;,</div><div class="">     current_record = &#x27;current_record&#x27;,</div><div class="">     is_active = &#x27;is_active&#x27;)</div><div class=""> ``</div><div class=""> </div><div class=""> The ``archive_db=db`` tells web2py to store the archive table in the same database as the ``stored_item`` table. The ``archive_name`` sets the name for the archive table. The archive table has the same fields as the original table ``stored_item`` except that unique fields are no longer unique (because it needs to store multiple versions) and has an extra field which name is specified by ``current_record`` and which is a reference to the current record in the ``stored_item`` table.</div><div class=""> </div><div class=""> When records are deleted, they are not really deleted. A deleted record is copied in the ``stored_item_archive`` table (like when it is modified) and the ``is_active`` field is set to False. By enabling record versioning web2py sets a ``custom_filter`` on this table that hides all fields in table ``stored_item`` where the ``is_active`` field is set to False. The ``is_active`` parameter in the ``_enable_record_versioning`` method allows to specify the name of the field used by the ``custom_filter`` to determine if the field was deleted or not.</div><div class=""> </div><div class=""> ``custom_filter``s are ignored by the appadmin interface.</div><div class=""> </div><div class=""> #### Common fields and multi-tenancy</div><div class=""> ``common fields``:inxx</div><div class=""> ``multi tenancy``:inxx</div><div class=""> </div><div class="insert">``db._common_fields`` is a list of fields that should belong to all the tables. This list can also contain tables and it i<span class="highlight"></span>s understood as all fields from the table. For example occasionally you find yourself in need to add a signature to all your tables but the ```auth`` tables. In this case, after you ``db.define_tables()`` but before defining any other table, insert</div><div class=""> </div><div class=""> ``</div><div class=""> db._common_fields.append(auth.signature)</div><div class=""> ``</div><div class=""> </div><div class=""> One field is special: &quot;request_tenant&quot;.</div><div class=""> This field does not exist but you can create it and add it to any of your tables (or them all):</div><div class=""> </div><div class=""> ``</div><div class=""> db._common_fields.append(Field(&#x27;request_tenant&#x27;,</div><div class="">     default=request.env.http_host,writable=False))</div><div class=""> ``</div><div class=""> </div><div class=""> For every table with a field called ``db._request_tenant``, all records for all queries are always automatically filtered by:</div><div class=""> </div><div class=""> ``</div><div class=""> db.table.request_tenant == db.table.request_tenant.default</div><div class=""> ``:code</div><div class=""> </div><div class=""> and for every record insert, this field is set to the default value.</div><div class=""> the uri string is then parsed in more detail by the adapter itself.</div><div class=""> For any adapter you can replace the driver with a different one:</div><div class=""> </div><div class=""> ``</div><div class=""> from gluon.dal import MySQLAdapter</div><div class=""> MySQLAdapter.driver = mysqldb</div><div class=""> ``</div><div class=""> </div><div class=""> and you can specify optional driver arguments and adapter arguments:</div><div class=""> </div><div class=""> ``</div><div class=""> db =DAL(..., driver_args={}, adapter_args={})</div><div class=""> ``</div><div class=""> </div><div class=""> </div><div class=""> #### Gotchas</div><div class=""> </div><div class=""> **SQLite** does not support dropping and altering columns. That means that web2py migrations will work up to a point. If you delete a field from a table, the column will remain in the database but be invisible to web2py. If you decide to reinstate the column, web2py will try re-create it and fail. In this case you must set ``fake_migrate=True`` so that metadata is rebuilt without attempting to add the column again. Also, for the same reason, **SQLite** is not aware of any change of column type. If you insert a number in a string field, it will be stored as string. If you later change the model and replace the type &quot;string&quot; with type &quot;integer&quot;, SQLite will continue to keep the number as a string and this may cause problem when you try to extract the data.</div><div class=""> </div><div class=""> **MySQL** does not support multiple ALTER TABLE within a single transaction. This means that any migration process is broken into multiple commits. If something happens that causes a failure it is possible to break a migration (the web2py metadata are no longer in sync with the actual table structure in the database). This is unfortunate but it can be prevented (migrate one table at the time) or it can be fixed a posteriori (revert the web2py model to what corresponds to the table structure in database, set ``fake_migrate=True`` and after the metadata has been rebuilt, set ``fake_migrate=False`` and migrate the table again).</div><div class=""> </div><div class="insert">**Google SQL** has the same problems as MySQL and more. In particular table metadata itself must be stored in the database in a table that is not migrated by web2py. This is because Google App Engine has a read<span class="highlight">-</span>only file system. Web2py migrations in Google:SQL combined with the MySQL issue described above can result in metadata corruption. Again, this can be prevented (my migrating the table at once and then setting migrate=False so that the metadata table is not accessed any more) or it can fixed a posteriori (my accessing the database using the Google dashboard and deleting any corrupted entry from the table called ``web2py_filesystem``.</div><div class=""> </div><div class=""> ``limitby``:inxx</div><div class=""> **MSSQL** does not support the SQL OFFSET keyword. Therefore the database cannot do pagination. When doing a ``limitby=(a,b)`` web2py will fetch the first ``b`` rows and discard the first ``a``. This may result in a considerable overhead when compared with other database engines.</div><div class=""> </div><div class=""> **Oracle** also does not support pagination. It does not support neither the OFFSET nor the LIMIT keywords. Web2py achieves pagination by translating a ``db(...).select(limitby=(a,b))`` into a complex three-way nested select (as suggested by official Oracle documentation). This works for simple select but may break for complex selects involving aliased fields and or joins.</div><div class=""> </div><div class=""> **MSSQL** has problems with circular references in tables that have ONDELETE CASCADE. This is an MSSSQL bug and you work around it by setting the ondelete attribute for all reference fields to &quot;NO ACTION&quot;. You can also do it once and for all before you define tables:</div><div class=""> </div><div class=""> ``</div><div class=""> db = DAL(&#x27;mssql://....&#x27;)</div><div class=""> for key in [&#x27;reference&#x27;,&#x27;reference FK&#x27;]:</div><div class="">     db._adapter.types[key]=db._adapter.types[key].replace(</div><div class="">         &#x27;%(on_delete_action)s&#x27;,&#x27;NO ACTION&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> **MSSQL** also has problems with arguments passed to the DISTINCT keyword and therefore</div><div class="">  while this works,</div><div class=""> </div><div class=""> ``</div><div class=""> db(query).select(distinct=True)</div><div class=""> ``</div><div class=""> </div><div class=""> this does not</div><div class=""> </div><div class=""> ``</div><div class=""> db(query).select(distinct=db.mytable.myfield)</div><div class=""> ``</div><div class=""> </div><div class="insert">**Google NoSQL (Datastore)** does not allow joins, left joins, aggregates, expression, OR involving more than one table, the <span class="highlight">‘</span>like<span class="highlight">’ operator searches</span> in &quot;text<span class="highlight"></span>&quot; fields. Transactions are limited and not provided automatically by web2py (you need to use the Google API ``run_in_transaction`` which you can look up in the Google App Engine documentation online). Google also limits the number of records you can retrieve in each one query (1000 at the time of writing). On the Google datastore record IDs are integer but they are not sequential. While on SQL the &quot;list:string&quot; type is mapped into a &quot;text&quot; type, on the Google Datastore it is mapped into a ``ListStringProperty``. Similarly &quot;list:integer&quot; and &quot;list:reference&quot; are mapped into &quot;ListProperty&quot;. This makes searches for content inside these fields types are more efficient on Google NoSQL than on SQL databases.</div></div></div>
    <div class="span6"><div class="diff"><div class=""> - ``ondelete`` translates into the &quot;ON DELETE&quot; SQL statement. By default it is set to &quot;CASCADE&quot;. This tells the database that when it deletes a record, it should also delete all records that refer to it. To disable this feature, set ``ondelete`` to &quot;NO ACTION&quot; or &quot;SET NULL&quot;.</div><div class=""> - ``notnull=True`` translates into the &quot;NOT NULL&quot; SQL statement. It prevents the database from inserting null values for the field.</div><div class=""> - ``unique=True`` translates into the &quot;UNIQUE&quot; SQL statement and it makes sure that values of this field are unique within the table. It is enforced at the database level.</div><div class=""> - ``uploadfield`` applies only to fields of type &quot;upload&quot;. A field of type &quot;upload&quot; stores the name of a file saved somewhere else, by default on the filesystem under the application &quot;uploads/&quot; folder. If ``uploadfield`` is set, then the file is stored in a blob field within the same table and the value of ``uploadfield`` is the name of the blob field. This will be discussed in more detail later in the context of SQLFORM.</div><div class=""> - ``uploadfolder`` defaults to the application&#x27;s &quot;uploads/&quot; folder. If set to a different path, files will uploaded to a different folder. For example, uploadfolder=os.path.join(request.folder,&#x27;static/temp&#x27;) will upload files to the web2py/applications/myapp/static/temp folder.</div><div class=""> - ``uploadseparate`` if set to True will upload files under different subfolders of the &#x27;&#x27;uploadfolder&#x27;&#x27; folder. This is optimized to avoid too many files under the same folder/subfolder. ATTENTION: You cannot change the value of ``uploadseparate`` from True to False without breaking the system. web2py either uses the separate subfolders or it does not. Changing the behavior after files have been uploaded will prevent web2py from being able to retrieve those files. If this happens it is possible to move files and fix the problem but this is not described here.</div><div class=""> - ``uploadfs`` allows you specify a different file system where to upload files, including an Amazon S3 storage or a remote FTP storage. This option requires PyFileSystem installed. ``uploadfs`` must point to ``PyFileSystem``. ``PyFileSystem``:inxx ``uploadfs``:idxx</div><div class=""> - ``widget`` must be one of the available widget objects, including custom widgets, for example: ``SQLFORM.widgets.string.widget``. A list of available widgets will be discussed later. Each field type has a default widget.</div><div class="delete">- ``label`` is a string (or something that can be serialized to a string) that contains the label to be used for this field in auto<span class="highlight"></span>generated forms.</div><div class=""> - ``comment``  is a string (or something that can be serialized to a string) that contains a comment associated with this field, and will be displayed to the right of the input field in the autogenerated forms.</div><div class=""> - ``writable`` if a field is writable, it can be edited in autogenerated create and update forms.</div><div class="delete">- ``readable`` if a field is readable, it will be visible in read<span class="highlight"></span>only forms. If a field is neither readable nor writable, it will not be displayed in create and update forms.</div><div class=""> - ``update`` contains the default value for this field when the record is updated.</div><div class=""> - ``compute`` is an optional function. If a record is inserted or updated, the compute function will be executed and the field will be populated with the function result. The record is passed to the compute function as a ``dict``, and the dict will not include the current value of that, or any other compute field.</div><div class=""> - ``authorize`` can be used to require access control on the corresponding field, for &quot;upload&quot; fields only. It will be discussed more in detail in the context of Authentication and Authorization.</div><div class=""> - ``autodelete`` determines if the corresponding uploaded file should be deleted when the record referencing the file is deleted. For &quot;upload&quot; fields only.</div><div class=""> - ``represent`` can be None or can point to a function that takes a field value and returns an alternate representation for the field value. Examples:</div><div class=""> ``</div><div class=""> db.mytable.name.represent = lambda name,row: name.capitalize()</div><div class=""> db.mytable.other_id.represent = lambda id,row: row.myfield</div><div class=""> db.mytable.some_uploadfield.represent = lambda value,row: \</div><div class="">     A(&#x27;get it&#x27;, _href=URL(&#x27;download&#x27;, args=value))</div><div class=""> ``:code</div><div class=""> </div><div class=""> ``blob``:inxx</div><div class=""> &quot;blob&quot; fields are also special. By default, binary data is encoded in base64 before being stored into the actual database field, and it is decoded when extracted. This has the negative effect of using 25% more storage space than necessary in blob fields, but has two advantages. On average it reduces the amount of data communicated between web2py and the database server, and it makes the communication independent of back-end-specific escaping conventions.</div><div class=""> </div><div class=""> Most attributes of fields and tables can be modified after they are defined:</div><div class=""> </div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;,Field(&#x27;name&#x27;,default=&#x27;&#x27;),format=&#x27;%(name)s&#x27;)</div><div class=""> db.person._format = &#x27;%(name)s/%(id)s&#x27;</div><div class=""> Given a field, you can access the attributes set in its definition:</div><div class=""> &gt;&gt;&gt; print db.person.name.type</div><div class=""> string</div><div class=""> &gt;&gt;&gt; print db.person.name.unique</div><div class=""> False</div><div class=""> &gt;&gt;&gt; print db.person.name.notnull</div><div class=""> False</div><div class=""> &gt;&gt;&gt; print db.person.name.length</div><div class=""> 32</div><div class=""> ``:code</div><div class=""> </div><div class=""> including its parent table, tablename, and parent connection:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.person.name._table == db.person</div><div class=""> True</div><div class=""> &gt;&gt;&gt; db.person.name._tablename == &#x27;person&#x27;</div><div class=""> True</div><div class=""> &gt;&gt;&gt; db.person.name._db == db</div><div class=""> True</div><div class=""> ``:code</div><div class=""> </div><div class="delete">A field also has methods. Some of them are used to build queries and we will see<span class="highlight">m</span> them later.</div><div class=""> A special method of the field object is ``validate`` and it calls the validators for the field.</div><div class=""> </div><div class=""> ``</div><div class=""> print db.person.name.validate(&#x27;John&#x27;)</div><div class=""> ``</div><div class=""> </div><div class=""> which returns a tuple ``(value, error)``. ``error`` is ``None`` if the input passes validation.</div><div class=""> </div><div class=""> ### Migrations</div><div class=""> ``migrations``:inxx</div><div class=""> </div><div class=""> ``define_table`` checks whether or not the corresponding table exists. If it does not, it generates the SQL to create it and executes the SQL. If the table does exist but differs from the one being defined, it generates the SQL to alter the table and executes it. If a field has changed type but not name, it will try to convert the data (If you do not want this, you need to redefine the table twice, the first time, letting web2py drop the field by removing it, and the second time adding the newly defined field so that web2py can create it.). If the table exists and matches the current definition, it will leave it alone. In all cases it will create the ``db.person`` object that represents the table.</div><div class=""> </div><div class=""> We refer to this behavior as a &quot;migration&quot;. web2py logs all migrations and migration attempts in the file &quot;databases/sql.log&quot;.</div><div class=""> </div><div class=""> The first argument of ``define_table`` is always the table name. The other unnamed arguments are the fields (Field). The function also takes an optional last argument called &quot;migrate&quot; which must be referred to explicitly by name as in:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;), migrate=&#x27;person.table&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can even build a query (using operators like ==, !=, &lt;, &gt;, &lt;=, &gt;=, like, bel</div><div class=""> When you call ``db`` with a query, you define a set of records. You can store it in a variable ``s`` and write:</div><div class=""> </div><div class=""> ``Set``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; s = db(q)</div><div class=""> ``:code</div><div class=""> </div><div class=""> Notice that no database query has been performed so far. DAL + Query simply define a set of records in this db that match the query.</div><div class=""> web2py determines from the query which table (or tables) are involved and, in fact, there is no need to specify that.</div><div class=""> </div><div class=""> ### ``select``</div><div class=""> </div><div class=""> Given a Set, ``s``, you can fetch the records with the command ``select``:</div><div class=""> </div><div class=""> ``Rows``:inxx ``select``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows = s.select()</div><div class=""> ``:code</div><div class=""> </div><div class=""> ``Row``:inxx</div><div class="delete">It returns an iterable object of class ``gluon.sql.Rows`` whose elements are Row objects. ``gluon.sql.Row`` objects act like dictionaries, but their elements can also be accessed as attributes, like ``gluon.storage.Storage``.The former differ from the latter because its values are read<span class="highlight"></span>only.</div><div class=""> </div><div class=""> The Rows object allows looping over the result of the select and printing the selected field values for each row:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in rows:</div><div class="">         print row.id, row.name</div><div class=""> 1 Alex</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can do all the steps in one statement:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db(db.person.name==&#x27;Alex&#x27;).select():</div><div class="">         print row.name</div><div class=""> Alex</div><div class=""> ``:code</div><div class=""> </div><div class=""> ``ALL``:inxx</div><div class=""> </div><div class=""> The select command can take arguments. All unnamed arguments are interpreted as the names of the fields that you want to fetch. For example, you can be explicit on fetching field &quot;id&quot; and field &quot;name&quot;:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db().select(db.person.id, db.person.name):</div><div class=""> Here we will consider the same example as in the previous subsection. In particu</div><div class=""> One can define a ``total_price`` virtual field as</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.item.total_price = Field.Virtual(</div><div class="">     lambda row: row.item.unit_price*row.item.quantity)</div><div class=""> ``:code</div><div class=""> </div><div class=""> i.e. by simply defining a new field ``total_price`` to be a ``Field.Virtual``. The only argument of the constructor is a function that takes a row and returns the computed values.</div><div class=""> </div><div class=""> A virtual field defined as the one above is automatically computed for all records when the records are selected:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db(db.item).select(): print row.total_price</div><div class=""> ``</div><div class=""> </div><div class=""> It is also possible to define method fields which are calculated on-demand, when called.</div><div class=""> For example:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.item.discounted_total = Field.Method(lambda row, discount=0.0: \</div><div class="delete">       row.item.unit_price*row.item.quantity*(1.0-discount/100<span class="highlight">.0</span>))</div><div class=""> ``:code</div><div class=""> </div><div class=""> In this case ``row.discounted_total`` is not a value but a function. The function takes the same arguments as the function passed to the ``Method`` constructor except for ``row`` which is implicit (think of it as ``self`` for rows objects).</div><div class=""> </div><div class=""> The lazy field in the example above allows one to compute the total price for each ``item``:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db(db.item).select(): print row.discounted_total()</div><div class=""> ``</div><div class=""> </div><div class=""> And it also allows to pass an optional ``discount`` percentage (15%):</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db(db.item).select(): print row.discounted_total(15)</div><div class=""> ``</div><div class=""> </div><div class=""> Virtual and Method fields can also be defined in place when a table is defined:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;item&#x27;,</div><div class=""> that produces a ``SELECT/OPTION`` multiple drop-box in forms.</div><div class=""> Also notice that this field gets a default ``represent`` attribute which represents the list of references as a comma-separated list of formatted references. This is used in read forms and ``SQLTABLE``s.</div><div class=""> </div><div class=""> -----</div><div class=""> While ``list:reference`` has a default validator and a default representation, ``list:integer`` and ``list:string`` do not. So these two need an ``IS_IN_SET`` or an ``IS_IN_DB`` validator if you want to use them in forms.</div><div class=""> -----</div><div class=""> </div><div class=""> </div><div class=""> ### Other operators</div><div class=""> </div><div class=""> web2py has other operators that provide an API to access equivalent SQL operators.</div><div class=""> Let&#x27;s define another table &quot;log&quot; to store security events, their event_time and severity, where the severity is an integer number.</div><div class=""> </div><div class=""> ``date``:inxx ``datetime``:inxx ``time``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;log&#x27;, Field(&#x27;event&#x27;),</div><div class="">                            Field(&#x27;event_time&#x27;, &#x27;datetime&#x27;),</div><div class="">                            Field(&#x27;severity&#x27;, &#x27;integer&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class=""> As before, insert a few events, a &quot;port scan&quot;, an &quot;xss injection&quot; and an &quot;unauthorized login&quot;.</div><div class="delete">For the sake of the example, you can log events with the same event_time but with different severities (1, 2, <span class="highlight"></span>3 respectively).</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; import datetime</div><div class=""> &gt;&gt;&gt; now = datetime.datetime.now()</div><div class=""> &gt;&gt;&gt; print db.log.insert(</div><div class="">         event=&#x27;port scan&#x27;, event_time=now, severity=1)</div><div class=""> 1</div><div class=""> &gt;&gt;&gt; print db.log.insert(</div><div class="">         event=&#x27;xss injection&#x27;, event_time=now, severity=2)</div><div class=""> 2</div><div class=""> &gt;&gt;&gt; print db.log.insert(</div><div class="">         event=&#x27;unauthorized login&#x27;, event_time=now, severity=3)</div><div class=""> 3</div><div class=""> ``:code</div><div class=""> </div><div class=""> #### ``like``, ``regexp``, ``startswith``, ``contains``, ``upper``, ``lower``</div><div class=""> </div><div class=""> ``like``:inxx ``startswith``:inxx ``regexp``:inxx</div><div class=""> ``contains``:inxx ``upper``:inxx ``lower``:inxx</div><div class=""> </div><div class=""> Fields have a like operator that you can use to match strings:</div><div class=""> In the following example, you see a controller that caches a select on the previ</div><div class=""> ``</div><div class=""> def cache_db_select():</div><div class="">     logs = db().select(db.log.ALL, cache=(cache.ram, 60))</div><div class="">     return dict(logs=logs)</div><div class=""> ``:code</div><div class=""> </div><div class=""> ``cacheable``:inxx</div><div class=""> </div><div class=""> The ``select`` method has an optional ``cacheable`` argument, normally set to ``False``. When ``cacheable=True`` the resulting ``Rows`` is serializable but The ``Row``s lack ``update_record`` and ``delete_record`` methods.</div><div class=""> </div><div class=""> If you do not need these methods you can speed up selects a lot by setting the cacheable attribute:</div><div class=""> </div><div class=""> ``</div><div class=""> rows = db(query).select(cacheable=True)</div><div class=""> ``:code</div><div class=""> </div><div class=""> -------</div><div class=""> The results of a ``select`` are normally complex, un-pickleable objects; they cannot be stored in a session and cannot be cached in any other way than the one explained here unless the ``cache`` attribute is set or ``cacheable=True``.</div><div class=""> -------</div><div class=""> </div><div class="delete">When the ``cache`` argument is set but ``cacheable=False`` (default) only the database results are cached, not the actual Rows object. When the ``cache`` argument is used in conjunction with ``cacheable=True`` the entire Rows object is cached and this results in much <span class="highlight">b</span>aster caching:</div><div class=""> </div><div class=""> ``</div><div class=""> rows = db(query).select(cache=(cache.ram,3600),cacheable=True)</div><div class=""> ``:code</div><div class=""> </div><div class=""> ### Self-Reference and aliases</div><div class=""> </div><div class=""> ``self reference``:inxx</div><div class=""> ``alias``:inxx</div><div class=""> It is possible to define tables with fields that refer to themselves, here is an example:</div><div class=""> ``reference table``:inxx</div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;,</div><div class="">     Field(&#x27;name&#x27;),</div><div class="">     Field(&#x27;father_id&#x27;, &#x27;reference person&#x27;),</div><div class="">     Field(&#x27;mother_id&#x27;, &#x27;reference person&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class=""> Notice that the alternative notation of using a table object as field type will fail in this case, because it uses a variable ``db.person`` before it is defined:</div><div class=""> ``</div><div class=""> db.stored_item._enable_record_versioning()</div><div class=""> or in a more verbose syntax:</div><div class=""> </div><div class=""> ``</div><div class=""> db.stored_item._enable_record_versioning(</div><div class="">     archive_db = db,</div><div class="">     archive_name = &#x27;stored_item_archive&#x27;,</div><div class="">     current_record = &#x27;current_record&#x27;,</div><div class="">     is_active = &#x27;is_active&#x27;)</div><div class=""> ``</div><div class=""> </div><div class=""> The ``archive_db=db`` tells web2py to store the archive table in the same database as the ``stored_item`` table. The ``archive_name`` sets the name for the archive table. The archive table has the same fields as the original table ``stored_item`` except that unique fields are no longer unique (because it needs to store multiple versions) and has an extra field which name is specified by ``current_record`` and which is a reference to the current record in the ``stored_item`` table.</div><div class=""> </div><div class=""> When records are deleted, they are not really deleted. A deleted record is copied in the ``stored_item_archive`` table (like when it is modified) and the ``is_active`` field is set to False. By enabling record versioning web2py sets a ``custom_filter`` on this table that hides all fields in table ``stored_item`` where the ``is_active`` field is set to False. The ``is_active`` parameter in the ``_enable_record_versioning`` method allows to specify the name of the field used by the ``custom_filter`` to determine if the field was deleted or not.</div><div class=""> </div><div class=""> ``custom_filter``s are ignored by the appadmin interface.</div><div class=""> </div><div class=""> #### Common fields and multi-tenancy</div><div class=""> ``common fields``:inxx</div><div class=""> ``multi tenancy``:inxx</div><div class=""> </div><div class="delete">``db._common_fields`` is a list of fields that should belong to all the tables. This list can also contain tables and it i<span class="highlight">t i</span>s understood as all fields from the table. For example occasionally you find yourself in need to add a signature to all your tables but the ```auth`` tables. In this case, after you ``db.define_tables()`` but before defining any other table, insert</div><div class=""> </div><div class=""> ``</div><div class=""> db._common_fields.append(auth.signature)</div><div class=""> ``</div><div class=""> </div><div class=""> One field is special: &quot;request_tenant&quot;.</div><div class=""> This field does not exist but you can create it and add it to any of your tables (or them all):</div><div class=""> </div><div class=""> ``</div><div class=""> db._common_fields.append(Field(&#x27;request_tenant&#x27;,</div><div class="">     default=request.env.http_host,writable=False))</div><div class=""> ``</div><div class=""> </div><div class=""> For every table with a field called ``db._request_tenant``, all records for all queries are always automatically filtered by:</div><div class=""> </div><div class=""> ``</div><div class=""> db.table.request_tenant == db.table.request_tenant.default</div><div class=""> ``:code</div><div class=""> </div><div class=""> and for every record insert, this field is set to the default value.</div><div class=""> the uri string is then parsed in more detail by the adapter itself.</div><div class=""> For any adapter you can replace the driver with a different one:</div><div class=""> </div><div class=""> ``</div><div class=""> from gluon.dal import MySQLAdapter</div><div class=""> MySQLAdapter.driver = mysqldb</div><div class=""> ``</div><div class=""> </div><div class=""> and you can specify optional driver arguments and adapter arguments:</div><div class=""> </div><div class=""> ``</div><div class=""> db =DAL(..., driver_args={}, adapter_args={})</div><div class=""> ``</div><div class=""> </div><div class=""> </div><div class=""> #### Gotchas</div><div class=""> </div><div class=""> **SQLite** does not support dropping and altering columns. That means that web2py migrations will work up to a point. If you delete a field from a table, the column will remain in the database but be invisible to web2py. If you decide to reinstate the column, web2py will try re-create it and fail. In this case you must set ``fake_migrate=True`` so that metadata is rebuilt without attempting to add the column again. Also, for the same reason, **SQLite** is not aware of any change of column type. If you insert a number in a string field, it will be stored as string. If you later change the model and replace the type &quot;string&quot; with type &quot;integer&quot;, SQLite will continue to keep the number as a string and this may cause problem when you try to extract the data.</div><div class=""> </div><div class=""> **MySQL** does not support multiple ALTER TABLE within a single transaction. This means that any migration process is broken into multiple commits. If something happens that causes a failure it is possible to break a migration (the web2py metadata are no longer in sync with the actual table structure in the database). This is unfortunate but it can be prevented (migrate one table at the time) or it can be fixed a posteriori (revert the web2py model to what corresponds to the table structure in database, set ``fake_migrate=True`` and after the metadata has been rebuilt, set ``fake_migrate=False`` and migrate the table again).</div><div class=""> </div><div class="delete">**Google SQL** has the same problems as MySQL and more. In particular table metadata itself must be stored in the database in a table that is not migrated by web2py. This is because Google App Engine has a read<span class="highlight"></span>only file system. Web2py migrations in Google:SQL combined with the MySQL issue described above can result in metadata corruption. Again, this can be prevented (my migrating the table at once and then setting migrate=False so that the metadata table is not accessed any more) or it can fixed a posteriori (my accessing the database using the Google dashboard and deleting any corrupted entry from the table called ``web2py_filesystem``.</div><div class=""> </div><div class=""> ``limitby``:inxx</div><div class=""> **MSSQL** does not support the SQL OFFSET keyword. Therefore the database cannot do pagination. When doing a ``limitby=(a,b)`` web2py will fetch the first ``b`` rows and discard the first ``a``. This may result in a considerable overhead when compared with other database engines.</div><div class=""> </div><div class=""> **Oracle** also does not support pagination. It does not support neither the OFFSET nor the LIMIT keywords. Web2py achieves pagination by translating a ``db(...).select(limitby=(a,b))`` into a complex three-way nested select (as suggested by official Oracle documentation). This works for simple select but may break for complex selects involving aliased fields and or joins.</div><div class=""> </div><div class=""> **MSSQL** has problems with circular references in tables that have ONDELETE CASCADE. This is an MSSSQL bug and you work around it by setting the ondelete attribute for all reference fields to &quot;NO ACTION&quot;. You can also do it once and for all before you define tables:</div><div class=""> </div><div class=""> ``</div><div class=""> db = DAL(&#x27;mssql://....&#x27;)</div><div class=""> for key in [&#x27;reference&#x27;,&#x27;reference FK&#x27;]:</div><div class="">     db._adapter.types[key]=db._adapter.types[key].replace(</div><div class="">         &#x27;%(on_delete_action)s&#x27;,&#x27;NO ACTION&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> **MSSQL** also has problems with arguments passed to the DISTINCT keyword and therefore</div><div class="">  while this works,</div><div class=""> </div><div class=""> ``</div><div class=""> db(query).select(distinct=True)</div><div class=""> ``</div><div class=""> </div><div class=""> this does not</div><div class=""> </div><div class=""> ``</div><div class=""> db(query).select(distinct=db.mytable.myfield)</div><div class=""> ``</div><div class=""> </div><div class="delete">**Google NoSQL (Datastore)** does not allow joins, left joins, aggregates, expression, OR involving more than one table, the <span class="highlight"></span>like<span class="highlight"> operator and search</span> in &quot;text<span class="highlight">&quot;</span>&quot; fields. Transactions are limited and not provided automatically by web2py (you need to use the Google API ``run_in_transaction`` which you can look up in the Google App Engine documentation online). Google also limits the number of records you can retrieve in each one query (1000 at the time of writing). On the Google datastore record IDs are integer but they are not sequential. While on SQL the &quot;list:string&quot; type is mapped into a &quot;text&quot; type, on the Google Datastore it is mapped into a ``ListStringProperty``. Similarly &quot;list:integer&quot; and &quot;list:reference&quot; are mapped into &quot;ListProperty&quot;. This makes searches for content inside these fields types are more efficient on Google NoSQL than on SQL databases.</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/952ca92844a2c9638b9a652f0d0e536f391e9fe1">952ca92</a><ul><li>Date : 2013-01-29</li><li>Fix negation parenthesis and add precdence explanation.</li></ul></li></ul>
<div class="row-fluid" id="com_952ca92844a2c9638b9a652f0d0e536f391e9fe1">
    <div class="span6"><div class="diff"><div class=""> or by explicit negation with the &quot;``~``&quot; unary operator:</div><div class=""> ``</div><div class="insert">&gt;&gt;&gt; rows = db(<span class="highlight">~</span>(<span class="highlight"></span>db.person.name==&#x27;Alex&#x27;) | (db.person.id&gt;3)).select()</div><div class=""> &gt;&gt;&gt; for row in rows: print row.id, row.name</div><div class=""> 2 Bob</div><div class=""> 3 Carl</div><div class=""> ``:code</div><div class=""> </div><div class=""> ------</div><div class="insert">Due to Python restrictions in overloading &quot;``and``&quot; and &quot;``or``&quot; operators, these cannot be used in forming queries.  The binary operators &quot;``&amp;``&quot; and &quot;``|``&quot; must be used instead. Note that these operators (unlike &quot;``and``&quot; and &quot;``or``&quot;) have higher precedence than comparison operators, so the &quot;extra&quot; parentheses in the above examples are mandatory.<span class="highlight"> Similarly, the unary operator &quot;``~``&quot; has higher precedence than comparison operators, so ``~``-negated comparisons must also be parenthesized.</span></div><div class=""> ------</div></div></div>
    <div class="span6"><div class="diff"><div class=""> or by explicit negation with the &quot;``~``&quot; unary operator:</div><div class=""> ``</div><div class="delete">&gt;&gt;&gt; rows = db(<span class="highlight"></span>(<span class="highlight">~</span>db.person.name==&#x27;Alex&#x27;) | (db.person.id&gt;3)).select()</div><div class=""> &gt;&gt;&gt; for row in rows: print row.id, row.name</div><div class=""> 2 Bob</div><div class=""> 3 Carl</div><div class=""> ``:code</div><div class=""> </div><div class=""> ------</div><div class="delete">Due to Python restrictions in overloading &quot;``and``&quot; and &quot;``or``&quot; operators, these cannot be used in forming queries.  The binary operators &quot;``&amp;``&quot; and &quot;``|``&quot; must be used instead. Note that these operators (unlike &quot;``and``&quot; and &quot;``or``&quot;) have higher precedence than comparison operators, so the &quot;extra&quot; parentheses in the above examples are mandatory.<span class="highlight"></span></div><div class=""> ------</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/61df3d2ca87986edb19cb65ecd11696c82ad913a">61df3d2</a><ul><li>Date : 2013-01-21</li><li>fixed 100-&gt;100.0, thanks Niphlod</li></ul></li></ul>
<div class="row-fluid" id="com_61df3d2ca87986edb19cb65ecd11696c82ad913a">
    <div class="span6"><div class="diff"><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.item.discounted_total = Field.Method(lambda row, discount=0.0: \</div><div class="insert">       row.item.unit_price*row.item.quantity*(1.0-discount/100<span class="highlight">.0</span>))</div><div class=""> ``:code</div></div></div>
    <div class="span6"><div class="diff"><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.item.discounted_total = Field.Method(lambda row, discount=0.0: \</div><div class="delete">       row.item.unit_price*row.item.quantity*(1.0-discount/100<span class="highlight"></span>))</div><div class=""> ``:code</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/e706d40e67287f56741ecf730ef44a7e3ac66054">e706d40</a><ul><li>Date : 2013-01-20</li><li>edited acknowledgements</li></ul></li></ul>
<div class="row-fluid" id="com_e706d40e67287f56741ecf730ef44a7e3ac66054">
    <div class="span6"><div class="diff"><div class="insert">web2py comes with a Database Abstraction Layer (DAL), an API that maps Python objects into database objects such as queries, tables, and records. The DAL dynamically generates the SQL in real time using the specified dialect for the database back end, so that you do not have to write SQL code or learn different SQL dialects (the term SQL is used generically), and the application will be portable among different types of databases. At the time of this writing, the supported databases are SQLite (which comes with Python and thus web2py), PostgreSQL, MySQL, Oracle, MSSQL, FireBird, DB2, Informix, Ingres, <span class="highlight">MongoDB, </span>and the Google App Engine (SQL and NoSQL). Experimentally we support more databases. Please check on the web2py web site and mailing list for more recent adapters. Google NoSQL is treated as a particular case in Chapter 13.</div><div class=""> </div><div class=""> The Windows binary distribution works out of the box with SQLite and MySQL. The Mac binary distribution works out of the box with SQLite.</div><div class=""> To use any other database back-end, run from the source distribution and install the appropriate driver for the required back end.</div><div class=""> ``database drivers``:inxx</div><div class=""> </div><div class=""> Once the proper driver is installed, start web2py from source, and it will find the driver. Here is a list of drivers:</div><div class=""> </div><div class=""> ``DAL``:inxx ``SQLite``:inxx ``MySQL``:inxx ``PostgresSQL``:inxx ``Oracle``:inxx ``MSSQL``:inxx ``FireBird``:inxx ``DB2``:inxx ``Informix``:inxx ``Sybase``:inxx ``Teradata``:inxx ``MongoDB``:inxx ``CouchDB``:inxx ``SAPDB``:inxx ``Cubrid``:inxx</div><div class=""> </div><div class=""> ----------</div><div class=""> database | drivers (source)</div><div class=""> SQLite | sqlite3 or pysqlite2 or zxJDBC ``zxjdbc``:cite  (on Jython)</div><div class=""> PostgreSQL | psycopg2 ``psycopg2``:cite  or pg8000 ``pg8000``:cite or zxJDBC ``zxjdbc``:cite  (on Jython)</div><div class=""> MySQL | pymysql ``pymysql``:cite or MySQLdb ``mysqldb``:cite</div><div class=""> Oracle | cx_Oracle ``cxoracle``:cite</div><div class=""> MSSQL | pyodbc ``pyodbc``:cite</div><div class=""> FireBird | kinterbasdb ``kinterbasdb``:cite or fdb or pyodbc</div><div class=""> DB2 | pyodbc ``pyodbc``:cite</div><div class=""> Informix | informixdb ``informixdb``:cite</div><div class=""> Ingres | ingresdbi ``ingresdbi``:cite</div><div class=""> Not all of them are relevant for every field. &quot;length&quot; is relevant only for fiel</div><div class=""> ``time`` | ``IS_TIME()``</div><div class=""> ``datetime`` | ``IS_DATETIME()``</div><div class=""> ``password`` | ``None``</div><div class=""> ``upload`` | ``None``</div><div class=""> ``reference &lt;table&gt;``  | ``IS_IN_DB(db,table.field,format)``</div><div class=""> ``list:string`` | ``None``</div><div class=""> ``list:integer`` | ``None``</div><div class=""> ``list:reference &lt;table&gt;`` | ``IS_IN_DB(db,table.field,format,multiple=True)``</div><div class=""> ``json`` | ``IS_JSON()``</div><div class=""> ``bigint`` | ``None``</div><div class=""> ``big-id`` | ``None``</div><div class=""> ``big-reference`` | ``None``</div><div class=""> ---------</div><div class=""> </div><div class=""> Decimal requires and returns values as ``Decimal`` objects, as defined in the Python ``decimal`` module. SQLite does not handle the ``decimal`` type so internally we treat it as a ``double``. The (n,m) are the number of digits in total and the number of digits after the decimal point respectively.</div><div class=""> </div><div class=""> The ``big-id`` and, ``big-reference`` are only supported by some of the database engines and are experimental. They are not normally used as field types unless for legacy tables, however, the DAL constructor has a ``bigint_id`` argument that when set to ``True`` makes the ``id`` fields and ``reference`` fields ``big-id`` and ``big-reference`` respectively.</div><div class=""> </div><div class=""> The ``list:`` fields are special because they are designed to take advantage of certain denormalization features on NoSQL (in the case of Google App Engine NoSQL, the field types ``ListProperty`` and ``StringListProperty``) and back-port them all the other supported relational databases. On relational databases lists are stored as a ``text`` field. The items are separated by a ``|`` and each ``|`` in string item is escaped as a ``||``. They are discussed in their own section.</div><div class=""> </div><div class="insert">+The ``json`` field type is pretty much explanatory. It can store any json serializable object. It is designed to work specifically for MongoDB and backported to the other database adapters for portability.</div><div class="insert">+</div><div class=""> -------</div><div class=""> Notice that ``requires=...`` is enforced at the level of forms, ``required=True`` is enforced at the level of the DAL (insert), while ``notnull``, ``unique`` and ``ondelete`` are enforced at the level of the database. While they sometimes may seem redundant, it is important to maintain the distinction when programming with the DAL.</div><div class=""> -------</div></div></div>
    <div class="span6"><div class="diff"><div class="delete">web2py comes with a Database Abstraction Layer (DAL), an API that maps Python objects into database objects such as queries, tables, and records. The DAL dynamically generates the SQL in real time using the specified dialect for the database back end, so that you do not have to write SQL code or learn different SQL dialects (the term SQL is used generically), and the application will be portable among different types of databases. At the time of this writing, the supported databases are SQLite (which comes with Python and thus web2py), PostgreSQL, MySQL, Oracle, MSSQL, FireBird, DB2, Informix, Ingres, <span class="highlight"></span>and the Google App Engine (SQL and NoSQL). Experimentally we support more databases. Please check on the web2py web site and mailing list for more recent adapters. Google NoSQL is treated as a particular case in Chapter 13.</div><div class=""> </div><div class=""> The Windows binary distribution works out of the box with SQLite and MySQL. The Mac binary distribution works out of the box with SQLite.</div><div class=""> To use any other database back-end, run from the source distribution and install the appropriate driver for the required back end.</div><div class=""> ``database drivers``:inxx</div><div class=""> </div><div class=""> Once the proper driver is installed, start web2py from source, and it will find the driver. Here is a list of drivers:</div><div class=""> </div><div class=""> ``DAL``:inxx ``SQLite``:inxx ``MySQL``:inxx ``PostgresSQL``:inxx ``Oracle``:inxx ``MSSQL``:inxx ``FireBird``:inxx ``DB2``:inxx ``Informix``:inxx ``Sybase``:inxx ``Teradata``:inxx ``MongoDB``:inxx ``CouchDB``:inxx ``SAPDB``:inxx ``Cubrid``:inxx</div><div class=""> </div><div class=""> ----------</div><div class=""> database | drivers (source)</div><div class=""> SQLite | sqlite3 or pysqlite2 or zxJDBC ``zxjdbc``:cite  (on Jython)</div><div class=""> PostgreSQL | psycopg2 ``psycopg2``:cite  or pg8000 ``pg8000``:cite or zxJDBC ``zxjdbc``:cite  (on Jython)</div><div class=""> MySQL | pymysql ``pymysql``:cite or MySQLdb ``mysqldb``:cite</div><div class=""> Oracle | cx_Oracle ``cxoracle``:cite</div><div class=""> MSSQL | pyodbc ``pyodbc``:cite</div><div class=""> FireBird | kinterbasdb ``kinterbasdb``:cite or fdb or pyodbc</div><div class=""> DB2 | pyodbc ``pyodbc``:cite</div><div class=""> Informix | informixdb ``informixdb``:cite</div><div class=""> Ingres | ingresdbi ``ingresdbi``:cite</div><div class=""> Not all of them are relevant for every field. &quot;length&quot; is relevant only for fiel</div><div class=""> ``time`` | ``IS_TIME()``</div><div class=""> ``datetime`` | ``IS_DATETIME()``</div><div class=""> ``password`` | ``None``</div><div class=""> ``upload`` | ``None``</div><div class=""> ``reference &lt;table&gt;``  | ``IS_IN_DB(db,table.field,format)``</div><div class=""> ``list:string`` | ``None``</div><div class=""> ``list:integer`` | ``None``</div><div class=""> ``list:reference &lt;table&gt;`` | ``IS_IN_DB(db,table.field,format,multiple=True)``</div><div class=""> ``json`` | ``IS_JSON()``</div><div class=""> ``bigint`` | ``None``</div><div class=""> ``big-id`` | ``None``</div><div class=""> ``big-reference`` | ``None``</div><div class=""> ---------</div><div class=""> </div><div class=""> Decimal requires and returns values as ``Decimal`` objects, as defined in the Python ``decimal`` module. SQLite does not handle the ``decimal`` type so internally we treat it as a ``double``. The (n,m) are the number of digits in total and the number of digits after the decimal point respectively.</div><div class=""> </div><div class=""> The ``big-id`` and, ``big-reference`` are only supported by some of the database engines and are experimental. They are not normally used as field types unless for legacy tables, however, the DAL constructor has a ``bigint_id`` argument that when set to ``True`` makes the ``id`` fields and ``reference`` fields ``big-id`` and ``big-reference`` respectively.</div><div class=""> </div><div class=""> The ``list:`` fields are special because they are designed to take advantage of certain denormalization features on NoSQL (in the case of Google App Engine NoSQL, the field types ``ListProperty`` and ``StringListProperty``) and back-port them all the other supported relational databases. On relational databases lists are stored as a ``text`` field. The items are separated by a ``|`` and each ``|`` in string item is escaped as a ``||``. They are discussed in their own section.</div><div class=""> </div><div class=""> -------</div><div class=""> Notice that ``requires=...`` is enforced at the level of forms, ``required=True`` is enforced at the level of the DAL (insert), while ``notnull``, ``unique`` and ``ondelete`` are enforced at the level of the database. While they sometimes may seem redundant, it is important to maintain the distinction when programming with the DAL.</div><div class=""> -------</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/c8d32ea975d0ab9fd251f1eb7b72313744e31ad5">c8d32ea</a><ul><li>Date : 2013-01-20</li><li>typos</li></ul></li></ul>
<div class="row-fluid" id="com_c8d32ea975d0ab9fd251f1eb7b72313744e31ad5">
    <div class="span6"><div class="diff"><div class="insert">+The value of migrate is the filename (in the &quot;databases&quot; folder for the application) where web2py stores internal migration information for this table. </div><div class="insert">+These files are very important and should never be removed while the corresponding tables exist.  In cases where a table has been dropped and the corresponding file still exist, it can be removed manually. By default, migrate is set to True. This causes web2py to generate the filename from a hash of the connection string. If migrate is set to False, the migration is not performed, and web2py assumes that the table exists in the datastore and it contains (at least) the fields listed in ``define_table``.</div><div class=""> The best practice is to give an explicit name to the migrate table.</div></div></div>
    <div class="span6"><div class="diff"><div class="delete">-The value of migrate is the filename (in the &quot;databases&quot; folder for the application) where web2py stores internal migration information for this table. These files are very important and should never be removed except when the entire database is dropped. In this case, the &quot;.table&quot; files have to be removed manually. By default, migrate is set to True. This causes web2py to generate the filename from a hash of the connection string. If migrate is set to False, the migration is not performed, and web2py assumes that the table exists in the datastore and it contains (at least) the fields listed in ``define_table``.</div><div class=""> The best practice is to give an explicit name to the migrate table.</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/06e7da447e109c9d4b50fdcb1d7c2e1b55850375">06e7da4</a><ul><li>Date : 2013-01-16</li><li>added db_codec parameter description</li></ul></li></ul>
<div class="row-fluid" id="com_06e7da447e109c9d4b50fdcb1d7c2e1b55850375">
    <div class="span6"><div class="diff"><div class="insert">+Notice that by default web2py uses utf8 character encoding for databases. If you work with existing databases that behave differently, you have to change it with the optional parameter ``db_codec`` like</div><div class="insert">+</div><div class="insert">+``</div><div class="insert">+db = DAL(&#x27;...&#x27;, db_codec=&#x27;latin1&#x27;)</div><div class="insert">+``:code</div><div class="insert">+</div><div class="insert">+otherwise you&#x27;ll get UnicodeDecodeErrors tickets.</div><div class="insert">+</div><div class=""> #### Connection pooling</div><div class=""> ``connection pooling``:inxx</div></div></div>
    <div class="span6"><div class="diff"><div class=""> #### Connection pooling</div><div class=""> ``connection pooling``:inxx</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/8fe4c65f991a23ce43305114e46fb6cf8e96a386">8fe4c65</a><ul><li>Date : 2013-01-15</li><li>typos and PythonAnywhere polishings</li></ul></li></ul>
<div class="row-fluid" id="com_8fe4c65f991a23ce43305114e46fb6cf8e96a386">
    <div class="span6"><div class="diff"><div class=""> In this case, the return values are not parsed or transformed by the DAL, and the format depends on the specific database driver. This usage with selects is normally not needed, but it is more common with indexes.</div><div class="insert">``executesql`` takes <span class="highlight">f</span>o<span class="highlight">ur</span> optional arguments: ``placeholders``<span class="highlight">,</span> ``as_dict``<span class="highlight">, ``fields`` and ``colnames``. </span></div><div class=""> ``placeholders`` is an optional</div><div class=""> sequence of values to be substituted in</div><div class=""> or, if supported by the DB driver, a dictionary with keys</div><div class=""> matching named placeholders in your SQL.</div><div class=""> </div><div class=""> If ``as_dict`` is set to True,</div><div class=""> and the results cursor returned by the DB driver will be</div><div class=""> converted to a sequence of dictionaries keyed with the db</div><div class=""> field names.  Results returned with ``as_dict = True ``are</div><div class=""> the same as those returned when applying **.as_list()** to a normal select.</div><div class=""> ``</div><div class=""> [{field1: value1, field2: value2}, {field1: value1b, field2: value2b}]</div><div class=""> ``:code</div><div class=""> </div><div class=""> The ``fields`` argument is a list of DAL Field objects that match the</div><div class=""> fields returned from the DB. The Field objects should be part of one or</div><div class=""> more Table objects defined on the DAL object. The ``fields`` list can</div><div class=""> include one or more DAL Table objects in addition to or instead of</div><div class=""> including Field objects, or it can be just a single table (not in a</div><div class=""> list). In that case, the Field objects will be extracted from the</div><div class=""> table(s).</div><div class=""> </div><div class=""> Instead of specifying the ``fields`` argument, the ``colnames`` argument</div><div class=""> can be specified as a list of field names in tablename.fieldname format.</div><div class=""> Again, these should represent tables and fields defined on the DAL</div><div class=""> object.</div><div class=""> </div><div class=""> It is also possible to specify both ``fields`` and the associated</div><div class=""> ``colnames``. In that case, ``fields`` can also include DAL Expression</div><div class=""> objects in addition to Field objects. For Field objects in &quot;fields&quot;,</div><div class=""> the associated ``colnames`` must still be in tablename.fieldname format.</div><div class=""> For Expression objects in ``fields``, the associated ``colnames`` can</div><div class=""> be any arbitrary labels.</div><div class=""> </div><div class=""> The SQLTABLE constructor takes the following optional arguments:</div><div class=""> - ``headers`` a dictionary mapping field names to their labels to be used as headers (default to ``{}``). It can also be an instruction. Currently we support ``headers=&#x27;fieldname:capitalize&#x27;``.</div><div class=""> - ``truncate`` the number of characters for truncating long values in the table (default is 16)</div><div class=""> - ``columns`` the list of fieldnames to be shown as columns (in tablename.fieldname format).</div><div class="">    Those not listed are not displayed (defaults to all).</div><div class=""> - ``**attributes`` generic helper attributes to be passed to the most external TABLE object.</div><div class=""> </div><div class=""> Here is an example:</div><div class=""> ``</div><div class=""> {{extend &#x27;layout.html&#x27;}}</div><div class=""> &lt;h1&gt;Records&lt;/h1&gt;</div><div class=""> {{=SQLTABLE(rows,</div><div class="">      headers=&#x27;fieldname:capitalize&#x27;,</div><div class="">      truncate=100,</div><div class="">      upload=URL(&#x27;download&#x27;))</div><div class=""> }}</div><div class=""> ``:code</div><div class=""> </div><div class=""> ``SQLFORM.grid``:inxx ``SQLFORM.smartgrid``:inxx</div><div class=""> </div><div class=""> ------</div><div class="insert">``SQLTABLE`` is useful but there are t<span class="highlight">im</span>es when one needs more. ``SQLFORM.grid`` is an extension of SQLTABLE that creates a table with search features and pagination, as well as ability to open detailed records, create, edit and delete records. ``SQLFORM.smartgrid`` is a further generalization that allows all of the above but also creates buttons to access referencing records.</div><div class=""> ------</div></div></div>
    <div class="span6"><div class="diff"><div class=""> In this case, the return values are not parsed or transformed by the DAL, and the format depends on the specific database driver. This usage with selects is normally not needed, but it is more common with indexes.</div><div class="delete">``executesql`` takes <span class="highlight">tw</span>o<span class="highlight"></span> optional arguments: ``placeholders``<span class="highlight"> and</span> ``as_dict``<span class="highlight"></span></div><div class=""> ``placeholders`` is an optional</div><div class=""> sequence of values to be substituted in</div><div class=""> or, if supported by the DB driver, a dictionary with keys</div><div class=""> matching named placeholders in your SQL.</div><div class=""> </div><div class=""> If ``as_dict`` is set to True,</div><div class=""> and the results cursor returned by the DB driver will be</div><div class=""> converted to a sequence of dictionaries keyed with the db</div><div class=""> field names.  Results returned with ``as_dict = True ``are</div><div class=""> the same as those returned when applying **.as_list()** to a normal select.</div><div class=""> ``</div><div class=""> [{field1: value1, field2: value2}, {field1: value1b, field2: value2b}]</div><div class=""> ``:code</div><div class=""> </div><div class="delete">-``executesql`` have two optional arguments: ``fields`` and ``colnames``.</div><div class="delete">-</div><div class=""> The ``fields`` argument is a list of DAL Field objects that match the</div><div class=""> fields returned from the DB. The Field objects should be part of one or</div><div class=""> more Table objects defined on the DAL object. The ``fields`` list can</div><div class=""> include one or more DAL Table objects in addition to or instead of</div><div class=""> including Field objects, or it can be just a single table (not in a</div><div class=""> list). In that case, the Field objects will be extracted from the</div><div class=""> table(s).</div><div class=""> </div><div class=""> Instead of specifying the ``fields`` argument, the ``colnames`` argument</div><div class=""> can be specified as a list of field names in tablename.fieldname format.</div><div class=""> Again, these should represent tables and fields defined on the DAL</div><div class=""> object.</div><div class=""> </div><div class=""> It is also possible to specify both ``fields`` and the associated</div><div class=""> ``colnames``. In that case, ``fields`` can also include DAL Expression</div><div class=""> objects in addition to Field objects. For Field objects in &quot;fields&quot;,</div><div class=""> the associated ``colnames`` must still be in tablename.fieldname format.</div><div class=""> For Expression objects in ``fields``, the associated ``colnames`` can</div><div class=""> be any arbitrary labels.</div><div class=""> </div><div class=""> The SQLTABLE constructor takes the following optional arguments:</div><div class=""> - ``headers`` a dictionary mapping field names to their labels to be used as headers (default to ``{}``). It can also be an instruction. Currently we support ``headers=&#x27;fieldname:capitalize&#x27;``.</div><div class=""> - ``truncate`` the number of characters for truncating long values in the table (default is 16)</div><div class=""> - ``columns`` the list of fieldnames to be shown as columns (in tablename.fieldname format).</div><div class="">    Those not listed are not displayed (defaults to all).</div><div class=""> - ``**attributes`` generic helper attributes to be passed to the most external TABLE object.</div><div class=""> </div><div class=""> Here is an example:</div><div class=""> ``</div><div class=""> {{extend &#x27;layout.html&#x27;}}</div><div class=""> &lt;h1&gt;Records&lt;/h1&gt;</div><div class=""> {{=SQLTABLE(rows,</div><div class="">      headers=&#x27;fieldname:capitalize&#x27;,</div><div class="">      truncate=100,</div><div class="">      upload=URL(&#x27;download&#x27;))</div><div class=""> }}</div><div class=""> ``:code</div><div class=""> </div><div class=""> ``SQLFORM.grid``:inxx ``SQLFORM.smartgrid``:inxx</div><div class=""> </div><div class=""> ------</div><div class="delete">``SQLTABLE`` is useful but there are t<span class="highlight">yp</span>es when one needs more. ``SQLFORM.grid`` is an extension of SQLTABLE that creates a table with search features and pagination, as well as ability to open detailed records, create, edit and delete records. ``SQLFORM.smartgrid`` is a further generalization that allows all of the above but also creates buttons to access referencing records.</div><div class=""> ------</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/6feb49d47e68077713b316da11a6533e1d639add">6feb49d</a><ul><li>Date : 2013-01-11</li><li>May spell fixes, thanks Denes</li></ul></li></ul>
<div class="row-fluid" id="com_6feb49d47e68077713b316da11a6533e1d639add">
    <div class="span6"><div class="diff"><div class=""> ``</div><div class="insert">db = DAL(<span class="highlight">&#x27;</span>...<span class="highlight">&#x27;</span>, do_connect=False)</div><div class=""> ``:code</div><div class=""> </div><div class="insert">In this case you will be able to call ``_select``, ``_insert``, ``_update``, and ``_delete`` to generate SQL but <span class="highlight">not </span>call ``select``, ``insert``, ``update``, and ``delete``. In most of the cases you can use ``do_connect=False`` even without having the required database drivers.</div><div class=""> </div><div class=""> #### Connection pooling</div><div class=""> ``connection pooling``:inxx</div><div class=""> </div><div class=""> The second argument of the DAL constructor is the ``pool_size``; it defaults to zero.</div><div class=""> </div><div class=""> As it is rather slow to establish a new database connection for each request, web2py implements a mechanism for connection pooling. Once a connection is established and the page has been served and the transaction completed, the connection is not closed but goes into a pool. When the next http request arrives, web2py tries to obtain a connection from the pool and use that for the new transaction. If there are no available connections in the pool, a new connection is established.</div><div class=""> </div><div class=""> The ``pool_size`` parameter is ignored by SQLite and Google App Engine.</div><div class=""> </div><div class=""> Connections in the pools are shared sequentially among threads, in the sense that they may be used by two different but not simultaneous threads. There is only one pool for each web2py process.</div><div class=""> </div><div class=""> When web2py starts, the pool is always empty. The pool grows up to the minimum between the value of ``pool_size`` and the max number of concurrent requests. This means that if ``pool_size=10`` but our server never receives more than 5 concurrent requests, then the actual pool size will only grow to 5. If ``pool_size=0`` then connection pooling is not used.</div><div class=""> </div><div class=""> Connection pooling is ignored for SQLite, since it would not yield any benefit.</div><div class=""> </div><div class=""> #### Connection failures</div><div class=""> </div><div class=""> If web2py fails to connect to the database it waits 1 seconds and tries again up to 5 times before declaring a failure. In case of connection pooling it is possible that a pooled connection that stays open but unused for some time is closed by the database end. Thanks to the retry feature web2py tries to re-establish these dropped connections.</div><div class=""> </div><div class=""> It is also possible to build queries using in-place logical operators:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; query = db.person.name!=&#x27;Alex&#x27;</div><div class=""> &gt;&gt;&gt; query &amp;= db.person.id&gt;3</div><div class=""> &gt;&gt;&gt; query |= db.person.name==&#x27;John&#x27;</div><div class=""> ``</div><div class=""> </div><div class=""> #### ``count``, ``isempty``, ``delete``, ``update``</div><div class=""> </div><div class=""> You can count records in a set:</div><div class=""> </div><div class=""> ``count``:inxx ``isempty``:inxx</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; print db(db.person.id &gt; 0).count()</div><div class=""> 3</div><div class=""> ``:code</div><div class=""> </div><div class=""> Notice that ``count`` takes an optional ``distinct`` argument which defaults to False, and it works very much like the same argument for ``select``. ``count`` has also a ``cache`` argument that works very much like the equivalent argument of the ``select`` method.</div><div class=""> </div><div class="insert">Sometimes you may need to check i<span class="highlight">f</span> a table is empty. A more efficient way than counting is using the ``isempty`` method:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; print db(db.person.id &gt; 0).isempty()</div><div class=""> False</div><div class=""> ``:code</div><div class=""> </div><div class=""> or equivalently:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; print db(db.person).isempty()</div><div class=""> False</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can delete records in a set:</div><div class=""> </div><div class=""> ``delete``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db(db.person.id &gt; 3).delete()</div><div class=""> ``:code</div><div class=""> </div><div class=""> Max</div><div class=""> Tim</div><div class=""> &gt;&gt;&gt; print rows2</div><div class=""> person.name</div><div class=""> John</div><div class=""> Tim</div><div class=""> ``</div><div class=""> </div><div class=""> </div><div class=""> You can do a union of the records in two set of rows:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows3 = rows1 &amp; rows2</div><div class=""> &gt;&gt;&gt; print rows3</div><div class=""> name</div><div class=""> Max</div><div class=""> Tim</div><div class=""> John</div><div class=""> Tim</div><div class=""> ``:code</div><div class=""> </div><div class="insert">You can do a union of the records <span class="highlight"></span>removing duplicates:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows3 = rows1 | rows2</div><div class=""> &gt;&gt;&gt; print rows3</div><div class=""> name</div><div class=""> Max</div><div class=""> Tim</div><div class=""> John</div><div class=""> ``:code</div><div class=""> </div><div class=""> #### ``find``, ``exclude``, ``sort``</div><div class=""> ``find``:inxx ``exclude``:inxx ``sort``:inxx</div><div class=""> </div><div class=""> There are times when one needs to perform two selects and one contains a subset of a previous select. In this case it is pointless to access the database again. The ``find``, ``exclude`` and ``sort`` objects allow you to manipulate a Rows objects and generate another one without accessing the database. More specifically:</div><div class=""> - ``find`` returns a new set of Rows filtered by a condition and leaves the original unchanged.</div><div class=""> - ``exclude`` returns a new set of Rows filtered by a condition and removes them from the original Rows.</div><div class=""> - ``sort`` returns a new set of Rows sorted by a condition and leaves the original unchanged.</div><div class=""> </div><div class=""> All these methods take a single argument, a function that acts on each individual row.</div><div class=""> </div><div class=""> Max</div><div class=""> &gt;&gt;&gt; print len(rows)</div><div class=""> 2</div><div class=""> &gt;&gt;&gt; for row in rows.sort(lambda row: row.name):</div><div class="">         print row.name</div><div class=""> Alex</div><div class=""> John</div><div class=""> ``:code</div><div class=""> </div><div class=""> They can be combined:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows = db(db.person).select()</div><div class=""> &gt;&gt;&gt; rows = rows.find(</div><div class="">         lambda row: &#x27;x&#x27; in row.name).sort(</div><div class="">             lambda row: row.name)</div><div class=""> &gt;&gt;&gt; for row in rows:</div><div class="">         print row.name</div><div class=""> Alex</div><div class=""> Max</div><div class=""> ``:code</div><div class=""> </div><div class="insert">Sort takes an optional argument ``reverse=True`` w<span class="highlight"></span>i<span class="highlight">t</span>h <span class="highlight">the</span> obvious meaning.</div><div class=""> </div><div class=""> The ``find`` method as an optional limitby argument with the same syntax and functionality as the Set select ``method``.</div><div class=""> </div><div class=""> </div><div class=""> </div><div class=""> ### Other methods</div><div class=""> </div><div class=""> #### ``update_or_insert``</div><div class=""> ``update_or_insert``:inxx</div><div class=""> </div><div class=""> Some times you need to perform an insert only if there is no record with the same values as those being inserted.</div><div class=""> This can be done with</div><div class=""> </div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;,Field(&#x27;name&#x27;),Field(&#x27;birthplace&#x27;))</div><div class=""> db.person.update_or_insert(name=&#x27;John&#x27;,birthplace=&#x27;Chicago&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> The record will be inserted only of there is no other user called John born in Chicago.</div><div class=""> </div><div class=""> The SQL IN operator is realized via the belongs method which returns true when t</div><div class=""> ``belongs``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db(db.log.severity.belongs((1, 2))).select():</div><div class="">         print row.event</div><div class=""> port scan</div><div class=""> xss injection</div><div class=""> ``:code</div><div class=""> </div><div class=""> The DAL also allows a nested select as the argument of the belongs operator. The only caveat is that the nested select has to be a ``_select``, not a ``select``, and only one field has to be selected explicitly, the one that defines the set.</div><div class=""> </div><div class=""> ``nested select``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; bad_days = db(db.log.severity==3)._select(db.log.event_time)</div><div class=""> &gt;&gt;&gt; for row in db(db.log.event_time.belongs(bad_days)).select():</div><div class="">         print row.event</div><div class=""> port scan</div><div class=""> xss injection</div><div class=""> unauthorized login</div><div class=""> ``:code</div><div class=""> </div><div class="insert">In those cases where a nested select is required and the loo<span class="highlight">k</span>-up field is a reference we can also use a query as argument. For example:</div><div class=""> </div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;,Field(&#x27;name&#x27;))</div><div class=""> db.define_table(&#x27;thing&#x27;,Field(&#x27;owner&#x27;),Field(&#x27;owner&#x27;,&#x27;reference thing&#x27;))</div><div class=""> db(db.thing.owner.belongs(db.person.name==&#x27;Jonathan&#x27;)).select()</div><div class=""> ``:code</div><div class=""> </div><div class=""> In this case it is obvious that the next select only needs the field referenced by the ``db.thing.owner`` field so we do not need the more verbose ``_select`` notation.</div><div class=""> </div><div class=""> ``nested_select``:inxx</div><div class=""> </div><div class=""> A nested select can also be used as insert/update value but in this case the syntax is different:</div><div class=""> </div><div class=""> ``</div><div class=""> lazy = db(db.person.name==&#x27;Jonathan&#x27;).nested_select(db.person.id)</div><div class=""> db(db.thing.id==1).update(owner = lazy)</div><div class=""> ``:code</div><div class=""> </div><div class=""> In this case ``lazy`` is a nested expression that computes the ``id`` of person &quot;Jonathan&quot;. The two lines result in one single SQL query.</div><div class=""> </div><div class=""> db(query, ignore_common_filters=True).select(...)</div><div class=""> ``SQLCustomType``:inxx</div><div class=""> </div><div class=""> It is possible to define new/custom field types. For example we consider here the example if a field that contains binary data in compressed form:</div><div class=""> </div><div class=""> ``</div><div class=""> from gluon.dal import SQLCustomType</div><div class=""> import zlib</div><div class=""> </div><div class=""> compressed = SQLCustomType(</div><div class="">      type =&#x27;text&#x27;,</div><div class="">      native=&#x27;text&#x27;,</div><div class="">      encoder =(lambda x: zlib.compress(x or &#x27;&#x27;)),</div><div class="">      decoder = (lambda x: zlib.decompress(x))</div><div class=""> )</div><div class=""> </div><div class=""> db.define_table(&#x27;example&#x27;, Field(&#x27;data&#x27;,type=compressed))</div><div class=""> ``:code</div><div class=""> </div><div class=""> ``SQLCustomType`` is a field type factory. Its ``type`` argument must be one of the standard web2py types. It tells web2py how to treat the field values at the web2py level. ``native`` is the name of the field as far as the database is concerned. Allowed names depend on the database engine. ``encoder`` is an optional transformation function applied when the data is stored and ``decoder`` is the optional reversed transformation function.</div><div class=""> </div><div class="insert">This feature is marked as experimental. In practice i<span class="highlight">t</span> has been in web2py for a long time and it works but it can make the code not portable, for example when the native type is database specific. It does not work on Google App Engine NoSQL.</div><div class=""> </div><div class=""> #### Using DAL without define tables</div><div class=""> </div><div class=""> The DAL can be used from any Python program simply by doing this:</div><div class=""> </div><div class=""> ``</div><div class=""> from gluon import DAL, Field</div><div class=""> db = DAL(&#x27;sqlite://storage.sqlite&#x27;,folder=&#x27;path/to/app/databases&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> i.e. import the DAL, Field, connect and specify the folder which contains the .table files (the app/databases folder).</div><div class=""> </div><div class=""> To access the data and its attributes we still have to define all the tables we are going to access with ``db.define_tables(...)``.</div><div class=""> </div><div class=""> If we just need access to the data but not to the web2py table attributes, we get away without re-defining the tables but simply asking web2py to read the necessary info from the metadata in the .table files:</div><div class=""> </div><div class=""> ``</div><div class=""> from gluon import DAL, Field</div><div class=""> db = DAL(&#x27;sqlite://storage.sqlite&#x27;,folder=&#x27;path/to/app/databases&#x27;,</div><div class="">          auto_import=True))</div><div class=""> For any adapter you can replace the driver with a different one:</div><div class=""> from gluon.dal import MySQLAdapter</div><div class=""> MySQLAdapter.driver = mysqldb</div><div class=""> ``</div><div class=""> </div><div class=""> and you can specify optional driver arguments and adapter arguments:</div><div class=""> </div><div class=""> ``</div><div class=""> db =DAL(..., driver_args={}, adapter_args={})</div><div class=""> ``</div><div class=""> </div><div class=""> </div><div class=""> #### Gotchas</div><div class=""> </div><div class=""> **SQLite** does not support dropping and altering columns. That means that web2py migrations will work up to a point. If you delete a field from a table, the column will remain in the database but be invisible to web2py. If you decide to reinstate the column, web2py will try re-create it and fail. In this case you must set ``fake_migrate=True`` so that metadata is rebuilt without attempting to add the column again. Also, for the same reason, **SQLite** is not aware of any change of column type. If you insert a number in a string field, it will be stored as string. If you later change the model and replace the type &quot;string&quot; with type &quot;integer&quot;, SQLite will continue to keep the number as a string and this may cause problem when you try to extract the data.</div><div class=""> </div><div class=""> **MySQL** does not support multiple ALTER TABLE within a single transaction. This means that any migration process is broken into multiple commits. If something happens that causes a failure it is possible to break a migration (the web2py metadata are no longer in sync with the actual table structure in the database). This is unfortunate but it can be prevented (migrate one table at the time) or it can be fixed a posteriori (revert the web2py model to what corresponds to the table structure in database, set ``fake_migrate=True`` and after the metadata has been rebuilt, set ``fake_migrate=False`` and migrate the table again).</div><div class=""> </div><div class=""> **Google SQL** has the same problems as MySQL and more. In particular table metadata itself must be stored in the database in a table that is not migrated by web2py. This is because Google App Engine has a readonly file system. Web2py migrations in Google:SQL combined with the MySQL issue described above can result in metadata corruption. Again, this can be prevented (my migrating the table at once and then setting migrate=False so that the metadata table is not accessed any more) or it can fixed a posteriori (my accessing the database using the Google dashboard and deleting any corrupted entry from the table called ``web2py_filesystem``.</div><div class=""> </div><div class=""> ``limitby``:inxx</div><div class="insert">**MSSQL** does not support the SQL OFFSET keyword. Therefore the database cannot do pagination. When doing a ``limitby=(a,b)`` web2py will fetch the first ``b`` rows and discard the first <span class="highlight"></span>``a``. This may result in a considerable overhead when compared with other database engines.</div><div class=""> </div><div class=""> **Oracle** also does not support pagination. It does not support neither the OFFSET nor the LIMIT keywords. Web2py achieves pagination by translating a ``db(...).select(limitby=(a,b))`` into a complex three-way nested select (as suggested by official Oracle documentation). This works for simple select but may break for complex selects involving aliased fields and or joins.</div><div class=""> </div><div class=""> **MSSQL** has problems with circular references in tables that have ONDELETE CASCADE. This is an MSSSQL bug and you work around it by setting the ondelete attribute for all reference fields to &quot;NO ACTION&quot;. You can also do it once and for all before you define tables:</div><div class=""> </div><div class=""> ``</div><div class=""> db = DAL(&#x27;mssql://....&#x27;)</div><div class=""> for key in [&#x27;reference&#x27;,&#x27;reference FK&#x27;]:</div><div class="">     db._adapter.types[key]=db._adapter.types[key].replace(</div><div class="">         &#x27;%(on_delete_action)s&#x27;,&#x27;NO ACTION&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> **MSSQL** also has problems with arguments passed to the DISTINCT keyword and therefore</div><div class="">  while this works,</div><div class=""> </div><div class=""> ``</div><div class=""> db(query).select(distinct=True)</div><div class=""> ``</div><div class=""> </div><div class=""> this does not</div><div class=""> </div><div class=""> ``</div><div class=""> db(query).select(distinct=db.mytable.myfield)</div><div class=""> ``</div><div class=""> </div><div class="insert">**Google NoSQL (Datastore)** does not allow joins, left joins, aggregates, expression, OR involving more than one table, the like operator and search in &quot;text&quot;&quot; fields. Transactions are limited and not provided automatically by web2py (you need to use the Google API ``run_in_transaction`` which you can look up in the Google App Engine documentation online). Google also limits the number of records you can retrieve in each one query (1000 at the time of writing). On the Google datastore record IDs are integer but they are not sequential. While on SQL the &quot;list:string&quot; type is mapped into a &quot;text&quot; type, on the Google Datastore it is mapped into a ``ListStringProperty``. Similarly &quot;list:integer&quot; and &quot;list:reference&quot; are mapped into &quot;ListProperty&quot;. This makes <span class="highlight"></span>searches for content inside these fields types are more efficient on Google NoSQL than on SQL databases.</div></div></div>
    <div class="span6"><div class="diff"><div class=""> ``</div><div class="delete">db = DAL(<span class="highlight"></span>...<span class="highlight"></span>, do_connect=False)</div><div class=""> ``:code</div><div class=""> </div><div class="delete">In this case you will be able to call ``_select``, ``_insert``, ``_update``, and ``_delete`` to generate SQL but <span class="highlight"></span>call ``select``, ``insert``, ``update``, and ``delete``. In most of the cases you can use ``do_connect=False`` even without having the required database drivers.</div><div class=""> </div><div class=""> #### Connection pooling</div><div class=""> ``connection pooling``:inxx</div><div class=""> </div><div class=""> The second argument of the DAL constructor is the ``pool_size``; it defaults to zero.</div><div class=""> </div><div class=""> As it is rather slow to establish a new database connection for each request, web2py implements a mechanism for connection pooling. Once a connection is established and the page has been served and the transaction completed, the connection is not closed but goes into a pool. When the next http request arrives, web2py tries to obtain a connection from the pool and use that for the new transaction. If there are no available connections in the pool, a new connection is established.</div><div class=""> </div><div class=""> The ``pool_size`` parameter is ignored by SQLite and Google App Engine.</div><div class=""> </div><div class=""> Connections in the pools are shared sequentially among threads, in the sense that they may be used by two different but not simultaneous threads. There is only one pool for each web2py process.</div><div class=""> </div><div class=""> When web2py starts, the pool is always empty. The pool grows up to the minimum between the value of ``pool_size`` and the max number of concurrent requests. This means that if ``pool_size=10`` but our server never receives more than 5 concurrent requests, then the actual pool size will only grow to 5. If ``pool_size=0`` then connection pooling is not used.</div><div class=""> </div><div class=""> Connection pooling is ignored for SQLite, since it would not yield any benefit.</div><div class=""> </div><div class=""> #### Connection failures</div><div class=""> </div><div class=""> If web2py fails to connect to the database it waits 1 seconds and tries again up to 5 times before declaring a failure. In case of connection pooling it is possible that a pooled connection that stays open but unused for some time is closed by the database end. Thanks to the retry feature web2py tries to re-establish these dropped connections.</div><div class=""> </div><div class=""> It is also possible to build queries using in-place logical operators:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; query = db.person.name!=&#x27;Alex&#x27;</div><div class=""> &gt;&gt;&gt; query &amp;= db.person.id&gt;3</div><div class=""> &gt;&gt;&gt; query |= db.person.name==&#x27;John&#x27;</div><div class=""> ``</div><div class=""> </div><div class=""> #### ``count``, ``isempty``, ``delete``, ``update``</div><div class=""> </div><div class=""> You can count records in a set:</div><div class=""> </div><div class=""> ``count``:inxx ``isempty``:inxx</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; print db(db.person.id &gt; 0).count()</div><div class=""> 3</div><div class=""> ``:code</div><div class=""> </div><div class=""> Notice that ``count`` takes an optional ``distinct`` argument which defaults to False, and it works very much like the same argument for ``select``. ``count`` has also a ``cache`` argument that works very much like the equivalent argument of the ``select`` method.</div><div class=""> </div><div class="delete">Sometimes you may need to check i<span class="highlight">s</span> a table is empty. A more efficient way than counting is using the ``isempty`` method:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; print db(db.person.id &gt; 0).isempty()</div><div class=""> False</div><div class=""> ``:code</div><div class=""> </div><div class=""> or equivalently:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; print db(db.person).isempty()</div><div class=""> False</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can delete records in a set:</div><div class=""> </div><div class=""> ``delete``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db(db.person.id &gt; 3).delete()</div><div class=""> ``:code</div><div class=""> </div><div class=""> Max</div><div class=""> Tim</div><div class=""> &gt;&gt;&gt; print rows2</div><div class=""> person.name</div><div class=""> John</div><div class=""> Tim</div><div class=""> ``</div><div class=""> </div><div class=""> </div><div class=""> You can do a union of the records in two set of rows:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows3 = rows1 &amp; rows2</div><div class=""> &gt;&gt;&gt; print rows3</div><div class=""> name</div><div class=""> Max</div><div class=""> Tim</div><div class=""> John</div><div class=""> Tim</div><div class=""> ``:code</div><div class=""> </div><div class="delete">You can do a union of the records <span class="highlight">and </span>removing duplicates:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows3 = rows1 | rows2</div><div class=""> &gt;&gt;&gt; print rows3</div><div class=""> name</div><div class=""> Max</div><div class=""> Tim</div><div class=""> John</div><div class=""> ``:code</div><div class=""> </div><div class=""> #### ``find``, ``exclude``, ``sort``</div><div class=""> ``find``:inxx ``exclude``:inxx ``sort``:inxx</div><div class=""> </div><div class=""> There are times when one needs to perform two selects and one contains a subset of a previous select. In this case it is pointless to access the database again. The ``find``, ``exclude`` and ``sort`` objects allow you to manipulate a Rows objects and generate another one without accessing the database. More specifically:</div><div class=""> - ``find`` returns a new set of Rows filtered by a condition and leaves the original unchanged.</div><div class=""> - ``exclude`` returns a new set of Rows filtered by a condition and removes them from the original Rows.</div><div class=""> - ``sort`` returns a new set of Rows sorted by a condition and leaves the original unchanged.</div><div class=""> </div><div class=""> All these methods take a single argument, a function that acts on each individual row.</div><div class=""> </div><div class=""> Max</div><div class=""> &gt;&gt;&gt; print len(rows)</div><div class=""> 2</div><div class=""> &gt;&gt;&gt; for row in rows.sort(lambda row: row.name):</div><div class="">         print row.name</div><div class=""> Alex</div><div class=""> John</div><div class=""> ``:code</div><div class=""> </div><div class=""> They can be combined:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows = db(db.person).select()</div><div class=""> &gt;&gt;&gt; rows = rows.find(</div><div class="">         lambda row: &#x27;x&#x27; in row.name).sort(</div><div class="">             lambda row: row.name)</div><div class=""> &gt;&gt;&gt; for row in rows:</div><div class="">         print row.name</div><div class=""> Alex</div><div class=""> Max</div><div class=""> ``:code</div><div class=""> </div><div class="delete">Sort takes an optional argument ``reverse=True`` w<span class="highlight">h</span>i<span class="highlight">c</span>h <span class="highlight">an</span> obvious meaning.</div><div class=""> </div><div class=""> The ``find`` method as an optional limitby argument with the same syntax and functionality as the Set select ``method``.</div><div class=""> </div><div class=""> </div><div class=""> </div><div class=""> ### Other methods</div><div class=""> </div><div class=""> #### ``update_or_insert``</div><div class=""> ``update_or_insert``:inxx</div><div class=""> </div><div class=""> Some times you need to perform an insert only if there is no record with the same values as those being inserted.</div><div class=""> This can be done with</div><div class=""> </div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;,Field(&#x27;name&#x27;),Field(&#x27;birthplace&#x27;))</div><div class=""> db.person.update_or_insert(name=&#x27;John&#x27;,birthplace=&#x27;Chicago&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> The record will be inserted only of there is no other user called John born in Chicago.</div><div class=""> </div><div class=""> The SQL IN operator is realized via the belongs method which returns true when t</div><div class=""> ``belongs``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db(db.log.severity.belongs((1, 2))).select():</div><div class="">         print row.event</div><div class=""> port scan</div><div class=""> xss injection</div><div class=""> ``:code</div><div class=""> </div><div class=""> The DAL also allows a nested select as the argument of the belongs operator. The only caveat is that the nested select has to be a ``_select``, not a ``select``, and only one field has to be selected explicitly, the one that defines the set.</div><div class=""> </div><div class=""> ``nested select``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; bad_days = db(db.log.severity==3)._select(db.log.event_time)</div><div class=""> &gt;&gt;&gt; for row in db(db.log.event_time.belongs(bad_days)).select():</div><div class="">         print row.event</div><div class=""> port scan</div><div class=""> xss injection</div><div class=""> unauthorized login</div><div class=""> ``:code</div><div class=""> </div><div class="delete">In those cases where a nested select is required and the loo<span class="highlight">p</span>-up field is a reference we can also use a query as argument. For example:</div><div class=""> </div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;,Field(&#x27;name&#x27;))</div><div class=""> db.define_table(&#x27;thing&#x27;,Field(&#x27;owner&#x27;),Field(&#x27;owner&#x27;,&#x27;reference thing&#x27;))</div><div class=""> db(db.thing.owner.belongs(db.person.name==&#x27;Jonathan&#x27;)).select()</div><div class=""> ``:code</div><div class=""> </div><div class=""> In this case it is obvious that the next select only needs the field referenced by the ``db.thing.owner`` field so we do not need the more verbose ``_select`` notation.</div><div class=""> </div><div class=""> ``nested_select``:inxx</div><div class=""> </div><div class=""> A nested select can also be used as insert/update value but in this case the syntax is different:</div><div class=""> </div><div class=""> ``</div><div class=""> lazy = db(db.person.name==&#x27;Jonathan&#x27;).nested_select(db.person.id)</div><div class=""> db(db.thing.id==1).update(owner = lazy)</div><div class=""> ``:code</div><div class=""> </div><div class=""> In this case ``lazy`` is a nested expression that computes the ``id`` of person &quot;Jonathan&quot;. The two lines result in one single SQL query.</div><div class=""> </div><div class=""> db(query, ignore_common_filters=True).select(...)</div><div class=""> ``SQLCustomType``:inxx</div><div class=""> </div><div class=""> It is possible to define new/custom field types. For example we consider here the example if a field that contains binary data in compressed form:</div><div class=""> </div><div class=""> ``</div><div class=""> from gluon.dal import SQLCustomType</div><div class=""> import zlib</div><div class=""> </div><div class=""> compressed = SQLCustomType(</div><div class="">      type =&#x27;text&#x27;,</div><div class="">      native=&#x27;text&#x27;,</div><div class="">      encoder =(lambda x: zlib.compress(x or &#x27;&#x27;)),</div><div class="">      decoder = (lambda x: zlib.decompress(x))</div><div class=""> )</div><div class=""> </div><div class=""> db.define_table(&#x27;example&#x27;, Field(&#x27;data&#x27;,type=compressed))</div><div class=""> ``:code</div><div class=""> </div><div class=""> ``SQLCustomType`` is a field type factory. Its ``type`` argument must be one of the standard web2py types. It tells web2py how to treat the field values at the web2py level. ``native`` is the name of the field as far as the database is concerned. Allowed names depend on the database engine. ``encoder`` is an optional transformation function applied when the data is stored and ``decoder`` is the optional reversed transformation function.</div><div class=""> </div><div class="delete">This feature is marked as experimental. In practice i<span class="highlight">s</span> has been in web2py for a long time and it works but it can make the code not portable, for example when the native type is database specific. It does not work on Google App Engine NoSQL.</div><div class=""> </div><div class=""> #### Using DAL without define tables</div><div class=""> </div><div class=""> The DAL can be used from any Python program simply by doing this:</div><div class=""> </div><div class=""> ``</div><div class=""> from gluon import DAL, Field</div><div class=""> db = DAL(&#x27;sqlite://storage.sqlite&#x27;,folder=&#x27;path/to/app/databases&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> i.e. import the DAL, Field, connect and specify the folder which contains the .table files (the app/databases folder).</div><div class=""> </div><div class=""> To access the data and its attributes we still have to define all the tables we are going to access with ``db.define_tables(...)``.</div><div class=""> </div><div class=""> If we just need access to the data but not to the web2py table attributes, we get away without re-defining the tables but simply asking web2py to read the necessary info from the metadata in the .table files:</div><div class=""> </div><div class=""> ``</div><div class=""> from gluon import DAL, Field</div><div class=""> db = DAL(&#x27;sqlite://storage.sqlite&#x27;,folder=&#x27;path/to/app/databases&#x27;,</div><div class="">          auto_import=True))</div><div class=""> For any adapter you can replace the driver with a different one:</div><div class=""> from gluon.dal import MySQLAdapter</div><div class=""> MySQLAdapter.driver = mysqldb</div><div class=""> ``</div><div class=""> </div><div class=""> and you can specify optional driver arguments and adapter arguments:</div><div class=""> </div><div class=""> ``</div><div class=""> db =DAL(..., driver_args={}, adapter_args={})</div><div class=""> ``</div><div class=""> </div><div class=""> </div><div class=""> #### Gotchas</div><div class=""> </div><div class=""> **SQLite** does not support dropping and altering columns. That means that web2py migrations will work up to a point. If you delete a field from a table, the column will remain in the database but be invisible to web2py. If you decide to reinstate the column, web2py will try re-create it and fail. In this case you must set ``fake_migrate=True`` so that metadata is rebuilt without attempting to add the column again. Also, for the same reason, **SQLite** is not aware of any change of column type. If you insert a number in a string field, it will be stored as string. If you later change the model and replace the type &quot;string&quot; with type &quot;integer&quot;, SQLite will continue to keep the number as a string and this may cause problem when you try to extract the data.</div><div class=""> </div><div class=""> **MySQL** does not support multiple ALTER TABLE within a single transaction. This means that any migration process is broken into multiple commits. If something happens that causes a failure it is possible to break a migration (the web2py metadata are no longer in sync with the actual table structure in the database). This is unfortunate but it can be prevented (migrate one table at the time) or it can be fixed a posteriori (revert the web2py model to what corresponds to the table structure in database, set ``fake_migrate=True`` and after the metadata has been rebuilt, set ``fake_migrate=False`` and migrate the table again).</div><div class=""> </div><div class=""> **Google SQL** has the same problems as MySQL and more. In particular table metadata itself must be stored in the database in a table that is not migrated by web2py. This is because Google App Engine has a readonly file system. Web2py migrations in Google:SQL combined with the MySQL issue described above can result in metadata corruption. Again, this can be prevented (my migrating the table at once and then setting migrate=False so that the metadata table is not accessed any more) or it can fixed a posteriori (my accessing the database using the Google dashboard and deleting any corrupted entry from the table called ``web2py_filesystem``.</div><div class=""> </div><div class=""> ``limitby``:inxx</div><div class="delete">**MSSQL** does not support the SQL OFFSET keyword. Therefore the database cannot do pagination. When doing a ``limitby=(a,b)`` web2py will fetch the first ``b`` rows and discard the first <span class="highlight">the </span>``a``. This may result in a considerable overhead when compared with other database engines.</div><div class=""> </div><div class=""> **Oracle** also does not support pagination. It does not support neither the OFFSET nor the LIMIT keywords. Web2py achieves pagination by translating a ``db(...).select(limitby=(a,b))`` into a complex three-way nested select (as suggested by official Oracle documentation). This works for simple select but may break for complex selects involving aliased fields and or joins.</div><div class=""> </div><div class=""> **MSSQL** has problems with circular references in tables that have ONDELETE CASCADE. This is an MSSSQL bug and you work around it by setting the ondelete attribute for all reference fields to &quot;NO ACTION&quot;. You can also do it once and for all before you define tables:</div><div class=""> </div><div class=""> ``</div><div class=""> db = DAL(&#x27;mssql://....&#x27;)</div><div class=""> for key in [&#x27;reference&#x27;,&#x27;reference FK&#x27;]:</div><div class="">     db._adapter.types[key]=db._adapter.types[key].replace(</div><div class="">         &#x27;%(on_delete_action)s&#x27;,&#x27;NO ACTION&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> **MSSQL** also has problems with arguments passed to the DISTINCT keyword and therefore</div><div class="">  while this works,</div><div class=""> </div><div class=""> ``</div><div class=""> db(query).select(distinct=True)</div><div class=""> ``</div><div class=""> </div><div class=""> this does not</div><div class=""> </div><div class=""> ``</div><div class=""> db(query).select(distinct=db.mytable.myfield)</div><div class=""> ``</div><div class=""> </div><div class="delete">**Google NoSQL (Datastore)** does not allow joins, left joins, aggregates, expression, OR involving more than one table, the like operator and search in &quot;text&quot;&quot; fields. Transactions are limited and not provided automatically by web2py (you need to use the Google API ``run_in_transaction`` which you can look up in the Google App Engine documentation online). Google also limits the number of records you can retrieve in each one query (1000 at the time of writing). On the Google datastore record IDs are integer but they are not sequential. While on SQL the &quot;list:string&quot; type is mapped into a &quot;text&quot; type, on the Google Datastore it is mapped into a ``ListStringProperty``. Similarly &quot;list:integer&quot; and &quot;list:reference&quot; are mapped into &quot;ListProperty&quot;. This makes <span class="highlight">that </span>searches for content inside these fields types are more efficient on Google NoSQL than on SQL databases.</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/6b98100d18209c817980078fba78b5d511a8d299">6b98100</a><ul><li>Date : 2013-01-08</li><li>fixed st_x and json field type</li></ul></li></ul>
<div class="row-fluid" id="com_6b98100d18209c817980078fba78b5d511a8d299">
    <div class="span6"><div class="diff"><div class=""> ----------</div><div class=""> **field type** | **default field validators**</div><div class=""> ``string`` | ``IS_LENGTH(length)`` default length is 512</div><div class=""> ``text`` | ``IS_LENGTH(65536)``</div><div class=""> ``blob`` | ``None``</div><div class=""> ``boolean`` | ``None``</div><div class=""> ``integer`` | ``IS_INT_IN_RANGE(-1e100, 1e100)``</div><div class=""> ``double`` | ``IS_FLOAT_IN_RANGE(-1e100, 1e100)``</div><div class=""> ``decimal(n,m)`` | ``IS_DECIMAL_IN_RANGE(-1e100, 1e100)``</div><div class=""> ``date`` | ``IS_DATE()``</div><div class=""> ``time`` | ``IS_TIME()``</div><div class=""> ``datetime`` | ``IS_DATETIME()``</div><div class=""> ``password`` | ``None``</div><div class=""> ``upload`` | ``None``</div><div class=""> ``reference &lt;table&gt;``  | ``IS_IN_DB(db,table.field,format)``</div><div class=""> ``list:string`` | ``None``</div><div class=""> ``list:integer`` | ``None``</div><div class=""> ``list:reference &lt;table&gt;`` | ``IS_IN_DB(db,table.field,format,multiple=True)``</div><div class="insert">+``json`` | ``IS_JSON()``</div><div class=""> ``bigint`` | ``None``</div><div class=""> ``big-id`` | ``None``</div><div class=""> ``big-reference`` | ``None``</div><div class=""> ---------</div><div class=""> </div><div class=""> Decimal requires and returns values as ``Decimal`` objects, as defined in the Python ``decimal`` module. SQLite does not handle the ``decimal`` type so internally we treat it as a ``double``. The (n,m) are the number of digits in total and the number of digits after the decimal point respectively.</div><div class=""> </div><div class=""> The ``big-id`` and, ``big-reference`` are only supported by some of the database engines and are experimental. They are not normally used as field types unless for legacy tables, however, the DAL constructor has a ``bigint_id`` argument that when set to ``True`` makes the ``id`` fields and ``reference`` fields ``big-id`` and ``big-reference`` respectively.</div><div class=""> </div><div class=""> The ``list:`` fields are special because they are designed to take advantage of certain denormalization features on NoSQL (in the case of Google App Engine NoSQL, the field types ``ListProperty`` and ``StringListProperty``) and back-port them all the other supported relational databases. On relational databases lists are stored as a ``text`` field. The items are separated by a ``|`` and each ``|`` in string item is escaped as a ``||``. They are discussed in their own section.</div><div class=""> </div><div class=""> -------</div><div class=""> Notice that ``requires=...`` is enforced at the level of forms, ``required=True`` is enforced at the level of the DAL (insert), while ``notnull``, ``unique`` and ``ondelete`` are enforced at the level of the database. While they sometimes may seem redundant, it is important to maintain the distinction when programming with the DAL.</div><div class=""> -------</div><div class=""> </div><div class=""> ``ondelete``:inxx</div><div class=""> </div><div class=""> - ``ondelete`` translates into the &quot;ON DELETE&quot; SQL statement. By default it is set to &quot;CASCADE&quot;. This tells the database that when it deletes a record, it should also delete all records that refer to it. To disable this feature, set ``ondelete`` to &quot;NO ACTION&quot; or &quot;SET NULL&quot;.</div><div class=""> - ``notnull=True`` translates into the &quot;NOT NULL&quot; SQL statement. It prevents the database from inserting null values for the field.</div><div class=""> - ``unique=True`` translates into the &quot;UNIQUE&quot; SQL statement and it makes sure that values of this field are unique within the table. It is enforced at the database level.</div><div class=""> db = DAL(&#x27;sqlite://storage.sqlite&#x27;,folder=&#x27;path/to/app/databases&#x27;,</div><div class=""> ``:code</div><div class=""> </div><div class=""> This allows us to access any ``db.table`` without need to re-define it.</div><div class=""> </div><div class=""> #### PostGIS, SpatiaLite, and MS Geo (experimental)</div><div class=""> </div><div class=""> ``PostGIS``:inxx ``StatiaLite``:inxx ``Geo Extensions``:inxx</div><div class=""> ``geometry``:inxx ``geoPoint``:inxx ``geoLine``:inxx ``geoPolygon``:inxx</div><div class=""> </div><div class=""> The DAL supports geographical APIs using PostGIS (for PostgreSQL), spatialite (for SQLite), and MSSQL and Spatial Extensions. This is a feature that was sponsored by the Sahana project and implemented by Denes Lengyel.</div><div class=""> </div><div class=""> DAL provides geometry and geography fields types and the following functions:</div><div class=""> </div><div class=""> ``st_asgeojson``:inxx ``st_astext``:inxx ``st_contained``:inxx ``st_contains``:inxx</div><div class=""> ``st_distance``:inxx ``st_equals``:inxx ``st_intersects``:inxx ``st_overlaps``:inxx</div><div class=""> ``st_simplify``:inxx ``st_touches``:inxx ``st_within``:inxx</div><div class=""> </div><div class=""> ``</div><div class=""> st_asgeojson (PostGIS only)</div><div class=""> st_astext</div><div class=""> st_contains</div><div class=""> st_distance</div><div class=""> st_equals</div><div class=""> st_intersects</div><div class=""> st_overlaps</div><div class=""> st_simplify (PostGIS only)</div><div class=""> st_touches</div><div class=""> st_within</div><div class="insert">+st_x</div><div class="insert">+st_y</div><div class=""> ``</div></div></div>
    <div class="span6"><div class="diff"><div class=""> ----------</div><div class=""> **field type** | **default field validators**</div><div class=""> ``string`` | ``IS_LENGTH(length)`` default length is 512</div><div class=""> ``text`` | ``IS_LENGTH(65536)``</div><div class=""> ``blob`` | ``None``</div><div class=""> ``boolean`` | ``None``</div><div class=""> ``integer`` | ``IS_INT_IN_RANGE(-1e100, 1e100)``</div><div class=""> ``double`` | ``IS_FLOAT_IN_RANGE(-1e100, 1e100)``</div><div class=""> ``decimal(n,m)`` | ``IS_DECIMAL_IN_RANGE(-1e100, 1e100)``</div><div class=""> ``date`` | ``IS_DATE()``</div><div class=""> ``time`` | ``IS_TIME()``</div><div class=""> ``datetime`` | ``IS_DATETIME()``</div><div class=""> ``password`` | ``None``</div><div class=""> ``upload`` | ``None``</div><div class=""> ``reference &lt;table&gt;``  | ``IS_IN_DB(db,table.field,format)``</div><div class=""> ``list:string`` | ``None``</div><div class=""> ``list:integer`` | ``None``</div><div class=""> ``list:reference &lt;table&gt;`` | ``IS_IN_DB(db,table.field,format,multiple=True)``</div><div class=""> ``bigint`` | ``None``</div><div class=""> ``big-id`` | ``None``</div><div class=""> ``big-reference`` | ``None``</div><div class=""> ---------</div><div class=""> </div><div class=""> Decimal requires and returns values as ``Decimal`` objects, as defined in the Python ``decimal`` module. SQLite does not handle the ``decimal`` type so internally we treat it as a ``double``. The (n,m) are the number of digits in total and the number of digits after the decimal point respectively.</div><div class=""> </div><div class=""> The ``big-id`` and, ``big-reference`` are only supported by some of the database engines and are experimental. They are not normally used as field types unless for legacy tables, however, the DAL constructor has a ``bigint_id`` argument that when set to ``True`` makes the ``id`` fields and ``reference`` fields ``big-id`` and ``big-reference`` respectively.</div><div class=""> </div><div class=""> The ``list:`` fields are special because they are designed to take advantage of certain denormalization features on NoSQL (in the case of Google App Engine NoSQL, the field types ``ListProperty`` and ``StringListProperty``) and back-port them all the other supported relational databases. On relational databases lists are stored as a ``text`` field. The items are separated by a ``|`` and each ``|`` in string item is escaped as a ``||``. They are discussed in their own section.</div><div class=""> </div><div class=""> -------</div><div class=""> Notice that ``requires=...`` is enforced at the level of forms, ``required=True`` is enforced at the level of the DAL (insert), while ``notnull``, ``unique`` and ``ondelete`` are enforced at the level of the database. While they sometimes may seem redundant, it is important to maintain the distinction when programming with the DAL.</div><div class=""> -------</div><div class=""> </div><div class=""> ``ondelete``:inxx</div><div class=""> </div><div class=""> - ``ondelete`` translates into the &quot;ON DELETE&quot; SQL statement. By default it is set to &quot;CASCADE&quot;. This tells the database that when it deletes a record, it should also delete all records that refer to it. To disable this feature, set ``ondelete`` to &quot;NO ACTION&quot; or &quot;SET NULL&quot;.</div><div class=""> - ``notnull=True`` translates into the &quot;NOT NULL&quot; SQL statement. It prevents the database from inserting null values for the field.</div><div class=""> - ``unique=True`` translates into the &quot;UNIQUE&quot; SQL statement and it makes sure that values of this field are unique within the table. It is enforced at the database level.</div><div class=""> db = DAL(&#x27;sqlite://storage.sqlite&#x27;,folder=&#x27;path/to/app/databases&#x27;,</div><div class=""> ``:code</div><div class=""> </div><div class=""> This allows us to access any ``db.table`` without need to re-define it.</div><div class=""> </div><div class=""> #### PostGIS, SpatiaLite, and MS Geo (experimental)</div><div class=""> </div><div class=""> ``PostGIS``:inxx ``StatiaLite``:inxx ``Geo Extensions``:inxx</div><div class=""> ``geometry``:inxx ``geoPoint``:inxx ``geoLine``:inxx ``geoPolygon``:inxx</div><div class=""> </div><div class=""> The DAL supports geographical APIs using PostGIS (for PostgreSQL), spatialite (for SQLite), and MSSQL and Spatial Extensions. This is a feature that was sponsored by the Sahana project and implemented by Denes Lengyel.</div><div class=""> </div><div class=""> DAL provides geometry and geography fields types and the following functions:</div><div class=""> </div><div class=""> ``st_asgeojson``:inxx ``st_astext``:inxx ``st_contained``:inxx ``st_contains``:inxx</div><div class=""> ``st_distance``:inxx ``st_equals``:inxx ``st_intersects``:inxx ``st_overlaps``:inxx</div><div class=""> ``st_simplify``:inxx ``st_touches``:inxx ``st_within``:inxx</div><div class=""> </div><div class=""> ``</div><div class=""> st_asgeojson (PostGIS only)</div><div class=""> st_astext</div><div class="delete">-st_contained</div><div class=""> st_contains</div><div class=""> st_distance</div><div class=""> st_equals</div><div class=""> st_intersects</div><div class=""> st_overlaps</div><div class=""> st_simplify (PostGIS only)</div><div class=""> st_touches</div><div class=""> st_within</div><div class=""> ``</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/dfb272c5b97441b4e2bc1177c97177ecf83b1d0f">dfb272c</a><ul><li>Date : 2013-01-01</li><li>fixed bug in virtual field description, thanks Niphlod</li></ul></li></ul>
<div class="row-fluid" id="com_dfb272c5b97441b4e2bc1177c97177ecf83b1d0f">
    <div class="span6"><div class="diff"><div class=""> ``</div><div class="insert">+&gt;&gt;&gt; db.item.total_price = Field.Virtual(</div><div class="insert">+    lambda row: row.item.unit_price*row.item.quantity)</div><div class=""> ``:code</div><div class=""> </div><div class=""> i.e. by simply defining a new field ``total_price`` to be a ``Field.Virtual``. The only argument of the constructor is a function that takes a row and returns the computed values.</div><div class=""> </div><div class=""> A virtual field defined as the one above is automatically computed for all records when the records are selected:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db(db.item).select(): print row.total_price</div><div class=""> ``</div><div class=""> </div><div class=""> It is also possible to define method fields which are calculated on-demand, when called.</div><div class=""> For example:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.item.discounted_total = Field.Method(lambda row, discount=0.0: \</div><div class="insert">       row<span class="highlight">.item</span>.unit_price*row<span class="highlight">.item</span>.quantity*(1.0-discount/100))</div><div class=""> ``:code</div></div></div>
    <div class="span6"><div class="diff"><div class=""> ``</div><div class="delete">-&gt;&gt;&gt; db.item.total_price = Field.Virtual(lambda row: row.unit_price*row.quantity)</div><div class=""> ``:code</div><div class=""> </div><div class=""> i.e. by simply defining a new field ``total_price`` to be a ``Field.Virtual``. The only argument of the constructor is a function that takes a row and returns the computed values.</div><div class=""> </div><div class=""> A virtual field defined as the one above is automatically computed for all records when the records are selected:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db(db.item).select(): print row.total_price</div><div class=""> ``</div><div class=""> </div><div class=""> It is also possible to define method fields which are calculated on-demand, when called.</div><div class=""> For example:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.item.discounted_total = Field.Method(lambda row, discount=0.0: \</div><div class="delete">       row<span class="highlight"></span>.unit_price*row<span class="highlight"></span>.quantity*(1.0-discount/100))</div><div class=""> ``:code</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/f2fd41dd2a0d4bf68f5cd4f0989fb32bdc35eac5">f2fd41d</a><ul><li>Date : 2012-12-31</li><li>spell check of diffs, thanks Joanthan</li></ul></li></ul>
<div class="row-fluid" id="com_f2fd41dd2a0d4bf68f5cd4f0989fb32bdc35eac5">
    <div class="span6"><div class="diff"><div class=""> - ``ondelete`` translates into the &quot;ON DELETE&quot; SQL statement. By default it is set to &quot;CASCADE&quot;. This tells the database that when it deletes a record, it should also delete all records that refer to it. To disable this feature, set ``ondelete`` to &quot;NO ACTION&quot; or &quot;SET NULL&quot;.</div><div class=""> - ``notnull=True`` translates into the &quot;NOT NULL&quot; SQL statement. It prevents the database from inserting null values for the field.</div><div class=""> - ``unique=True`` translates into the &quot;UNIQUE&quot; SQL statement and it makes sure that values of this field are unique within the table. It is enforced at the database level.</div><div class=""> - ``uploadfield`` applies only to fields of type &quot;upload&quot;. A field of type &quot;upload&quot; stores the name of a file saved somewhere else, by default on the filesystem under the application &quot;uploads/&quot; folder. If ``uploadfield`` is set, then the file is stored in a blob field within the same table and the value of ``uploadfield`` is the name of the blob field. This will be discussed in more detail later in the context of SQLFORM.</div><div class=""> - ``uploadfolder`` defaults to the application&#x27;s &quot;uploads/&quot; folder. If set to a different path, files will uploaded to a different folder. For example, uploadfolder=os.path.join(request.folder,&#x27;static/temp&#x27;) will upload files to the web2py/applications/myapp/static/temp folder.</div><div class=""> - ``uploadseparate`` if set to True will upload files under different subfolders of the &#x27;&#x27;uploadfolder&#x27;&#x27; folder. This is optimized to avoid too many files under the same folder/subfolder. ATTENTION: You cannot change the value of ``uploadseparate`` from True to False without breaking the system. web2py either uses the separate subfolders or it does not. Changing the behavior after files have been uploaded will prevent web2py from being able to retrieve those files. If this happens it is possible to move files and fix the problem but this is not described here.</div><div class="insert">- ``uploadfs`` allows you specify a different file<span class="highlight"> </span>system where to upload files, including an Amazon S3 storage or a remote FTP storage. This option requires PyFileSystem installed. ``uploadfs`` must point to ``PyFileSystem``. ``PyFileSystem``:inxx ``uploadfs``:idxx</div><div class=""> - ``widget`` must be one of the available widget objects, including custom widgets, for example: ``SQLFORM.widgets.string.widget``. A list of available widgets will be discussed later. Each field type has a default widget.</div><div class=""> - ``label`` is a string (or something that can be serialized to a string) that contains the label to be used for this field in autogenerated forms.</div><div class=""> - ``comment``  is a string (or something that can be serialized to a string) that contains a comment associated with this field, and will be displayed to the right of the input field in the autogenerated forms.</div><div class=""> - ``writable`` if a field is writable, it can be edited in autogenerated create and update forms.</div><div class=""> - ``readable`` if a field is readable, it will be visible in readonly forms. If a field is neither readable nor writable, it will not be displayed in create and update forms.</div><div class=""> - ``update`` contains the default value for this field when the record is updated.</div><div class=""> - ``compute`` is an optional function. If a record is inserted or updated, the compute function will be executed and the field will be populated with the function result. The record is passed to the compute function as a ``dict``, and the dict will not include the current value of that, or any other compute field.</div><div class=""> - ``authorize`` can be used to require access control on the corresponding field, for &quot;upload&quot; fields only. It will be discussed more in detail in the context of Authentication and Authorization.</div><div class=""> - ``autodelete`` determines if the corresponding uploaded file should be deleted when the record referencing the file is deleted. For &quot;upload&quot; fields only.</div><div class=""> - ``represent`` can be None or can point to a function that takes a field value and returns an alternate representation for the field value. Examples:</div><div class=""> ``</div><div class=""> db.mytable.name.represent = lambda name,row: name.capitalize()</div><div class=""> db.mytable.other_id.represent = lambda id,row: row.myfield</div><div class=""> db.mytable.some_uploadfield.represent = lambda value,row: \</div><div class="">     A(&#x27;get it&#x27;, _href=URL(&#x27;download&#x27;, args=value))</div><div class=""> ``:code</div><div class=""> </div><div class=""> ``blob``:inxx</div><div class=""> &quot;blob&quot; fields are also special. By default, binary data is encoded in base64 before being stored into the actual database field, and it is decoded when extracted. This has the negative effect of using 25% more storage space than necessary in blob fields, but has two advantages. On average it reduces the amount of data communicated between web2py and the database server, and it makes the communication independent of back-end-specific escaping conventions.</div><div class=""> </div><div class=""> Insert returns the unique &quot;id&quot; value of each record inserted.</div><div class=""> </div><div class=""> You can truncate the table, i.e., delete all records and reset the counter of the id.</div><div class=""> </div><div class=""> ``truncate``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.person.truncate()</div><div class=""> ``:code</div><div class=""> </div><div class=""> Now, if you insert a record again, the counter starts again at 1 (this is back-end specific and does not apply to Google NoSQL):</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.person.insert(name=&quot;Alex&quot;)</div><div class=""> 1</div><div class=""> ``:code</div><div class=""> </div><div class=""> Notice you can pass parameters to ``truncate``, for example you can tell SQLITE to restart the id counter.</div><div class=""> </div><div class=""> ``</div><div class=""> db.person.truncate(&#x27;RESTART IDENTITY CASCADE&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class="insert">The argument is in raw SQL and the<span class="highlight">re</span>f<span class="highlight"></span>ore engine specific.</div><div class=""> </div><div class=""> ``bulk_insert``:inxx</div><div class=""> web2py also provides a bulk_insert method</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.person.bulk_insert([{&#x27;name&#x27;:&#x27;Alex&#x27;}, {&#x27;name&#x27;:&#x27;John&#x27;}, {&#x27;name&#x27;:&#x27;Tim&#x27;}])</div><div class=""> [3,4,5]</div><div class=""> ``:code</div><div class=""> </div><div class=""> It takes a list of dictionaries of fields to be inserted and performs multiple inserts at once. It returns the IDs of the inserted records. On the supported relational databases there is no advantage in using this function as opposed to looping and performing individual inserts but on Google App Engine NoSQL, there is a major speed advantage.</div><div class=""> </div><div class=""> ### ``commit`` and ``rollback``</div><div class=""> </div><div class=""> No create, drop, insert, truncate, delete, or update operation is actually committed until you issue the commit command</div><div class=""> </div><div class=""> ``commit``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.commit()</div><div class=""> ``:code</div><div class=""> </div><div class=""> To check it let&#x27;s insert a new record:</div><div class=""> are equivalent to</div><div class=""> </div><div class=""> #### ``as_dict`` and ``as_list``</div><div class=""> ``as_list``:inxx ``as_dict``:inxx</div><div class=""> </div><div class=""> A Row object can be serialized into a regular dictionary using the ``as_dict()`` method and a Rows object can be serialized into a list of dictionaries using the ``as_list()`` method. Here are some examples:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows = db(query).select()</div><div class=""> &gt;&gt;&gt; rows_list = rows.as_list()</div><div class=""> &gt;&gt;&gt; first_row_dict = rows.first().as_dict()</div><div class=""> ``:code</div><div class=""> </div><div class=""> These methods are convenient for passing Rows to generic views and or to store Rows in sessions (since Rows objects themselves cannot be serialized since contain a reference to an open DB connection):</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows = db(query).select()</div><div class=""> &gt;&gt;&gt; session.rows = rows # not allowed!</div><div class=""> &gt;&gt;&gt; session.rows = rows.as_list() # allowed!</div><div class=""> ``:code</div><div class=""> </div><div class=""> #### Combining rows</div><div class=""> </div><div class="insert">Row objects can be co<span class="highlight">m</span>bined at the Python level. Here we assume:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; print rows1</div><div class=""> person.name</div><div class=""> Max</div><div class=""> Tim</div><div class=""> &gt;&gt;&gt; print rows2</div><div class=""> person.name</div><div class=""> John</div><div class=""> Tim</div><div class=""> ``</div><div class=""> </div><div class=""> </div><div class=""> You can do a union of the records in two set of rows:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows3 = rows1 &amp; rows2</div><div class=""> &gt;&gt;&gt; print rows3</div><div class=""> name</div><div class=""> Max</div><div class=""> Max</div><div class=""> &gt;&gt;&gt; print len(rows)</div><div class=""> 2</div><div class=""> &gt;&gt;&gt; for row in rows.sort(lambda row: row.name):</div><div class="">         print row.name</div><div class=""> Alex</div><div class=""> John</div><div class=""> ``:code</div><div class=""> </div><div class=""> They can be combined:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows = db(db.person).select()</div><div class=""> &gt;&gt;&gt; rows = rows.find(</div><div class="">         lambda row: &#x27;x&#x27; in row.name).sort(</div><div class="">             lambda row: row.name)</div><div class=""> &gt;&gt;&gt; for row in rows:</div><div class="">         print row.name</div><div class=""> Alex</div><div class=""> Max</div><div class=""> ``:code</div><div class=""> </div><div class="insert">Sort takes an optional arg<span class="highlight">u</span>ment ``reverse=True`` which an obvious meaning.</div><div class=""> </div><div class=""> The ``find`` method as an optional limitby argument with the same syntax and functionality as the Set select ``method``.</div><div class=""> </div><div class=""> </div><div class=""> </div><div class=""> ### Other methods</div><div class=""> </div><div class=""> #### ``update_or_insert``</div><div class=""> ``update_or_insert``:inxx</div><div class=""> </div><div class=""> Some times you need to perform an insert only if there is no record with the same values as those being inserted.</div><div class=""> This can be done with</div><div class=""> </div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;,Field(&#x27;name&#x27;),Field(&#x27;birthplace&#x27;))</div><div class=""> db.person.update_or_insert(name=&#x27;John&#x27;,birthplace=&#x27;Chicago&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> The record will be inserted only of there is no other user called John born in Chicago.</div><div class=""> </div><div class=""> In the following example, you see a controller that caches a select on the previ</div><div class=""> ``</div><div class=""> def cache_db_select():</div><div class="">     logs = db().select(db.log.ALL, cache=(cache.ram, 60))</div><div class="">     return dict(logs=logs)</div><div class=""> ``:code</div><div class=""> </div><div class=""> ``cacheable``:inxx</div><div class=""> </div><div class=""> The ``select`` method has an optional ``cacheable`` argument, normally set to ``False``. When ``cacheable=True`` the resulting ``Rows`` is serializable but The ``Row``s lack ``update_record`` and ``delete_record`` methods.</div><div class=""> </div><div class=""> If you do not need these methods you can speed up selects a lot by setting the cacheable attribute:</div><div class=""> </div><div class=""> ``</div><div class=""> rows = db(query).select(cacheable=True)</div><div class=""> ``:code</div><div class=""> </div><div class=""> -------</div><div class=""> The results of a ``select`` are normally complex, un-pickleable objects; they cannot be stored in a session and cannot be cached in any other way than the one explained here unless the ``cache`` attribute is set or ``cacheable=True``.</div><div class=""> -------</div><div class=""> </div><div class="insert">When the ``cache`` argument is set but ``cacheable=False`` (default) only the database results are cached, not the actual Rows object. When the ``cache`` argument is used in conju<span class="highlight">n</span>ction with ``cacheable=True`` the entire Rows object is cached and this results in much baster caching:</div><div class=""> </div><div class=""> ``</div><div class=""> rows = db(query).select(cache=(cache.ram,3600),cacheable=True)</div><div class=""> ``:code</div><div class=""> </div><div class=""> ### Self-Reference and aliases</div><div class=""> </div><div class=""> ``self reference``:inxx</div><div class=""> ``alias``:inxx</div><div class=""> It is possible to define tables with fields that refer to themselves, here is an example:</div><div class=""> ``reference table``:inxx</div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;,</div><div class="">     Field(&#x27;name&#x27;),</div><div class="">     Field(&#x27;father_id&#x27;, &#x27;reference person&#x27;),</div><div class="">     Field(&#x27;mother_id&#x27;, &#x27;reference person&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class="insert">Notice that the alter<span class="highlight">n</span>a<span class="highlight"></span>tive notation of using a table object as field type will fail in this case, because it uses a variable ``db.person`` before it is defined:</div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;,</div><div class="">     Field(&#x27;name&#x27;),</div><div class="">     Field(&#x27;father_id&#x27;, db.person), # wrong!</div><div class="">     Field(&#x27;mother_id&#x27;, db.person)) # wrong!</div><div class=""> ``:code</div><div class=""> </div><div class=""> In general ``db.tablename`` and ``&quot;reference tablename&quot;`` are equivalent field types, but the latter is the only one allowed for self.references.</div><div class=""> </div><div class=""> ``with_alias``:inxx</div><div class=""> If the table refers to itself, then it is not possible to perform a JOIN to select a person and its parents without use of the SQL &quot;AS&quot; keyword. This is achieved in web2py using the ``with_alias``. Here is an example:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; Father = db.person.with_alias(&#x27;father&#x27;)</div><div class=""> &gt;&gt;&gt; Mother = db.person.with_alias(&#x27;mother&#x27;)</div><div class=""> &gt;&gt;&gt; db.person.insert(name=&#x27;Massimo&#x27;)</div><div class=""> 1</div><div class=""> &gt;&gt;&gt; db.person.insert(name=&#x27;Claudia&#x27;)</div><div class=""> 2</div><div class=""> &gt;&gt;&gt; db.person.insert(name=&#x27;Marco&#x27;, father_id=1, mother_id=2)</div><div class=""> 3</div><div class=""> db = DAL(&#x27;sqlite://storage.sqlite&#x27;,folder=&#x27;path/to/app/databases&#x27;)</div><div class=""> </div><div class=""> i.e. import the DAL, Field, connect and specify the folder which contains the .table files (the app/databases folder).</div><div class=""> </div><div class=""> To access the data and its attributes we still have to define all the tables we are going to access with ``db.define_tables(...)``.</div><div class=""> </div><div class=""> If we just need access to the data but not to the web2py table attributes, we get away without re-defining the tables but simply asking web2py to read the necessary info from the metadata in the .table files:</div><div class=""> </div><div class=""> ``</div><div class=""> from gluon import DAL, Field</div><div class=""> db = DAL(&#x27;sqlite://storage.sqlite&#x27;,folder=&#x27;path/to/app/databases&#x27;,</div><div class="">          auto_import=True))</div><div class=""> ``:code</div><div class=""> </div><div class=""> This allows us to access any ``db.table`` without need to re-define it.</div><div class=""> </div><div class=""> #### PostGIS, SpatiaLite, and MS Geo (experimental)</div><div class=""> </div><div class=""> ``PostGIS``:inxx ``StatiaLite``:inxx ``Geo Extensions``:inxx</div><div class=""> ``geometry``:inxx ``geoPoint``:inxx ``geoLine``:inxx ``geoPolygon``:inxx</div><div class=""> </div><div class="insert">The DAL supports geographical APIs using PostGIS (for PostgreSQL), spatialite (for SQLite), and MSSQL and Spatial Extensions. This is a feature that was spon<span class="highlight">so</span>red by the Sahana project and implemented by Denes Lengyel.</div><div class=""> </div><div class=""> DAL provides geometry and geography fields types and the following functions:</div><div class=""> </div><div class=""> ``st_asgeojson``:inxx ``st_astext``:inxx ``st_contained``:inxx ``st_contains``:inxx</div><div class=""> ``st_distance``:inxx ``st_equals``:inxx ``st_intersects``:inxx ``st_overlaps``:inxx</div><div class=""> ``st_simplify``:inxx ``st_touches``:inxx ``st_within``:inxx</div><div class=""> </div><div class=""> ``</div><div class=""> st_asgeojson (PostGIS only)</div><div class=""> st_astext</div><div class=""> st_contained</div><div class=""> st_contains</div><div class=""> st_distance</div><div class=""> st_equals</div><div class=""> st_intersects</div><div class=""> st_overlaps</div><div class=""> st_simplify (PostGIS only)</div><div class=""> st_touches</div><div class=""> st_within</div><div class=""> ``</div><div class=""> Here are some examples:</div><div class=""> </div><div class=""> ``</div><div class=""> from gluon.dal import DAL, Field, geoPoint, geoLine, geoPolygon</div><div class=""> db = DAL(&quot;mssql://user:pass@host:db&quot;)</div><div class=""> sp = db.define_table(&#x27;spatial&#x27;, Field(&#x27;loc&#x27;,&#x27;geometry()&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class=""> Below we insert a point, a line, and a polygon:</div><div class=""> ``</div><div class=""> sp.insert(loc=geoPoint(1,1))</div><div class=""> sp.insert(loc=geoLine((100,100),(20,180),(180,180)))</div><div class=""> sp.insert(loc=geoPolygon((0,0),(150,0),(150,150),(0,150),(0,0)))</div><div class=""> ``:code</div><div class=""> </div><div class=""> Notice that</div><div class=""> ``</div><div class=""> rows = db(sp.id&gt;0).select()</div><div class=""> ``:code</div><div class=""> </div><div class=""> Always returns the geometry data serialized as text.</div><div class="insert">You can also do the same more explicit<span class="highlight"></span>ly using ``st_astext()``:</div><div class=""> </div><div class=""> ``</div><div class=""> print db(sp.id&gt;0).select(sp.id, sp.loc.st_astext())</div><div class=""> spatial.id,spatial.loc.STAsText()</div><div class=""> 1, &quot;POINT (1 2)&quot;</div><div class=""> 2, &quot;LINESTRING (100 100, 20 180, 180 180)&quot;</div><div class=""> 3, &quot;POLYGON ((0 0, 150 0, 150 150, 0 150, 0 0))&quot;</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can ask for the native representation by using ``st_asgeojson()`` (in PostGIS only):</div><div class=""> </div><div class=""> ``</div><div class=""> print db(sp.id&gt;0).select(sp.id, sp.loc.st_asgeojson().with_alias(&#x27;loc&#x27;))</div><div class=""> spatial.id,loc</div><div class=""> 1, [1, 2]</div><div class=""> 2, [[100, 100], [20 180], [180, 180]]</div><div class=""> 3, [[[0, 0], [150, 0], [150, 150], [0, 150], [0, 0]]]</div><div class=""> ``:code</div><div class=""> </div><div class=""> (notice an array is a point, an array of arrays is a line, and an array of array of arrays is a polygon).</div><div class=""> </div><div class=""> Here are example of how to use geographical functions:</div><div class=""> </div><div class=""> ``</div><div class=""> query = sp.loc.st_intersects(geoLine((20,120),(60,160)))</div><div class=""> query = sp.loc.st_overlaps(geoPolygon((1,1),(11,1),(11,11),(11,1),(1,1)))</div><div class=""> query = sp.loc.st_contains(geoPoint(1,1))</div><div class=""> print db(query).select(sp.id,sp.loc)</div><div class=""> spatial.id,spatial.loc</div><div class="insert">3,&quot;POLYG<span class="highlight"></span>ON ((0 0, 150 0, 150 150, 0 150, 0 0))&quot;</div><div class=""> ``:code</div></div></div>
    <div class="span6"><div class="diff"><div class=""> - ``ondelete`` translates into the &quot;ON DELETE&quot; SQL statement. By default it is set to &quot;CASCADE&quot;. This tells the database that when it deletes a record, it should also delete all records that refer to it. To disable this feature, set ``ondelete`` to &quot;NO ACTION&quot; or &quot;SET NULL&quot;.</div><div class=""> - ``notnull=True`` translates into the &quot;NOT NULL&quot; SQL statement. It prevents the database from inserting null values for the field.</div><div class=""> - ``unique=True`` translates into the &quot;UNIQUE&quot; SQL statement and it makes sure that values of this field are unique within the table. It is enforced at the database level.</div><div class=""> - ``uploadfield`` applies only to fields of type &quot;upload&quot;. A field of type &quot;upload&quot; stores the name of a file saved somewhere else, by default on the filesystem under the application &quot;uploads/&quot; folder. If ``uploadfield`` is set, then the file is stored in a blob field within the same table and the value of ``uploadfield`` is the name of the blob field. This will be discussed in more detail later in the context of SQLFORM.</div><div class=""> - ``uploadfolder`` defaults to the application&#x27;s &quot;uploads/&quot; folder. If set to a different path, files will uploaded to a different folder. For example, uploadfolder=os.path.join(request.folder,&#x27;static/temp&#x27;) will upload files to the web2py/applications/myapp/static/temp folder.</div><div class=""> - ``uploadseparate`` if set to True will upload files under different subfolders of the &#x27;&#x27;uploadfolder&#x27;&#x27; folder. This is optimized to avoid too many files under the same folder/subfolder. ATTENTION: You cannot change the value of ``uploadseparate`` from True to False without breaking the system. web2py either uses the separate subfolders or it does not. Changing the behavior after files have been uploaded will prevent web2py from being able to retrieve those files. If this happens it is possible to move files and fix the problem but this is not described here.</div><div class="delete">- ``uploadfs`` allows you specify a different file<span class="highlight">s</span>system where to upload files, including an Amazon S3 storage or a remote FTP storage. This option requires PyFileSystem installed. ``uploadfs`` must point to ``PyFileSystem``. ``PyFileSystem``:inxx ``uploadfs``:idxx</div><div class=""> - ``widget`` must be one of the available widget objects, including custom widgets, for example: ``SQLFORM.widgets.string.widget``. A list of available widgets will be discussed later. Each field type has a default widget.</div><div class=""> - ``label`` is a string (or something that can be serialized to a string) that contains the label to be used for this field in autogenerated forms.</div><div class=""> - ``comment``  is a string (or something that can be serialized to a string) that contains a comment associated with this field, and will be displayed to the right of the input field in the autogenerated forms.</div><div class=""> - ``writable`` if a field is writable, it can be edited in autogenerated create and update forms.</div><div class=""> - ``readable`` if a field is readable, it will be visible in readonly forms. If a field is neither readable nor writable, it will not be displayed in create and update forms.</div><div class=""> - ``update`` contains the default value for this field when the record is updated.</div><div class=""> - ``compute`` is an optional function. If a record is inserted or updated, the compute function will be executed and the field will be populated with the function result. The record is passed to the compute function as a ``dict``, and the dict will not include the current value of that, or any other compute field.</div><div class=""> - ``authorize`` can be used to require access control on the corresponding field, for &quot;upload&quot; fields only. It will be discussed more in detail in the context of Authentication and Authorization.</div><div class=""> - ``autodelete`` determines if the corresponding uploaded file should be deleted when the record referencing the file is deleted. For &quot;upload&quot; fields only.</div><div class=""> - ``represent`` can be None or can point to a function that takes a field value and returns an alternate representation for the field value. Examples:</div><div class=""> ``</div><div class=""> db.mytable.name.represent = lambda name,row: name.capitalize()</div><div class=""> db.mytable.other_id.represent = lambda id,row: row.myfield</div><div class=""> db.mytable.some_uploadfield.represent = lambda value,row: \</div><div class="">     A(&#x27;get it&#x27;, _href=URL(&#x27;download&#x27;, args=value))</div><div class=""> ``:code</div><div class=""> </div><div class=""> ``blob``:inxx</div><div class=""> &quot;blob&quot; fields are also special. By default, binary data is encoded in base64 before being stored into the actual database field, and it is decoded when extracted. This has the negative effect of using 25% more storage space than necessary in blob fields, but has two advantages. On average it reduces the amount of data communicated between web2py and the database server, and it makes the communication independent of back-end-specific escaping conventions.</div><div class=""> </div><div class=""> Insert returns the unique &quot;id&quot; value of each record inserted.</div><div class=""> </div><div class=""> You can truncate the table, i.e., delete all records and reset the counter of the id.</div><div class=""> </div><div class=""> ``truncate``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.person.truncate()</div><div class=""> ``:code</div><div class=""> </div><div class=""> Now, if you insert a record again, the counter starts again at 1 (this is back-end specific and does not apply to Google NoSQL):</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.person.insert(name=&quot;Alex&quot;)</div><div class=""> 1</div><div class=""> ``:code</div><div class=""> </div><div class=""> Notice you can pass parameters to ``truncate``, for example you can tell SQLITE to restart the id counter.</div><div class=""> </div><div class=""> ``</div><div class=""> db.person.truncate(&#x27;RESTART IDENTITY CASCADE&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class="delete">The argument is in raw SQL and the<span class="highlight"></span>f<span class="highlight">e</span>ore engine specific.</div><div class=""> </div><div class=""> ``bulk_insert``:inxx</div><div class=""> web2py also provides a bulk_insert method</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.person.bulk_insert([{&#x27;name&#x27;:&#x27;Alex&#x27;}, {&#x27;name&#x27;:&#x27;John&#x27;}, {&#x27;name&#x27;:&#x27;Tim&#x27;}])</div><div class=""> [3,4,5]</div><div class=""> ``:code</div><div class=""> </div><div class=""> It takes a list of dictionaries of fields to be inserted and performs multiple inserts at once. It returns the IDs of the inserted records. On the supported relational databases there is no advantage in using this function as opposed to looping and performing individual inserts but on Google App Engine NoSQL, there is a major speed advantage.</div><div class=""> </div><div class=""> ### ``commit`` and ``rollback``</div><div class=""> </div><div class=""> No create, drop, insert, truncate, delete, or update operation is actually committed until you issue the commit command</div><div class=""> </div><div class=""> ``commit``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.commit()</div><div class=""> ``:code</div><div class=""> </div><div class=""> To check it let&#x27;s insert a new record:</div><div class=""> are equivalent to</div><div class=""> </div><div class=""> #### ``as_dict`` and ``as_list``</div><div class=""> ``as_list``:inxx ``as_dict``:inxx</div><div class=""> </div><div class=""> A Row object can be serialized into a regular dictionary using the ``as_dict()`` method and a Rows object can be serialized into a list of dictionaries using the ``as_list()`` method. Here are some examples:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows = db(query).select()</div><div class=""> &gt;&gt;&gt; rows_list = rows.as_list()</div><div class=""> &gt;&gt;&gt; first_row_dict = rows.first().as_dict()</div><div class=""> ``:code</div><div class=""> </div><div class=""> These methods are convenient for passing Rows to generic views and or to store Rows in sessions (since Rows objects themselves cannot be serialized since contain a reference to an open DB connection):</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows = db(query).select()</div><div class=""> &gt;&gt;&gt; session.rows = rows # not allowed!</div><div class=""> &gt;&gt;&gt; session.rows = rows.as_list() # allowed!</div><div class=""> ``:code</div><div class=""> </div><div class=""> #### Combining rows</div><div class=""> </div><div class="delete">Row objects can be co<span class="highlight">n</span>bined at the Python level. Here we assume:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; print rows1</div><div class=""> person.name</div><div class=""> Max</div><div class=""> Tim</div><div class=""> &gt;&gt;&gt; print rows2</div><div class=""> person.name</div><div class=""> John</div><div class=""> Tim</div><div class=""> ``</div><div class=""> </div><div class=""> </div><div class=""> You can do a union of the records in two set of rows:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows3 = rows1 &amp; rows2</div><div class=""> &gt;&gt;&gt; print rows3</div><div class=""> name</div><div class=""> Max</div><div class=""> Max</div><div class=""> &gt;&gt;&gt; print len(rows)</div><div class=""> 2</div><div class=""> &gt;&gt;&gt; for row in rows.sort(lambda row: row.name):</div><div class="">         print row.name</div><div class=""> Alex</div><div class=""> John</div><div class=""> ``:code</div><div class=""> </div><div class=""> They can be combined:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows = db(db.person).select()</div><div class=""> &gt;&gt;&gt; rows = rows.find(</div><div class="">         lambda row: &#x27;x&#x27; in row.name).sort(</div><div class="">             lambda row: row.name)</div><div class=""> &gt;&gt;&gt; for row in rows:</div><div class="">         print row.name</div><div class=""> Alex</div><div class=""> Max</div><div class=""> ``:code</div><div class=""> </div><div class="delete">Sort takes an optional arg<span class="highlight"></span>ment ``reverse=True`` which an obvious meaning.</div><div class=""> </div><div class=""> The ``find`` method as an optional limitby argument with the same syntax and functionality as the Set select ``method``.</div><div class=""> </div><div class=""> </div><div class=""> </div><div class=""> ### Other methods</div><div class=""> </div><div class=""> #### ``update_or_insert``</div><div class=""> ``update_or_insert``:inxx</div><div class=""> </div><div class=""> Some times you need to perform an insert only if there is no record with the same values as those being inserted.</div><div class=""> This can be done with</div><div class=""> </div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;,Field(&#x27;name&#x27;),Field(&#x27;birthplace&#x27;))</div><div class=""> db.person.update_or_insert(name=&#x27;John&#x27;,birthplace=&#x27;Chicago&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> The record will be inserted only of there is no other user called John born in Chicago.</div><div class=""> </div><div class=""> In the following example, you see a controller that caches a select on the previ</div><div class=""> ``</div><div class=""> def cache_db_select():</div><div class="">     logs = db().select(db.log.ALL, cache=(cache.ram, 60))</div><div class="">     return dict(logs=logs)</div><div class=""> ``:code</div><div class=""> </div><div class=""> ``cacheable``:inxx</div><div class=""> </div><div class=""> The ``select`` method has an optional ``cacheable`` argument, normally set to ``False``. When ``cacheable=True`` the resulting ``Rows`` is serializable but The ``Row``s lack ``update_record`` and ``delete_record`` methods.</div><div class=""> </div><div class=""> If you do not need these methods you can speed up selects a lot by setting the cacheable attribute:</div><div class=""> </div><div class=""> ``</div><div class=""> rows = db(query).select(cacheable=True)</div><div class=""> ``:code</div><div class=""> </div><div class=""> -------</div><div class=""> The results of a ``select`` are normally complex, un-pickleable objects; they cannot be stored in a session and cannot be cached in any other way than the one explained here unless the ``cache`` attribute is set or ``cacheable=True``.</div><div class=""> -------</div><div class=""> </div><div class="delete">When the ``cache`` argument is set but ``cacheable=False`` (default) only the database results are cached, not the actual Rows object. When the ``cache`` argument is used in conju<span class="highlight"></span>ction with ``cacheable=True`` the entire Rows object is cached and this results in much baster caching:</div><div class=""> </div><div class=""> ``</div><div class=""> rows = db(query).select(cache=(cache.ram,3600),cacheable=True)</div><div class=""> ``:code</div><div class=""> </div><div class=""> ### Self-Reference and aliases</div><div class=""> </div><div class=""> ``self reference``:inxx</div><div class=""> ``alias``:inxx</div><div class=""> It is possible to define tables with fields that refer to themselves, here is an example:</div><div class=""> ``reference table``:inxx</div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;,</div><div class="">     Field(&#x27;name&#x27;),</div><div class="">     Field(&#x27;father_id&#x27;, &#x27;reference person&#x27;),</div><div class="">     Field(&#x27;mother_id&#x27;, &#x27;reference person&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class="delete">Notice that the alter<span class="highlight"></span>a<span class="highlight">n</span>tive notation of using a table object as field type will fail in this case, because it uses a variable ``db.person`` before it is defined:</div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;,</div><div class="">     Field(&#x27;name&#x27;),</div><div class="">     Field(&#x27;father_id&#x27;, db.person), # wrong!</div><div class="">     Field(&#x27;mother_id&#x27;, db.person)) # wrong!</div><div class=""> ``:code</div><div class=""> </div><div class=""> In general ``db.tablename`` and ``&quot;reference tablename&quot;`` are equivalent field types, but the latter is the only one allowed for self.references.</div><div class=""> </div><div class=""> ``with_alias``:inxx</div><div class=""> If the table refers to itself, then it is not possible to perform a JOIN to select a person and its parents without use of the SQL &quot;AS&quot; keyword. This is achieved in web2py using the ``with_alias``. Here is an example:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; Father = db.person.with_alias(&#x27;father&#x27;)</div><div class=""> &gt;&gt;&gt; Mother = db.person.with_alias(&#x27;mother&#x27;)</div><div class=""> &gt;&gt;&gt; db.person.insert(name=&#x27;Massimo&#x27;)</div><div class=""> 1</div><div class=""> &gt;&gt;&gt; db.person.insert(name=&#x27;Claudia&#x27;)</div><div class=""> 2</div><div class=""> &gt;&gt;&gt; db.person.insert(name=&#x27;Marco&#x27;, father_id=1, mother_id=2)</div><div class=""> 3</div><div class=""> db = DAL(&#x27;sqlite://storage.sqlite&#x27;,folder=&#x27;path/to/app/databases&#x27;)</div><div class=""> </div><div class=""> i.e. import the DAL, Field, connect and specify the folder which contains the .table files (the app/databases folder).</div><div class=""> </div><div class=""> To access the data and its attributes we still have to define all the tables we are going to access with ``db.define_tables(...)``.</div><div class=""> </div><div class=""> If we just need access to the data but not to the web2py table attributes, we get away without re-defining the tables but simply asking web2py to read the necessary info from the metadata in the .table files:</div><div class=""> </div><div class=""> ``</div><div class=""> from gluon import DAL, Field</div><div class=""> db = DAL(&#x27;sqlite://storage.sqlite&#x27;,folder=&#x27;path/to/app/databases&#x27;,</div><div class="">          auto_import=True))</div><div class=""> ``:code</div><div class=""> </div><div class=""> This allows us to access any ``db.table`` without need to re-define it.</div><div class=""> </div><div class=""> #### PostGIS, SpatiaLite, and MS Geo (experimental)</div><div class=""> </div><div class=""> ``PostGIS``:inxx ``StatiaLite``:inxx ``Geo Extensions``:inxx</div><div class=""> ``geometry``:inxx ``geoPoint``:inxx ``geoLine``:inxx ``geoPolygon``:inxx</div><div class=""> </div><div class="delete">The DAL supports geographical APIs using PostGIS (for PostgreSQL), spatialite (for SQLite), and MSSQL and Spatial Extensions. This is a feature that was spon<span class="highlight">os</span>red by the Sahana project and implemented by Denes Lengyel.</div><div class=""> </div><div class=""> DAL provides geometry and geography fields types and the following functions:</div><div class=""> </div><div class=""> ``st_asgeojson``:inxx ``st_astext``:inxx ``st_contained``:inxx ``st_contains``:inxx</div><div class=""> ``st_distance``:inxx ``st_equals``:inxx ``st_intersects``:inxx ``st_overlaps``:inxx</div><div class=""> ``st_simplify``:inxx ``st_touches``:inxx ``st_within``:inxx</div><div class=""> </div><div class=""> ``</div><div class=""> st_asgeojson (PostGIS only)</div><div class=""> st_astext</div><div class=""> st_contained</div><div class=""> st_contains</div><div class=""> st_distance</div><div class=""> st_equals</div><div class=""> st_intersects</div><div class=""> st_overlaps</div><div class=""> st_simplify (PostGIS only)</div><div class=""> st_touches</div><div class=""> st_within</div><div class=""> ``</div><div class=""> Here are some examples:</div><div class=""> </div><div class=""> ``</div><div class=""> from gluon.dal import DAL, Field, geoPoint, geoLine, geoPolygon</div><div class=""> db = DAL(&quot;mssql://user:pass@host:db&quot;)</div><div class=""> sp = db.define_table(&#x27;spatial&#x27;, Field(&#x27;loc&#x27;,&#x27;geometry()&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class=""> Below we insert a point, a line, and a polygon:</div><div class=""> ``</div><div class=""> sp.insert(loc=geoPoint(1,1))</div><div class=""> sp.insert(loc=geoLine((100,100),(20,180),(180,180)))</div><div class=""> sp.insert(loc=geoPolygon((0,0),(150,0),(150,150),(0,150),(0,0)))</div><div class=""> ``:code</div><div class=""> </div><div class=""> Notice that</div><div class=""> ``</div><div class=""> rows = db(sp.id&gt;0).select()</div><div class=""> ``:code</div><div class=""> </div><div class=""> Always returns the geometry data serialized as text.</div><div class="delete">You can also do the same more explicit<span class="highlight">e</span>ly using ``st_astext()``:</div><div class=""> </div><div class=""> ``</div><div class=""> print db(sp.id&gt;0).select(sp.id, sp.loc.st_astext())</div><div class=""> spatial.id,spatial.loc.STAsText()</div><div class=""> 1, &quot;POINT (1 2)&quot;</div><div class=""> 2, &quot;LINESTRING (100 100, 20 180, 180 180)&quot;</div><div class=""> 3, &quot;POLYGON ((0 0, 150 0, 150 150, 0 150, 0 0))&quot;</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can ask for the native representation by using ``st_asgeojson()`` (in PostGIS only):</div><div class=""> </div><div class=""> ``</div><div class=""> print db(sp.id&gt;0).select(sp.id, sp.loc.st_asgeojson().with_alias(&#x27;loc&#x27;))</div><div class=""> spatial.id,loc</div><div class=""> 1, [1, 2]</div><div class=""> 2, [[100, 100], [20 180], [180, 180]]</div><div class=""> 3, [[[0, 0], [150, 0], [150, 150], [0, 150], [0, 0]]]</div><div class=""> ``:code</div><div class=""> </div><div class=""> (notice an array is a point, an array of arrays is a line, and an array of array of arrays is a polygon).</div><div class=""> </div><div class=""> Here are example of how to use geographical functions:</div><div class=""> </div><div class=""> ``</div><div class=""> query = sp.loc.st_intersects(geoLine((20,120),(60,160)))</div><div class=""> query = sp.loc.st_overlaps(geoPolygon((1,1),(11,1),(11,11),(11,1),(1,1)))</div><div class=""> query = sp.loc.st_contains(geoPoint(1,1))</div><div class=""> print db(query).select(sp.id,sp.loc)</div><div class=""> spatial.id,spatial.loc</div><div class="delete">3,&quot;POLYG<span class="highlight">N</span>ON ((0 0, 150 0, 150 150, 0 150, 0 0))&quot;</div><div class=""> ``:code</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/ae63889d5e5f406babdda11f1b0123978eb4603f">ae63889</a><ul><li>Date : 2012-12-28</li><li>added **{} ntation</li></ul></li></ul>
<div class="row-fluid" id="com_ae63889d5e5f406babdda11f1b0123978eb4603f">
    <div class="span6"><div class="diff"><div class="insert">+#### Inserting and updating from a dictionary</div><div class="insert">+</div><div class="insert">+A common issue consists of needing to insert or update records in a table where the name of the table, the field to be updated, and the value for the field are all stored in variables. For example: ``tablename``, ``fieldname``, and ``value``.</div><div class="insert">+</div><div class="insert">+The insert can be done using the following syntax:</div><div class="insert">+</div><div class="insert">+``</div><div class="insert">+db[tablename].insert(**{fieldname:value})</div><div class="insert">+``:</div><div class="insert">+</div><div class="insert">+The update of record with given id can be done with: ``_id``:inxx</div><div class="insert">+</div><div class="insert">+``</div><div class="insert">+db(db[tablename]._id==id).update(**{fieldname:value})</div><div class="insert">+``:code</div><div class="insert">+</div><div class="insert">+Notice we used ``table._id`` instead of ``table.id``. In this way the query works even for tables with a field of type &quot;id&quot; which has a name other than &quot;id&quot;.</div><div class="insert">+</div><div class="insert">+</div><div class=""> #### ``first`` and ``last``</div><div class=""> ``first``:inxx ``last``:inxx</div></div></div>
    <div class="span6"><div class="diff"><div class=""> #### ``first`` and ``last``</div><div class=""> ``first``:inxx ``last``:inxx</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/c482e34c27660c375ad9174f7c87d3df40a6eb62">c482e34</a><ul><li>Date : 2012-12-28</li><li>Typos</li></ul></li></ul>
<div class="row-fluid" id="com_c482e34c27660c375ad9174f7c87d3df40a6eb62">
    <div class="span6"><div class="diff"><div class=""> - ``primarykey`` is a list of the field names that make up the primary key.</div><div class=""> - All primarykey fields have a ``NOT NULL`` set even if not specified.</div><div class="insert">- Keyed table<span class="highlight">s</span> can only refer<span class="highlight"></span>e<span class="highlight">nce</span> other keyed tables.</div><div class=""> - Referencing fields must use the ``reference tablename.fieldname`` format.</div><div class=""> - The ``update_record`` function is not available for Rows of keyed tables.</div><div class=""> </div><div class=""> -------</div><div class=""> Note that currently this is only available for DB2, MS-SQL, Ingres and Informix, but others can be easily added.</div><div class=""> -------</div><div class=""> </div><div class=""> At the time of writing, we cannot guarantee that the ``primarykey`` attribute works with every existing legacy table and every supported database backend.</div><div class=""> For simplicity, we recommend, if possible, creating a database view that has an auto-increment id field.</div><div class=""> </div><div class=""> </div><div class=""> ### Distributed transaction</div><div class=""> ``distributed transactions``:inxx</div><div class=""> </div><div class=""> ------</div><div class=""> At the time of writing this feature is only supported</div><div class=""> by PostgreSQL, MySQL and Firebird, since they expose API for two-phase commits.</div><div class=""> ------</div><div class=""> </div><div class=""> Assuming you have two (or more) connections to distinct PostgreSQL databases, for example:</div><div class=""> It is possible to create a table that contains all the fields from another table</div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;))</div><div class=""> db.define_table(&#x27;doctor&#x27;, db.person, Field(&#x27;specialization&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class=""> ``dummy table``:inxx</div><div class=""> It is also possible to define a dummy table that is not stored in a database in order to reuse it in multiple other places. For example:</div><div class=""> </div><div class=""> ``</div><div class=""> signature = db.Table(db, &#x27;signature&#x27;,</div><div class="">     Field(&#x27;created_on&#x27;, &#x27;datetime&#x27;, default=request.now),</div><div class="">     Field(&#x27;created_by&#x27;, db.auth_user, default=auth.user_id),</div><div class="">     Field(&#x27;updated_on&#x27;, &#x27;datetime&#x27;, update=request.now),</div><div class="">     Field(&#x27;updated_by&#x27;, db.auth_user, update=auth.user_id))</div><div class=""> </div><div class=""> db.define_table(&#x27;payment&#x27;, Field(&#x27;amount&#x27;, &#x27;double&#x27;), signature)</div><div class=""> ``:code</div><div class=""> </div><div class=""> This example assumes that standard web2py authentication is enabled.</div><div class=""> </div><div class="insert">Notice that if you use<span class="highlight"></span> ``Auth`` web2py already creates one such table for you:</div><div class=""> </div><div class=""> ``</div><div class=""> auth = Auth(db)</div><div class=""> db.define_table(&#x27;payment&#x27;, Field(&#x27;amount&#x27;, &#x27;double&#x27;), auth.signature)</div><div class=""> ``</div><div class=""> </div><div class=""> When using table inheritance, if you want the inheriting table to inherit validators, be sure to define the validators of the parent table before defining the inheriting table.</div><div class=""> </div><div class=""> #### ``filter_in`` and ``filter_out``</div><div class=""> ``filter_in``:inxx ``filter_out``:inxx</div><div class=""> </div><div class=""> It is possible to define a filter for each field to be called before a value is inserted into the database for that field and after a value is retrieved from the database.</div><div class=""> </div><div class=""> Imagine for example that you want to store a serializable Python data structure in a field in the json format. Here is how it could be accomplished:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; from simplejson import loads, dumps</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;anyobj&#x27;,Field(&#x27;name&#x27;),Field(&#x27;data&#x27;,&#x27;text&#x27;))</div><div class=""> &gt;&gt;&gt; db.anyobj.data.filter_in = lambda obj, dumps=dumps: dumps(obj)</div><div class=""> &gt;&gt;&gt; db.anyobj.data.filter_out = lambda txt, loads=loads: loads(txt)</div><div class=""> For this purpose there the Set objects have an ``update_naive`` method that work</div><div class=""> </div><div class=""> It is possible to ask web2py to save every copy of a record when the record is modified. There are different ways to do it and it can be done for all tables at once using the syntax:</div><div class=""> </div><div class=""> ``</div><div class=""> auth.enable_record_versioning(db)</div><div class=""> ``:code</div><div class=""> </div><div class=""> this requires Auth and it is discussed in the chapter about authentication.</div><div class=""> It can also be done for each individual table as discussed below.</div><div class=""> </div><div class=""> Consider the following table:</div><div class=""> </div><div class=""> ``</div><div class=""> db.define_table(&#x27;stored_item&#x27;,</div><div class="">     Field(&#x27;name&#x27;),</div><div class="">     Field(&#x27;quantity&#x27;,&#x27;integer&#x27;),</div><div class="">     Field(&#x27;is_active&#x27;,&#x27;boolean&#x27;,</div><div class="">           writable=False,readable=False,default=True))</div><div class=""> ``:code</div><div class=""> </div><div class="insert">Notic<span class="highlight"></span>e the hidden boolean field called ``is_active`` and defaulting to</div><div class=""> True.</div></div></div>
    <div class="span6"><div class="diff"><div class=""> - ``primarykey`` is a list of the field names that make up the primary key.</div><div class=""> - All primarykey fields have a ``NOT NULL`` set even if not specified.</div><div class="delete">- Keyed table<span class="highlight"></span> can only refer<span class="highlight"> ar</span>e<span class="highlight"> to</span> other keyed tables.</div><div class=""> - Referencing fields must use the ``reference tablename.fieldname`` format.</div><div class=""> - The ``update_record`` function is not available for Rows of keyed tables.</div><div class=""> </div><div class=""> -------</div><div class=""> Note that currently this is only available for DB2, MS-SQL, Ingres and Informix, but others can be easily added.</div><div class=""> -------</div><div class=""> </div><div class=""> At the time of writing, we cannot guarantee that the ``primarykey`` attribute works with every existing legacy table and every supported database backend.</div><div class=""> For simplicity, we recommend, if possible, creating a database view that has an auto-increment id field.</div><div class=""> </div><div class=""> </div><div class=""> ### Distributed transaction</div><div class=""> ``distributed transactions``:inxx</div><div class=""> </div><div class=""> ------</div><div class=""> At the time of writing this feature is only supported</div><div class=""> by PostgreSQL, MySQL and Firebird, since they expose API for two-phase commits.</div><div class=""> ------</div><div class=""> </div><div class=""> Assuming you have two (or more) connections to distinct PostgreSQL databases, for example:</div><div class=""> It is possible to create a table that contains all the fields from another table</div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;))</div><div class=""> db.define_table(&#x27;doctor&#x27;, db.person, Field(&#x27;specialization&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class=""> ``dummy table``:inxx</div><div class=""> It is also possible to define a dummy table that is not stored in a database in order to reuse it in multiple other places. For example:</div><div class=""> </div><div class=""> ``</div><div class=""> signature = db.Table(db, &#x27;signature&#x27;,</div><div class="">     Field(&#x27;created_on&#x27;, &#x27;datetime&#x27;, default=request.now),</div><div class="">     Field(&#x27;created_by&#x27;, db.auth_user, default=auth.user_id),</div><div class="">     Field(&#x27;updated_on&#x27;, &#x27;datetime&#x27;, update=request.now),</div><div class="">     Field(&#x27;updated_by&#x27;, db.auth_user, update=auth.user_id))</div><div class=""> </div><div class=""> db.define_table(&#x27;payment&#x27;, Field(&#x27;amount&#x27;, &#x27;double&#x27;), signature)</div><div class=""> ``:code</div><div class=""> </div><div class=""> This example assumes that standard web2py authentication is enabled.</div><div class=""> </div><div class="delete">Notice that if you use<span class="highlight">r</span> ``Auth`` web2py already creates one such table for you:</div><div class=""> </div><div class=""> ``</div><div class=""> auth = Auth(db)</div><div class=""> db.define_table(&#x27;payment&#x27;, Field(&#x27;amount&#x27;, &#x27;double&#x27;), auth.signature)</div><div class=""> ``</div><div class=""> </div><div class=""> When using table inheritance, if you want the inheriting table to inherit validators, be sure to define the validators of the parent table before defining the inheriting table.</div><div class=""> </div><div class=""> #### ``filter_in`` and ``filter_out``</div><div class=""> ``filter_in``:inxx ``filter_out``:inxx</div><div class=""> </div><div class=""> It is possible to define a filter for each field to be called before a value is inserted into the database for that field and after a value is retrieved from the database.</div><div class=""> </div><div class=""> Imagine for example that you want to store a serializable Python data structure in a field in the json format. Here is how it could be accomplished:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; from simplejson import loads, dumps</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;anyobj&#x27;,Field(&#x27;name&#x27;),Field(&#x27;data&#x27;,&#x27;text&#x27;))</div><div class=""> &gt;&gt;&gt; db.anyobj.data.filter_in = lambda obj, dumps=dumps: dumps(obj)</div><div class=""> &gt;&gt;&gt; db.anyobj.data.filter_out = lambda txt, loads=loads: loads(txt)</div><div class=""> For this purpose there the Set objects have an ``update_naive`` method that work</div><div class=""> </div><div class=""> It is possible to ask web2py to save every copy of a record when the record is modified. There are different ways to do it and it can be done for all tables at once using the syntax:</div><div class=""> </div><div class=""> ``</div><div class=""> auth.enable_record_versioning(db)</div><div class=""> ``:code</div><div class=""> </div><div class=""> this requires Auth and it is discussed in the chapter about authentication.</div><div class=""> It can also be done for each individual table as discussed below.</div><div class=""> </div><div class=""> Consider the following table:</div><div class=""> </div><div class=""> ``</div><div class=""> db.define_table(&#x27;stored_item&#x27;,</div><div class="">     Field(&#x27;name&#x27;),</div><div class="">     Field(&#x27;quantity&#x27;,&#x27;integer&#x27;),</div><div class="">     Field(&#x27;is_active&#x27;,&#x27;boolean&#x27;,</div><div class="">           writable=False,readable=False,default=True))</div><div class=""> ``:code</div><div class=""> </div><div class="delete">Notic<span class="highlight">e w</span>e the hidden boolean field called ``is_active`` and defaulting to</div><div class=""> True.</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/95763bdcd5e83fb4b924ac8f71b00c67b2661dc7">95763bd</a><ul><li>Date : 2012-12-28</li><li>added some images</li></ul></li></ul>
<div class="row-fluid" id="com_95763bdcd5e83fb4b924ac8f71b00c67b2661dc7">
    <div class="span6"><div class="diff"><div class="insert">+</div><div class=""> ### Record representation</div></div></div>
    <div class="span6"><div class="diff"><div class=""> ### Record representation</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/097d699dc16179206ccb7e4aee863d6523cd471c">097d699</a><ul><li>Date : 2012-12-27</li><li>fixed typo, thanks Andrew</li></ul></li></ul>
<div class="row-fluid" id="com_097d699dc16179206ccb7e4aee863d6523cd471c">
    <div class="span6"><div class="diff"><div class="insert">The second argument of the DAL constructor is the ``pool_size``; it defaults to <span class="highlight">zero</span>.</div><div class=""> </div><div class=""> As it is rather slow to establish a new database connection for each request, web2py implements a mechanism for connection pooling. Once a connection is established and the page has been served and the transaction completed, the connection is not closed but goes into a pool. When the next http request arrives, web2py tries to obtain a connection from the pool and use that for the new transaction. If there are no available connections in the pool, a new connection is established.</div><div class=""> </div><div class=""> The ``pool_size`` parameter is ignored by SQLite and Google App Engine.</div><div class=""> </div><div class=""> Connections in the pools are shared sequentially among threads, in the sense that they may be used by two different but not simultaneous threads. There is only one pool for each web2py process.</div><div class=""> </div><div class=""> When web2py starts, the pool is always empty. The pool grows up to the minimum between the value of ``pool_size`` and the max number of concurrent requests. This means that if ``pool_size=10`` but our server never receives more than 5 concurrent requests, then the actual pool size will only grow to 5. If ``pool_size=0`` then connection pooling is not used.</div><div class=""> </div><div class=""> Connection pooling is ignored for SQLite, since it would not yield any benefit.</div><div class=""> </div><div class=""> #### Connection failures</div><div class=""> </div><div class=""> If web2py fails to connect to the database it waits 1 seconds and tries again up to 5 times before declaring a failure. In case of connection pooling it is possible that a pooled connection that stays open but unused for some time is closed by the database end. Thanks to the retry feature web2py tries to re-establish these dropped connections.</div><div class=""> </div><div class=""> When using connection pooling a connection is used, put back in the pool and then recycled. It is possible that while the connection is idle in pool the connection is closed by the database server. This can be because of a malfunction or a timeout. When this happens web2py detects it and re-establish the connection.</div><div class=""> </div><div class=""> #### Replicated databases</div><div class=""> </div><div class=""> The first argument of ``DAL(...)`` can be a list of URIs. In this case web2py tries to connect to each of them. The main purpose for this is to deal with multiple database servers and distribute the workload among them). Here is a typical use case:</div><div class=""> If you now insert again, the counter will again be set to 2, since the previous</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.person.insert(name=&quot;Bob&quot;)</div><div class=""> 2</div><div class=""> ``:code</div><div class=""> </div><div class=""> Code in models, views and controllers is enclosed in web2py code that looks like this:</div><div class=""> ``</div><div class=""> try:</div><div class="">      execute models, controller function and view</div><div class=""> except:</div><div class="">      rollback all connections</div><div class="">      log the traceback</div><div class="">      send a ticket to the visitor</div><div class=""> else:</div><div class="">      commit all connections</div><div class="">      save cookies, sessions and return the page</div><div class=""> ``:code</div><div class=""> </div><div class=""> There is no need to ever call ``commit``  or ``rollback`` explicitly in web2py unless one needs more granular control.</div><div class=""> </div><div class="insert">### Raw <span class="highlight">SQL</span></div><div class=""> </div><div class=""> #### Timing queries</div><div class=""> </div><div class=""> All queries are automatically timed by web2py. The variable ``db._timings`` is a list of tuples. Each tuple contains the raw SQL query as passed to the database driver and the time it took to execute in seconds. This variable can be displayed in views using the toolbar:</div><div class=""> </div><div class=""> ``</div><div class=""> {{=response.toolbar()}}</div><div class=""> ``</div><div class=""> </div><div class=""> #### ``executesql``</div><div class=""> </div><div class=""> The DAL allows you to explicitly issue SQL statements.</div><div class=""> </div><div class=""> ``executesql``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; print db.executesql(&#x27;SELECT * FROM person;&#x27;)</div><div class=""> [(1, u&#x27;Massimo&#x27;), (2, u&#x27;Massimo&#x27;)]</div><div class=""> ``:code</div><div class=""> </div><div class=""> In this case, the return values are not parsed or transformed by the DAL, and the format depends on the specific database driver. This usage with selects is normally not needed, but it is more common with indexes.</div><div class=""> ret = db.mytable.validate_and_insert(field=&#x27;value&#x27;)</div><div class=""> works very much like</div><div class=""> </div><div class=""> ``</div><div class=""> id = db.mytable.insert(field=&#x27;value&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> except that it calls the validators for the fields before performing the insert and bails out if the validation does not pass. If validation does not pass the errors can be found in ``ret.error``. If it passes, the id of the new record is in ``ret.id``. Mind that normally validation is done by the form processing logic so this function is rarely needed.</div><div class=""> </div><div class=""> Similarly</div><div class=""> </div><div class=""> ``</div><div class=""> ret = db(query).validate_and_update(field=&#x27;value&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> works very much the same as</div><div class=""> </div><div class=""> ``</div><div class=""> num = db(query).update(field=&#x27;value&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class="insert">except that it calls the validators for<span class="highlight">        </span>the fields before performing the update. Notice that it only works if query involves a single table. The number of updated records can be found in ``res.updated`` and errors will be ``ret.errors``.</div><div class=""> </div><div class=""> #### ``smart_query`` (experimental)</div><div class=""> </div><div class=""> There are times when you need to parse a query using natural language such as</div><div class=""> </div><div class=""> ``</div><div class=""> name contain m and age greater than 18</div><div class=""> ``</div><div class=""> </div><div class=""> The DAL provides a method to parse this type of queries:</div><div class=""> </div><div class=""> ``</div><div class=""> search = &#x27;name contain m and age greater than 18&#x27;</div><div class=""> rows = db.smart_query([db.person],search).select()</div><div class=""> ``</div><div class=""> </div><div class=""> The first argument must be a list of tables or fields that should be allowed in the search. It raises a ``RuntimeError`` if the search string is invalid. This functionality can be used to build RESTful interfaces (see chapter 10) and it is used internally by the ``SQLFORM.grid`` and ``SQLFORM.smartgrid``.</div><div class=""> </div><div class=""> In the smartquery search string, a field can be identified by fieldname only and or by tablename.fieldname. Strings may be delimited by double quotes if they contain spaces.</div><div class=""> </div><div class=""> DAL provides geometry and geography fields types and the following functions:</div><div class=""> </div><div class=""> ``</div><div class=""> st_asgeojson (PostGIS only)</div><div class=""> st_astext</div><div class=""> st_contained</div><div class=""> st_contains</div><div class=""> st_distance</div><div class=""> st_equals</div><div class=""> st_intersects</div><div class=""> st_overlaps</div><div class=""> st_simplify (PostGIS only)</div><div class=""> st_touches</div><div class=""> st_within</div><div class=""> ``</div><div class=""> </div><div class=""> Here are some examples:</div><div class=""> </div><div class=""> ``</div><div class=""> from gluon.dal import DAL, Field, geoPoint, geoLine, geoPolygon</div><div class=""> db = DAL(&quot;mssql://user:pass@host:db&quot;)</div><div class="insert"><span class="highlight">sp = db.define_table(&#x27;spatial&#x27;, Field(&#x27;loc&#x27;,&#x27;geometry(</span>)<span class="highlight">&#x27;))</span></div><div class=""> ``:code</div><div class=""> </div><div class=""> Below we insert a point, a line, and a polygon:</div><div class=""> ``</div><div class=""> sp.insert(loc=geoPoint(1,1))</div><div class=""> sp.insert(loc=geoLine((100,100),(20,180),(180,180)))</div><div class=""> sp.insert(loc=geoPolygon((0,0),(150,0),(150,150),(0,150),(0,0)))</div><div class=""> ``:code</div><div class=""> </div><div class=""> Notice that</div><div class=""> ``</div><div class=""> rows = db(sp.id&gt;0).select()</div><div class=""> ``:code</div><div class=""> </div><div class=""> Always returns the geometry data serialized as text.</div><div class=""> You can also do the same more explicitely using ``st_astext()``:</div><div class=""> </div><div class=""> ``</div><div class=""> print db(sp.id&gt;0).select(sp.id, sp.loc.st_astext())</div><div class=""> spatial.id,spatial.loc.STAsText()</div><div class="insert">+1, &quot;POINT (1 2)&quot;</div><div class="insert">+2, &quot;LINESTRING (100 100, 20 180, 180 180)&quot;</div><div class="insert">+3, &quot;POLYGON ((0 0, 150 0, 150 150, 0 150, 0 0))&quot;</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can ask for the native representation by using ``st_asgeojson()`` (in PostGIS only):</div><div class=""> </div><div class=""> ``</div><div class=""> print db(sp.id&gt;0).select(sp.id, sp.loc.st_asgeojson().with_alias(&#x27;loc&#x27;))</div><div class=""> spatial.id,loc</div><div class=""> 1, [1, 2]</div><div class=""> 2, [[100, 100], [20 180], [180, 180]]</div><div class=""> 3, [[[0, 0], [150, 0], [150, 150], [0, 150], [0, 0]]]</div><div class=""> ``:code</div><div class=""> </div><div class=""> (notice an array is a point, an array of arrays is a line, and an array of array of arrays is a polygon).</div><div class=""> </div><div class=""> Here are example of how to use geographical functions:</div><div class=""> </div><div class=""> ``</div><div class=""> query = sp.loc.st_intersects(geoLine((20,120),(60,160)))</div><div class=""> query = sp.loc.st_overlaps(geoPolygon((1,1),(11,1),(11,11),(11,1),(1,1)))</div><div class=""> query = sp.loc.st_contains(geoPoint(1,1))</div><div class=""> TeradataAdapter extends DB2Adapter (experimental)</div><div class=""> SAPDBAdapter extends BaseAdapter (experimental)</div><div class=""> CouchDBAdapter extends NoSQLAdapter (experimental)</div><div class=""> MongoDBAdapter extends NoSQLAdapter (experimental)</div><div class=""> ``</div><div class=""> </div><div class=""> which override the behavior of the ``BaseAdapter``.</div><div class=""> </div><div class=""> Each adapter has more or less this structure:</div><div class=""> </div><div class=""> ``</div><div class=""> class MySQLAdapter(BaseAdapter):</div><div class=""> </div><div class="">     # specify a diver to use</div><div class="">     driver = globals().get(&#x27;pymysql&#x27;,None)</div><div class=""> </div><div class="">     # map web2py types into database types</div><div class="">     types = {</div><div class="">         &#x27;boolean&#x27;: &#x27;CHAR(1)&#x27;,</div><div class="">         &#x27;string&#x27;: &#x27;VARCHAR(%(length)s)&#x27;,</div><div class="">         &#x27;text&#x27;: &#x27;LONGTEXT&#x27;,</div><div class="insert"><span class="highlight">        </span>...</div><div class="">         }</div><div class=""> </div><div class="">     # connect to the database using driver</div><div class="">     def __init__(self,db,uri,pool_size=0,folder=None,db_codec =&#x27;UTF-8&#x27;,</div><div class="">                 credential_decoder=lambda x:x, driver_args={},</div><div class="">                 adapter_args={}):</div><div class="">         # parse uri string and store parameters in driver_args</div><div class="">         ...</div><div class="">         # define a connection function</div><div class="">         def connect(driver_args=driver_args):</div><div class="">             return self.driver.connect(**driver_args)</div><div class="">         # place it in the pool</div><div class="">         self.pool_connection(connect)</div><div class="">         # set optional parameters (after connection)</div><div class="">         self.execute(&#x27;SET FOREIGN_KEY_CHECKS=1;&#x27;)</div><div class="">         self.execute(&quot;SET sql_mode=&#x27;NO_BACKSLASH_ESCAPES&#x27;;&quot;)</div><div class=""> </div><div class="">    # override BaseAdapter methods as needed</div><div class="">    def lastrowid(self,table):</div><div class="">         self.execute(&#x27;select last_insert_id();&#x27;)</div><div class=""> db =DAL(..., driver_args={}, adapter_args={})</div><div class=""> db = DAL(&#x27;mssql://....&#x27;)</div><div class=""> for key in [&#x27;reference&#x27;,&#x27;reference FK&#x27;]:</div><div class="">     db._adapter.types[key]=db._adapter.types[key].replace(</div><div class="">         &#x27;%(on_delete_action)s&#x27;,&#x27;NO ACTION&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> **MSSQL** also has problems with arguments passed to the DISTINCT keyword and therefore</div><div class="">  while this works,</div><div class=""> </div><div class=""> ``</div><div class=""> db(query).select(distinct=True)</div><div class=""> ``</div><div class=""> </div><div class=""> this does not</div><div class=""> </div><div class=""> ``</div><div class=""> db(query).select(distinct=db.mytable.myfield)</div><div class=""> ``</div><div class=""> </div><div class=""> **Google NoSQL (Datastore)** does not allow joins, left joins, aggregates, expression, OR involving more than one table, the like operator and search in &quot;text&quot;&quot; fields. Transactions are limited and not provided automatically by web2py (you need to use the Google API ``run_in_transaction`` which you can look up in the Google App Engine documentation online). Google also limits the number of records you can retrieve in each one query (1000 at the time of writing). On the Google datastore record IDs are integer but they are not sequential. While on SQL the &quot;list:string&quot; type is mapped into a &quot;text&quot; type, on the Google Datastore it is mapped into a ``ListStringProperty``. Similarly &quot;list:integer&quot; and &quot;list:reference&quot; are mapped into &quot;ListProperty&quot;. This makes that searches for content inside these fields types are more efficient on Google NoSQL than on SQL databases.</div></div></div>
    <div class="span6"><div class="diff"><div class="delete">The second argument of the DAL constructor is the ``pool_size``; it defaults to <span class="highlight">0</span>.</div><div class=""> </div><div class=""> As it is rather slow to establish a new database connection for each request, web2py implements a mechanism for connection pooling. Once a connection is established and the page has been served and the transaction completed, the connection is not closed but goes into a pool. When the next http request arrives, web2py tries to obtain a connection from the pool and use that for the new transaction. If there are no available connections in the pool, a new connection is established.</div><div class=""> </div><div class=""> The ``pool_size`` parameter is ignored by SQLite and Google App Engine.</div><div class=""> </div><div class=""> Connections in the pools are shared sequentially among threads, in the sense that they may be used by two different but not simultaneous threads. There is only one pool for each web2py process.</div><div class=""> </div><div class=""> When web2py starts, the pool is always empty. The pool grows up to the minimum between the value of ``pool_size`` and the max number of concurrent requests. This means that if ``pool_size=10`` but our server never receives more than 5 concurrent requests, then the actual pool size will only grow to 5. If ``pool_size=0`` then connection pooling is not used.</div><div class=""> </div><div class=""> Connection pooling is ignored for SQLite, since it would not yield any benefit.</div><div class=""> </div><div class=""> #### Connection failures</div><div class=""> </div><div class=""> If web2py fails to connect to the database it waits 1 seconds and tries again up to 5 times before declaring a failure. In case of connection pooling it is possible that a pooled connection that stays open but unused for some time is closed by the database end. Thanks to the retry feature web2py tries to re-establish these dropped connections.</div><div class=""> </div><div class=""> When using connection pooling a connection is used, put back in the pool and then recycled. It is possible that while the connection is idle in pool the connection is closed by the database server. This can be because of a malfunction or a timeout. When this happens web2py detects it and re-establish the connection.</div><div class=""> </div><div class=""> #### Replicated databases</div><div class=""> </div><div class=""> The first argument of ``DAL(...)`` can be a list of URIs. In this case web2py tries to connect to each of them. The main purpose for this is to deal with multiple database servers and distribute the workload among them). Here is a typical use case:</div><div class=""> If you now insert again, the counter will again be set to 2, since the previous</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.person.insert(name=&quot;Bob&quot;)</div><div class=""> 2</div><div class=""> ``:code</div><div class=""> </div><div class=""> Code in models, views and controllers is enclosed in web2py code that looks like this:</div><div class=""> ``</div><div class=""> try:</div><div class="">      execute models, controller function and view</div><div class=""> except:</div><div class="">      rollback all connections</div><div class="">      log the traceback</div><div class="">      send a ticket to the visitor</div><div class=""> else:</div><div class="">      commit all connections</div><div class="">      save cookies, sessions and return the page</div><div class=""> ``:code</div><div class=""> </div><div class=""> There is no need to ever call ``commit``  or ``rollback`` explicitly in web2py unless one needs more granular control.</div><div class=""> </div><div class="delete">### Raw <span class="highlight">sql</span></div><div class=""> </div><div class=""> #### Timing queries</div><div class=""> </div><div class=""> All queries are automatically timed by web2py. The variable ``db._timings`` is a list of tuples. Each tuple contains the raw SQL query as passed to the database driver and the time it took to execute in seconds. This variable can be displayed in views using the toolbar:</div><div class=""> </div><div class=""> ``</div><div class=""> {{=response.toolbar()}}</div><div class=""> ``</div><div class=""> </div><div class=""> #### ``executesql``</div><div class=""> </div><div class=""> The DAL allows you to explicitly issue SQL statements.</div><div class=""> </div><div class=""> ``executesql``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; print db.executesql(&#x27;SELECT * FROM person;&#x27;)</div><div class=""> [(1, u&#x27;Massimo&#x27;), (2, u&#x27;Massimo&#x27;)]</div><div class=""> ``:code</div><div class=""> </div><div class=""> In this case, the return values are not parsed or transformed by the DAL, and the format depends on the specific database driver. This usage with selects is normally not needed, but it is more common with indexes.</div><div class=""> ret = db.mytable.validate_and_insert(field=&#x27;value&#x27;)</div><div class=""> works very much like</div><div class=""> </div><div class=""> ``</div><div class=""> id = db.mytable.insert(field=&#x27;value&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> except that it calls the validators for the fields before performing the insert and bails out if the validation does not pass. If validation does not pass the errors can be found in ``ret.error``. If it passes, the id of the new record is in ``ret.id``. Mind that normally validation is done by the form processing logic so this function is rarely needed.</div><div class=""> </div><div class=""> Similarly</div><div class=""> </div><div class=""> ``</div><div class=""> ret = db(query).validate_and_update(field=&#x27;value&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> works very much the same as</div><div class=""> </div><div class=""> ``</div><div class=""> num = db(query).update(field=&#x27;value&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class="delete">except that it calls the validators for<span class="highlight">	</span>the fields before performing the update. Notice that it only works if query involves a single table. The number of updated records can be found in ``res.updated`` and errors will be ``ret.errors``.</div><div class=""> </div><div class=""> #### ``smart_query`` (experimental)</div><div class=""> </div><div class=""> There are times when you need to parse a query using natural language such as</div><div class=""> </div><div class=""> ``</div><div class=""> name contain m and age greater than 18</div><div class=""> ``</div><div class=""> </div><div class=""> The DAL provides a method to parse this type of queries:</div><div class=""> </div><div class=""> ``</div><div class=""> search = &#x27;name contain m and age greater than 18&#x27;</div><div class=""> rows = db.smart_query([db.person],search).select()</div><div class=""> ``</div><div class=""> </div><div class=""> The first argument must be a list of tables or fields that should be allowed in the search. It raises a ``RuntimeError`` if the search string is invalid. This functionality can be used to build RESTful interfaces (see chapter 10) and it is used internally by the ``SQLFORM.grid`` and ``SQLFORM.smartgrid``.</div><div class=""> </div><div class=""> In the smartquery search string, a field can be identified by fieldname only and or by tablename.fieldname. Strings may be delimited by double quotes if they contain spaces.</div><div class=""> </div><div class=""> DAL provides geometry and geography fields types and the following functions:</div><div class=""> </div><div class=""> ``</div><div class=""> st_asgeojson (PostGIS only)</div><div class=""> st_astext</div><div class=""> st_contained</div><div class=""> st_contains</div><div class=""> st_distance</div><div class=""> st_equals</div><div class=""> st_intersects</div><div class=""> st_overlaps</div><div class=""> st_simplify (PostGIS only)</div><div class=""> st_touches</div><div class=""> st_within</div><div class=""> ``</div><div class=""> </div><div class=""> Here are some examples:</div><div class=""> </div><div class=""> ``</div><div class=""> from gluon.dal import DAL, Field, geoPoint, geoLine, geoPolygon</div><div class=""> db = DAL(&quot;mssql://user:pass@host:db&quot;)</div><div class="delete">-sp = db.define_table(&#x27;spatial&#x27;,</div><div class="delete">-  Field(&#x27;loc&#x27;,&#x27;geometry()&#x27;)</div><div class="delete"><span class="highlight"></span>)<span class="highlight"></span></div><div class=""> ``:code</div><div class=""> </div><div class=""> Below we insert a point, a line, and a polygon:</div><div class=""> ``</div><div class=""> sp.insert(loc=geoPoint(1,1))</div><div class=""> sp.insert(loc=geoLine((100,100),(20,180),(180,180)))</div><div class=""> sp.insert(loc=geoPolygon((0,0),(150,0),(150,150),(0,150),(0,0)))</div><div class=""> ``:code</div><div class=""> </div><div class=""> Notice that</div><div class=""> ``</div><div class=""> rows = db(sp.id&gt;0).select()</div><div class=""> ``:code</div><div class=""> </div><div class=""> Always returns the geometry data serialized as text.</div><div class=""> You can also do the same more explicitely using ``st_astext()``:</div><div class=""> </div><div class=""> ``</div><div class=""> print db(sp.id&gt;0).select(sp.id, sp.loc.st_astext())</div><div class=""> spatial.id,spatial.loc.STAsText()</div><div class="delete">-1, POINT (1 2)&quot;</div><div class="delete">-2, LINESTRING (100 100, 20 180, 180 180)</div><div class="delete">-3, POLYGON ((0 0, 150 0, 150 150, 0 150, 0 0))</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can ask for the native representation by using ``st_asgeojson()`` (in PostGIS only):</div><div class=""> </div><div class=""> ``</div><div class=""> print db(sp.id&gt;0).select(sp.id, sp.loc.st_asgeojson().with_alias(&#x27;loc&#x27;))</div><div class=""> spatial.id,loc</div><div class=""> 1, [1, 2]</div><div class=""> 2, [[100, 100], [20 180], [180, 180]]</div><div class=""> 3, [[[0, 0], [150, 0], [150, 150], [0, 150], [0, 0]]]</div><div class=""> ``:code</div><div class=""> </div><div class=""> (notice an array is a point, an array of arrays is a line, and an array of array of arrays is a polygon).</div><div class=""> </div><div class=""> Here are example of how to use geographical functions:</div><div class=""> </div><div class=""> ``</div><div class=""> query = sp.loc.st_intersects(geoLine((20,120),(60,160)))</div><div class=""> query = sp.loc.st_overlaps(geoPolygon((1,1),(11,1),(11,11),(11,1),(1,1)))</div><div class=""> query = sp.loc.st_contains(geoPoint(1,1))</div><div class=""> TeradataAdapter extends DB2Adapter (experimental)</div><div class=""> SAPDBAdapter extends BaseAdapter (experimental)</div><div class=""> CouchDBAdapter extends NoSQLAdapter (experimental)</div><div class=""> MongoDBAdapter extends NoSQLAdapter (experimental)</div><div class=""> ``</div><div class=""> </div><div class=""> which override the behavior of the ``BaseAdapter``.</div><div class=""> </div><div class=""> Each adapter has more or less this structure:</div><div class=""> </div><div class=""> ``</div><div class=""> class MySQLAdapter(BaseAdapter):</div><div class=""> </div><div class="">     # specify a diver to use</div><div class="">     driver = globals().get(&#x27;pymysql&#x27;,None)</div><div class=""> </div><div class="">     # map web2py types into database types</div><div class="">     types = {</div><div class="">         &#x27;boolean&#x27;: &#x27;CHAR(1)&#x27;,</div><div class="">         &#x27;string&#x27;: &#x27;VARCHAR(%(length)s)&#x27;,</div><div class="">         &#x27;text&#x27;: &#x27;LONGTEXT&#x27;,</div><div class="delete"><span class="highlight">	</span>...</div><div class="">         }</div><div class=""> </div><div class="">     # connect to the database using driver</div><div class="">     def __init__(self,db,uri,pool_size=0,folder=None,db_codec =&#x27;UTF-8&#x27;,</div><div class="">                 credential_decoder=lambda x:x, driver_args={},</div><div class="">                 adapter_args={}):</div><div class="">         # parse uri string and store parameters in driver_args</div><div class="">         ...</div><div class="">         # define a connection function</div><div class="">         def connect(driver_args=driver_args):</div><div class="">             return self.driver.connect(**driver_args)</div><div class="">         # place it in the pool</div><div class="">         self.pool_connection(connect)</div><div class="">         # set optional parameters (after connection)</div><div class="">         self.execute(&#x27;SET FOREIGN_KEY_CHECKS=1;&#x27;)</div><div class="">         self.execute(&quot;SET sql_mode=&#x27;NO_BACKSLASH_ESCAPES&#x27;;&quot;)</div><div class=""> </div><div class="">    # override BaseAdapter methods as needed</div><div class="">    def lastrowid(self,table):</div><div class="">         self.execute(&#x27;select last_insert_id();&#x27;)</div><div class=""> db =DAL(..., driver_args={}, adapter_args={})</div><div class=""> db = DAL(&#x27;mssql://....&#x27;)</div><div class=""> for key in [&#x27;reference&#x27;,&#x27;reference FK&#x27;]:</div><div class="">     db._adapter.types[key]=db._adapter.types[key].replace(</div><div class="">         &#x27;%(on_delete_action)s&#x27;,&#x27;NO ACTION&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> **MSSQL** also has problems with arguments passed to the DISTINCT keyword and therefore</div><div class="">  while this works,</div><div class=""> </div><div class=""> ``</div><div class=""> db(query).select(distinct=True)</div><div class=""> ``</div><div class=""> </div><div class=""> this does not</div><div class=""> </div><div class=""> ``</div><div class=""> db(query).select(distinct=db.mytable.myfield)</div><div class=""> ``</div><div class=""> </div><div class=""> **Google NoSQL (Datastore)** does not allow joins, left joins, aggregates, expression, OR involving more than one table, the like operator and search in &quot;text&quot;&quot; fields. Transactions are limited and not provided automatically by web2py (you need to use the Google API ``run_in_transaction`` which you can look up in the Google App Engine documentation online). Google also limits the number of records you can retrieve in each one query (1000 at the time of writing). On the Google datastore record IDs are integer but they are not sequential. While on SQL the &quot;list:string&quot; type is mapped into a &quot;text&quot; type, on the Google Datastore it is mapped into a ``ListStringProperty``. Similarly &quot;list:integer&quot; and &quot;list:reference&quot; are mapped into &quot;ListProperty&quot;. This makes that searches for content inside these fields types are more efficient on Google NoSQL than on SQL databases.</div><div class="delete">-</div><div class="delete">-</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/49f38ab7ef56de1eb4ef48f68427ebf8a46b505d">49f38ab</a><ul><li>Date : 2012-12-26</li><li>more small edits</li></ul></li></ul>
<div class="row-fluid" id="com_49f38ab7ef56de1eb4ef48f68427ebf8a46b505d">
    <div class="span6"><div class="diff"><div class=""> -------------</div><div class=""> **SQLite**     | ``sqlite://storage.db``</div><div class=""> **MySQL**      | ``mysql://username:password@localhost/test``</div><div class=""> **PostgreSQL** | ``postgres://username:password@localhost/test``</div><div class=""> **MSSQL**      | ``mssql://username:password@localhost/test``</div><div class=""> **FireBird**   | ``firebird://username:password@localhost/test``</div><div class=""> **Oracle**     | ``oracle://username/password@test``</div><div class=""> **DB2**        | ``db2://username:password@test``</div><div class=""> **Ingres**     | ``ingres://username:password@localhost/test``</div><div class=""> **Sybase**     | ``sybase://username:password@localhost/test``</div><div class=""> **Informix**   | ``informix://username:password@test``</div><div class="insert">**Teradata**   | ``teradata://DSN=dsn;UID=user;PWD=pass;DATABASE=<span class="highlight">n</span>a<span class="highlight">m</span>e``</div><div class=""> **Cubrid**     | ``cubrid://username:password@localhost/test``</div><div class=""> **SAPDB**      | ``sapdb://username:password@localhost/test``</div><div class=""> **IMAP**       | ``imap://user:password@server:port``</div><div class=""> **MongoDB**    | ``mongodb://username:password@localhost/test``</div><div class="insert">+**Google/SQL** | ``google:sql``</div><div class="insert">+**Google/NoSQL** | ``google:datastore``</div><div class=""> -------------</div></div></div>
    <div class="span6"><div class="diff"><div class=""> -------------</div><div class=""> **SQLite**     | ``sqlite://storage.db``</div><div class=""> **MySQL**      | ``mysql://username:password@localhost/test``</div><div class=""> **PostgreSQL** | ``postgres://username:password@localhost/test``</div><div class=""> **MSSQL**      | ``mssql://username:password@localhost/test``</div><div class=""> **FireBird**   | ``firebird://username:password@localhost/test``</div><div class=""> **Oracle**     | ``oracle://username/password@test``</div><div class=""> **DB2**        | ``db2://username:password@test``</div><div class=""> **Ingres**     | ``ingres://username:password@localhost/test``</div><div class=""> **Sybase**     | ``sybase://username:password@localhost/test``</div><div class=""> **Informix**   | ``informix://username:password@test``</div><div class="delete">**Teradata**   | ``teradata://DSN=dsn;UID=user;PWD=pass;DATABASE=<span class="highlight">d</span>a<span class="highlight">tabas</span>e``</div><div class=""> **Cubrid**     | ``cubrid://username:password@localhost/test``</div><div class=""> **SAPDB**      | ``sapdb://username:password@localhost/test``</div><div class=""> **IMAP**       | ``imap://user:password@server:port``</div><div class=""> **MongoDB**    | ``mongodb://username:password@localhost/test``</div><div class="delete">-**Google App Engine/SQL** | ``google:sql``</div><div class="delete">-**Google App Engine/NoSQL** | ``google:datastore``</div><div class=""> -------------</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/eaaa0e14bf17cdc4d0edd2ea9daa9af5f3484c09">eaaa0e1</a><ul><li>Date : 2012-12-25</li><li>changes to style</li></ul></li></ul>
<div class="row-fluid" id="com_eaaa0e14bf17cdc4d0edd2ea9daa9af5f3484c09">
    <div class="span6"><div class="diff"><div class="insert">``virtual<span class="highlight"> </span>fields``:inxx</div><div class=""> </div><div class=""> Virtual fields are also computed fields (as in the previous subsection) but they differ from those because they are &#x27;&#x27;virtual&#x27;&#x27; in the sense that they are not stored in the db and they are computed each time records are extracted from the database. They can be used to simplify the user&#x27;s code without using additional storage but they cannot be used for searching.</div><div class=""> </div><div class="insert">+#### New style virtual fields</div><div class="insert">+</div><div class="insert">+web2py provides a new and easier way to define virtual fields and lazy virtual fields. This section is marked experimental because they APIs may still change a little from what is described here.</div><div class="insert">+</div><div class="insert">+Here we will consider the same example as in the previous subsection. In particular we consider the following model:</div><div class="insert">+</div><div class="insert">+``</div><div class="insert">+&gt;&gt;&gt; db.define_table(&#x27;item&#x27;,</div><div class="insert">+        Field(&#x27;unit_price&#x27;,&#x27;double&#x27;),</div><div class="insert">+        Field(&#x27;quantity&#x27;,&#x27;integer&#x27;),</div><div class="insert">+``:code</div><div class="insert">+</div><div class="insert">+One can define a ``total_price`` virtual field as</div><div class="insert">+</div><div class="insert">+``</div><div class="insert">+&gt;&gt;&gt; db.item.total_price = Field.Virtual(lambda row: row.unit_price*row.quantity)</div><div class="insert">+``:code</div><div class="insert">+</div><div class="insert">+i.e. by simply defining a new field ``total_price`` to be a ``Field.Virtual``. The only argument of the constructor is a function that takes a row and returns the computed values.</div><div class="insert">+</div><div class="insert">+A virtual field defined as the one above is automatically computed for all records when the records are selected:</div><div class="insert">+</div><div class="insert">+``</div><div class="insert">+&gt;&gt;&gt; for row in db(db.item).select(): print row.total_price</div><div class="insert">+``</div><div class="insert">+</div><div class="insert">+It is also possible to define method fields which are calculated on-demand, when called.</div><div class="insert">+For example:</div><div class="insert">+</div><div class="insert">+``</div><div class="insert">+&gt;&gt;&gt; db.item.discounted_total = Field.Method(lambda row, discount=0.0: \</div><div class="insert">+       row.unit_price*row.quantity*(1.0-discount/100))</div><div class="insert">+``:code</div><div class="insert">+</div><div class="insert">+In this case ``row.discounted_total`` is not a value but a function. The function takes the same arguments as the function passed to the ``Method`` constructor except for ``row`` which is implicit (think of it as ``self`` for rows objects).</div><div class="insert">+</div><div class="insert">+The lazy field in the example above allows one to compute the total price for each ``item``:</div><div class="insert">+</div><div class="insert">+``</div><div class="insert">+&gt;&gt;&gt; for row in db(db.item).select(): print row.discounted_total()</div><div class="insert">+``</div><div class="insert">+</div><div class="insert">+And it also allows to pass an optional ``discount`` percentage (15%):</div><div class="insert">+</div><div class="insert">+``</div><div class="insert">+&gt;&gt;&gt; for row in db(db.item).select(): print row.discounted_total(15)</div><div class="insert">+``</div><div class="insert">+</div><div class="insert">+Virtual and Method fields can also be defined in place when a table is defined:</div><div class="insert">+</div><div class="insert">+``</div><div class="insert">+&gt;&gt;&gt; db.define_table(&#x27;item&#x27;,</div><div class="insert">+        Field(&#x27;unit_price&#x27;,&#x27;double&#x27;),</div><div class="insert">+        Field(&#x27;quantity&#x27;,&#x27;integer&#x27;),</div><div class="insert">+        Field.Virtual(&#x27;total_price&#x27;, lambda row: ...),</div><div class="insert">+        Field.Method(&#x27;discounted_total&#x27;, lambda row, discount=0.0: ...))</div><div class="insert">+``:code</div><div class="insert">+</div><div class="insert">+</div><div class="insert">+------</div><div class="insert">+Mind that virtual fields do not have the same attributes as the other fields (default, readable, requires, etc) and they do not appear in the list of ``db.table.fields`` and are not visualized by default in tables (TABLE) and grids (SQLFORM.grid, SQLFORM.smartgrid).</div><div class="insert">+------</div><div class="insert">+</div><div class="insert">+#### Old style virtual fields</div><div class="insert">+</div><div class="insert">+In order to define one or more virtual fields, you can also define a container class, instantiate it and link it to a table or to a select. For example, consider the following table:</div><div class="insert">+</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;item&#x27;,</div><div class="">         Field(&#x27;unit_price&#x27;,&#x27;double&#x27;),</div><div class="">         Field(&#x27;quantity&#x27;,&#x27;integer&#x27;),</div><div class=""> ``:code</div><div class=""> </div><div class=""> One can define a ``total_price`` virtual field as</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; class MyVirtualFields(object):</div><div class="">         def total_price(self):</div><div class="">             return self.item.unit_price*self.item.quantity</div><div class=""> &gt;&gt;&gt; db.item.virtualfields.append(MyVirtualFields())</div><div class=""> ``:code</div><div class=""> </div><div class=""> Notice that each method of the class that takes a single argument (self) is a new virtual field. ``self`` refers to each one row of the select. Field values are referred by full path as in ``self.item.unit_price``. The table is linked to the virtual fields by appending an instance of the class to the table&#x27;s ``virtualfields`` attribute.</div><div class=""> </div><div class=""> Virtual fields can also access recursive fields as in</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;item&#x27;,</div><div class="">         Field(&#x27;unit_price&#x27;,&#x27;double&#x27;))</div><div class=""> Virtual fields can be &#x27;&#x27;lazy&#x27;&#x27;; all they need to do is return a function and acc</div><div class="">         Field(&#x27;quantity&#x27;,&#x27;integer&#x27;),</div><div class=""> &gt;&gt;&gt; class MyVirtualFields(object):</div><div class="">         def lazy_total_price(self):</div><div class="">             def lazy(self=self):</div><div class="">                 return self.item.unit_price \</div><div class="">                     * self.item.quantity</div><div class="">             return lazy</div><div class=""> &gt;&gt;&gt; db.item.virtualfields.append(MyVirtualFields())</div><div class=""> &gt;&gt;&gt; for item in db(db.item).select():</div><div class="">         print item.lazy_total_price()</div><div class=""> ``:code</div><div class=""> </div><div class=""> or shorter using a lambda function:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; class MyVirtualFields(object):</div><div class="">         def lazy_total_price(self):</div><div class="">             return lambda self=self: self.item.unit_price \</div><div class="">                 * self.item.quantity</div><div class=""> ``:code</div><div class=""> </div><div class=""> ### One to many relation</div><div class=""> ``one to many``:inxx</div><div class=""> </div><div class=""> To illustrate how to implement one to many relations with the web2py DAL, define another table &quot;thing&quot; that refers to the table &quot;person&quot; which we redefine here:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;,</div><div class="">                     Field(&#x27;name&#x27;),</div><div class="">                     format=&#x27;%(name)s&#x27;)</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;thing&#x27;,</div><div class="">                     Field(&#x27;name&#x27;),</div><div class="">                     Field(&#x27;owner&#x27;, &#x27;reference person&#x27;),</div><div class="">                     format=&#x27;%(name)s&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> Table &quot;thing&quot; has two fields, the name of the thing and the owner of the thing. The &quot;owner&quot; field id a reference field. A reference type can be specified in two equivalent ways:</div><div class=""> </div><div class=""> ``</div><div class=""> Field(&#x27;owner&#x27;, &#x27;reference person&#x27;)</div><div class=""> Field(&#x27;owner&#x27;, db.person)</div><div class=""> ``:code</div><div class=""> Curt Boat</div><div class=""> ``:code</div><div class=""> </div><div class=""> Similarly, you can search for all things owned by Alex:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in persons_and_things(db.person.name==&#x27;Alex&#x27;).select():</div><div class="">         print row.thing.name</div><div class=""> Boat</div><div class=""> Chair</div><div class=""> ``:code</div><div class=""> </div><div class=""> and all owners of Boat:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in persons_and_things(db.thing.name==&#x27;Boat&#x27;).select():</div><div class="">         print row.person.name</div><div class=""> Alex</div><div class=""> Curt</div><div class=""> ``:code</div><div class=""> </div><div class=""> A lighter alternative to Many 2 Many relations is tagging. Tagging is discussed in the context of the ``IS_IN_DB`` validator. Tagging works even on database backends that do not support JOINs like the Google App Engine NoSQL.</div><div class=""> </div><div class="insert">###<span class="highlight"></span> ``list:&lt;type&gt;``, and ``contains``</div><div class=""> ``list:string``:inxx</div><div class=""> ``list:integer``:inxx</div><div class=""> ``list:reference``:inxx</div><div class=""> ``contains``:inxx</div><div class=""> ``multiple``:inxx</div><div class=""> ``tags``:inxx</div><div class=""> </div><div class=""> web2py provides the following special field types:</div><div class=""> </div><div class=""> ``</div><div class=""> list:string</div><div class=""> list:integer</div><div class=""> list:reference &lt;table&gt;</div><div class=""> ``:code</div><div class=""> </div><div class=""> They can contain lists of strings, of integers and of references respectively.</div><div class=""> </div><div class=""> On Google App Engine NoSQL ``list:string`` is mapped into ``StringListProperty``, the other two are mapped into ``ListProperty(int)``. On relational databases they all mapped into text fields which contain the list of items separated by ``|``. For example ``[1,2,3]`` is mapped into ``|1|2|3|``.</div><div class=""> </div><div class=""> For lists of string the items are escaped so that any ``|`` in the item is replaced by a ``||``. Anyway this is an internal representation and it is transparent to the user.</div><div class=""> The DAL can be used from any Python program simply by doing this:</div><div class=""> </div><div class=""> ``</div><div class=""> from gluon import DAL, Field</div><div class=""> db = DAL(&#x27;sqlite://storage.sqlite&#x27;,folder=&#x27;path/to/app/databases&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> i.e. import the DAL, Field, connect and specify the folder which contains the .table files (the app/databases folder).</div><div class=""> </div><div class=""> To access the data and its attributes we still have to define all the tables we are going to access with ``db.define_tables(...)``.</div><div class=""> </div><div class=""> If we just need access to the data but not to the web2py table attributes, we get away without re-defining the tables but simply asking web2py to read the necessary info from the metadata in the .table files:</div><div class=""> </div><div class=""> ``</div><div class=""> from gluon import DAL, Field</div><div class=""> db = DAL(&#x27;sqlite://storage.sqlite&#x27;,folder=&#x27;path/to/app/databases&#x27;,</div><div class="">          auto_import=True))</div><div class=""> ``:code</div><div class=""> </div><div class=""> This allows us to access any ``db.table`` without need to re-define it.</div><div class=""> </div><div class="insert">#### PostGIS, SpatiaLite, and MS Geo <span class="highlight"></span>(experimental)</div></div></div>
    <div class="span6"><div class="diff"><div class="delete">-#### Old style virtual fields</div><div class="delete">``virtual<span class="highlight"></span>fields``:inxx</div><div class=""> </div><div class=""> Virtual fields are also computed fields (as in the previous subsection) but they differ from those because they are &#x27;&#x27;virtual&#x27;&#x27; in the sense that they are not stored in the db and they are computed each time records are extracted from the database. They can be used to simplify the user&#x27;s code without using additional storage but they cannot be used for searching.</div><div class=""> </div><div class="delete">-In order to define one or more virtual fields, you have to define a container class, instantiate it and link it to a table or to a select. For example, consider the following table:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;item&#x27;,</div><div class="">         Field(&#x27;unit_price&#x27;,&#x27;double&#x27;),</div><div class="">         Field(&#x27;quantity&#x27;,&#x27;integer&#x27;),</div><div class=""> ``:code</div><div class=""> </div><div class=""> One can define a ``total_price`` virtual field as</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; class MyVirtualFields(object):</div><div class="">         def total_price(self):</div><div class="">             return self.item.unit_price*self.item.quantity</div><div class=""> &gt;&gt;&gt; db.item.virtualfields.append(MyVirtualFields())</div><div class=""> ``:code</div><div class=""> </div><div class=""> Notice that each method of the class that takes a single argument (self) is a new virtual field. ``self`` refers to each one row of the select. Field values are referred by full path as in ``self.item.unit_price``. The table is linked to the virtual fields by appending an instance of the class to the table&#x27;s ``virtualfields`` attribute.</div><div class=""> </div><div class=""> Virtual fields can also access recursive fields as in</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;item&#x27;,</div><div class="">         Field(&#x27;unit_price&#x27;,&#x27;double&#x27;))</div><div class=""> Virtual fields can be &#x27;&#x27;lazy&#x27;&#x27;; all they need to do is return a function and acc</div><div class="">         Field(&#x27;quantity&#x27;,&#x27;integer&#x27;),</div><div class=""> &gt;&gt;&gt; class MyVirtualFields(object):</div><div class="">         def lazy_total_price(self):</div><div class="">             def lazy(self=self):</div><div class="">                 return self.item.unit_price \</div><div class="">                     * self.item.quantity</div><div class="">             return lazy</div><div class=""> &gt;&gt;&gt; db.item.virtualfields.append(MyVirtualFields())</div><div class=""> &gt;&gt;&gt; for item in db(db.item).select():</div><div class="">         print item.lazy_total_price()</div><div class=""> ``:code</div><div class=""> </div><div class=""> or shorter using a lambda function:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; class MyVirtualFields(object):</div><div class="">         def lazy_total_price(self):</div><div class="">             return lambda self=self: self.item.unit_price \</div><div class="">                 * self.item.quantity</div><div class=""> ``:code</div><div class=""> </div><div class="delete">-</div><div class="delete">-#### New style virtual fields (experimental)</div><div class="delete">-</div><div class="delete">-web2py provides a new and easier way to define virtual fields and lazy virtual fields. This section is marked experimental because they APIs may still change a little from what is described here.</div><div class="delete">-</div><div class="delete">-Here we will consider the same example as in the previous subsection. In particular we consider the following model:</div><div class="delete">-</div><div class="delete">-``</div><div class="delete">-&gt;&gt;&gt; db.define_table(&#x27;item&#x27;,</div><div class="delete">-        Field(&#x27;unit_price&#x27;,&#x27;double&#x27;),</div><div class="delete">-        Field(&#x27;quantity&#x27;,&#x27;integer&#x27;),</div><div class="delete">-``:code</div><div class="delete">-</div><div class="delete">-One can define a ``total_price`` virtual field as</div><div class="delete">-</div><div class="delete">-``</div><div class="delete">-&gt;&gt;&gt; db.item.total_price = Field.Virtual(lambda row: row.unit_price*row.quantity)</div><div class="delete">-``:code</div><div class="delete">-</div><div class="delete">-i.e. by simply defining a new field ``total_price`` to be a ``Field.Virtual``. The only argument of the constructor is a function that takes a row and returns the computed values.</div><div class="delete">-</div><div class="delete">-A virtual field defined as the one above is automatically computed for all records when the records are selected:</div><div class="delete">-</div><div class="delete">-``</div><div class="delete">-&gt;&gt;&gt; for row in db(db.item).select(): print row.total_price</div><div class="delete">-``</div><div class="delete">-</div><div class="delete">-It is also possible to define method fields which are calculated on-demand, when called.</div><div class="delete">-For example:</div><div class="delete">-</div><div class="delete">-``</div><div class="delete">-&gt;&gt;&gt; db.item.discounted_total = Field.Method(lambda row, discount=0.0: \</div><div class="delete">-       row.unit_price*row.quantity*(1.0-discount/100))</div><div class="delete">-``:code</div><div class="delete">-</div><div class="delete">-In this case ``row.discounted_total`` is not a value but a function. The function takes the same arguments as the function passed to the ``Method`` constructor except for ``row`` which is implicit (think of it as ``self`` for rows objects).</div><div class="delete">-</div><div class="delete">-The lazy field in the example above allows one to compute the total price for each ``item``:</div><div class="delete">-</div><div class="delete">-``</div><div class="delete">-&gt;&gt;&gt; for row in db(db.item).select(): print row.discounted_total()</div><div class="delete">-``</div><div class="delete">-</div><div class="delete">-And it also allows to pass an optional ``discount`` percentage (15%):</div><div class="delete">-</div><div class="delete">-``</div><div class="delete">-&gt;&gt;&gt; for row in db(db.item).select(): print row.discounted_total(15)</div><div class="delete">-``</div><div class="delete">-</div><div class="delete">-Virtual and Method fields can also be defined in place when a table is defined:</div><div class="delete">-</div><div class="delete">-``</div><div class="delete">-&gt;&gt;&gt; db.define_table(&#x27;item&#x27;,</div><div class="delete">-        Field(&#x27;unit_price&#x27;,&#x27;double&#x27;),</div><div class="delete">-        Field(&#x27;quantity&#x27;,&#x27;integer&#x27;),</div><div class="delete">-        Field.Virtual(&#x27;total_price&#x27;, lambda row: ...),</div><div class="delete">-        Field.Method(&#x27;discounted_total&#x27;, lambda row, discount=0.0: ...))</div><div class="delete">-``:code</div><div class="delete">-</div><div class="delete">-</div><div class="delete">-Mind that virtual fields do not have the same attributes as the other fields (default, readable, requires, etc) and they do not appear in the list of ``db.table.fields`` and are not visualized by default in tables (TABLE) and grids (SQLFORM.grid, SQLFORM.smartgrid).</div><div class="delete">-</div><div class=""> ### One to many relation</div><div class=""> ``one to many``:inxx</div><div class=""> </div><div class=""> To illustrate how to implement one to many relations with the web2py DAL, define another table &quot;thing&quot; that refers to the table &quot;person&quot; which we redefine here:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;,</div><div class="">                     Field(&#x27;name&#x27;),</div><div class="">                     format=&#x27;%(name)s&#x27;)</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;thing&#x27;,</div><div class="">                     Field(&#x27;name&#x27;),</div><div class="">                     Field(&#x27;owner&#x27;, &#x27;reference person&#x27;),</div><div class="">                     format=&#x27;%(name)s&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> Table &quot;thing&quot; has two fields, the name of the thing and the owner of the thing. The &quot;owner&quot; field id a reference field. A reference type can be specified in two equivalent ways:</div><div class=""> </div><div class=""> ``</div><div class=""> Field(&#x27;owner&#x27;, &#x27;reference person&#x27;)</div><div class=""> Field(&#x27;owner&#x27;, db.person)</div><div class=""> ``:code</div><div class=""> Curt Boat</div><div class=""> ``:code</div><div class=""> </div><div class=""> Similarly, you can search for all things owned by Alex:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in persons_and_things(db.person.name==&#x27;Alex&#x27;).select():</div><div class="">         print row.thing.name</div><div class=""> Boat</div><div class=""> Chair</div><div class=""> ``:code</div><div class=""> </div><div class=""> and all owners of Boat:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in persons_and_things(db.thing.name==&#x27;Boat&#x27;).select():</div><div class="">         print row.person.name</div><div class=""> Alex</div><div class=""> Curt</div><div class=""> ``:code</div><div class=""> </div><div class=""> A lighter alternative to Many 2 Many relations is tagging. Tagging is discussed in the context of the ``IS_IN_DB`` validator. Tagging works even on database backends that do not support JOINs like the Google App Engine NoSQL.</div><div class=""> </div><div class="delete">###<span class="highlight"> Many to many,</span> ``list:&lt;type&gt;``, and ``contains``</div><div class=""> ``list:string``:inxx</div><div class=""> ``list:integer``:inxx</div><div class=""> ``list:reference``:inxx</div><div class=""> ``contains``:inxx</div><div class=""> ``multiple``:inxx</div><div class=""> ``tags``:inxx</div><div class=""> </div><div class=""> web2py provides the following special field types:</div><div class=""> </div><div class=""> ``</div><div class=""> list:string</div><div class=""> list:integer</div><div class=""> list:reference &lt;table&gt;</div><div class=""> ``:code</div><div class=""> </div><div class=""> They can contain lists of strings, of integers and of references respectively.</div><div class=""> </div><div class=""> On Google App Engine NoSQL ``list:string`` is mapped into ``StringListProperty``, the other two are mapped into ``ListProperty(int)``. On relational databases they all mapped into text fields which contain the list of items separated by ``|``. For example ``[1,2,3]`` is mapped into ``|1|2|3|``.</div><div class=""> </div><div class=""> For lists of string the items are escaped so that any ``|`` in the item is replaced by a ``||``. Anyway this is an internal representation and it is transparent to the user.</div><div class=""> The DAL can be used from any Python program simply by doing this:</div><div class=""> </div><div class=""> ``</div><div class=""> from gluon import DAL, Field</div><div class=""> db = DAL(&#x27;sqlite://storage.sqlite&#x27;,folder=&#x27;path/to/app/databases&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> i.e. import the DAL, Field, connect and specify the folder which contains the .table files (the app/databases folder).</div><div class=""> </div><div class=""> To access the data and its attributes we still have to define all the tables we are going to access with ``db.define_tables(...)``.</div><div class=""> </div><div class=""> If we just need access to the data but not to the web2py table attributes, we get away without re-defining the tables but simply asking web2py to read the necessary info from the metadata in the .table files:</div><div class=""> </div><div class=""> ``</div><div class=""> from gluon import DAL, Field</div><div class=""> db = DAL(&#x27;sqlite://storage.sqlite&#x27;,folder=&#x27;path/to/app/databases&#x27;,</div><div class="">          auto_import=True))</div><div class=""> ``:code</div><div class=""> </div><div class=""> This allows us to access any ``db.table`` without need to re-define it.</div><div class=""> </div><div class="delete">#### PostGIS, SpatiaLite, and MS Geo <span class="highlight">Extensions </span>(experimental)</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/28816a98948c4a6577f73bdeb2b7424dc55d2582">28816a9</a><ul><li>Date : 2012-12-23</li><li>code building book</li></ul></li></ul>
<div class="row-fluid" id="com_28816a98948c4a6577f73bdeb2b7424dc55d2582">
    <div class="span6"><div class="diff"><div class=""> ----------</div><div class=""> database | drivers (source)</div><div class=""> SQLite | sqlite3 or pysqlite2 or zxJDBC ``zxjdbc``:cite  (on Jython)</div><div class=""> PostgreSQL | psycopg2 ``psycopg2``:cite  or pg8000 ``pg8000``:cite or zxJDBC ``zxjdbc``:cite  (on Jython)</div><div class=""> MySQL | pymysql ``pymysql``:cite or MySQLdb ``mysqldb``:cite</div><div class=""> Oracle | cx_Oracle ``cxoracle``:cite</div><div class=""> MSSQL | pyodbc ``pyodbc``:cite</div><div class=""> FireBird | kinterbasdb ``kinterbasdb``:cite or fdb or pyodbc</div><div class=""> DB2 | pyodbc ``pyodbc``:cite</div><div class=""> Informix | informixdb ``informixdb``:cite</div><div class=""> Ingres | ingresdbi ``ingresdbi``:cite</div><div class="insert">Cubrid | cubriddb ``cubrid<span class="highlight"></span>b``:cite ``cubrid<span class="highlight">b</span>``:cite</div><div class=""> Sybase | Sybase ``Sybase``:cite</div><div class=""> Teradata | pyodbc ``Teradata``:cite </div><div class=""> SAPDB    | sapdb ``SAPDB``:cite</div><div class=""> MongoDB | pymongo ``pymongo``:cite</div><div class=""> IMAP | imaplib ``IMAP``:cite </div><div class=""> ---------</div></div></div>
    <div class="span6"><div class="diff"><div class=""> ----------</div><div class=""> database | drivers (source)</div><div class=""> SQLite | sqlite3 or pysqlite2 or zxJDBC ``zxjdbc``:cite  (on Jython)</div><div class=""> PostgreSQL | psycopg2 ``psycopg2``:cite  or pg8000 ``pg8000``:cite or zxJDBC ``zxjdbc``:cite  (on Jython)</div><div class=""> MySQL | pymysql ``pymysql``:cite or MySQLdb ``mysqldb``:cite</div><div class=""> Oracle | cx_Oracle ``cxoracle``:cite</div><div class=""> MSSQL | pyodbc ``pyodbc``:cite</div><div class=""> FireBird | kinterbasdb ``kinterbasdb``:cite or fdb or pyodbc</div><div class=""> DB2 | pyodbc ``pyodbc``:cite</div><div class=""> Informix | informixdb ``informixdb``:cite</div><div class=""> Ingres | ingresdbi ``ingresdbi``:cite</div><div class="delete">Cubrid | cubriddb ``cubrid<span class="highlight">d</span>b``:cite ``cubrid<span class="highlight"></span>``:cite</div><div class=""> Sybase | Sybase ``Sybase``:cite</div><div class=""> Teradata | pyodbc ``Teradata``:cite </div><div class=""> SAPDB    | sapdb ``SAPDB``:cite</div><div class=""> MongoDB | pymongo ``pymongo``:cite</div><div class=""> IMAP | imaplib ``IMAP``:cite </div><div class=""> ---------</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/7bce1473ce90f4e60f49d72bf1b61d32f430cb54">7bce147</a><ul><li>Date : 2012-12-22</li><li>scheduler.queue_task</li></ul></li></ul>
<div class="row-fluid" id="com_7bce1473ce90f4e60f49d72bf1b61d32f430cb54">
    <div class="span6"><div class="diff"><div class="insert">#### <span class="highlight">P</span>ost<span class="highlight">GIS, Spat</span>i<span class="highlight">aLite,</span> and <span class="highlight">MS Geo Ex</span>te<span class="highlight">nsions</span> (experimental)</div><div class=""> </div><div class="insert">+``PostGIS``:inxx ``StatiaLite``:inxx ``Geo Extensions``:inxx</div><div class="insert">+``geometry``:inxx ``geoPoint``:inxx ``geoLine``:inxx ``geoPolygon``:inxx</div><div class="insert">+</div><div class="insert">+The DAL supports geographical APIs using PostGIS (for PostgreSQL), spatialite (for SQLite), and MSSQL and Spatial Extensions. This is a feature that was sponosred by the Sahana project and implemented by Denes Lengyel.</div><div class=""> </div><div class=""> DAL provides geometry and geography fields types and the following functions:</div><div class=""> </div><div class="insert">+``st_asgeojson``:inxx ``st_astext``:inxx ``st_contained``:inxx ``st_contains``:inxx</div><div class="insert">+``st_distance``:inxx ``st_equals``:inxx ``st_intersects``:inxx ``st_overlaps``:inxx</div><div class="insert">+``st_simplify``:inxx ``st_touches``:inxx ``st_within``:inxx</div><div class="insert">+</div><div class=""> ``</div><div class=""> st_asgeojson (PostGIS only)</div><div class=""> st_astext</div><div class=""> st_contained</div><div class=""> st_contains</div><div class=""> st_distance</div><div class=""> st_equals</div><div class=""> st_intersects</div><div class=""> st_overlaps</div><div class=""> st_simplify (PostGIS only)</div><div class=""> st_touches</div><div class=""> st_within</div><div class=""> ``</div><div class=""> </div><div class=""> Here are some examples:</div><div class=""> </div><div class=""> ``</div><div class=""> from gluon.dal import DAL, Field, geoPoint, geoLine, geoPolygon</div><div class=""> db = DAL(&quot;mssql://user:pass@host:db&quot;)</div><div class=""> sp = db.define_table(&#x27;spatial&#x27;,</div><div class="">   Field(&#x27;loc&#x27;,&#x27;geometry()&#x27;)</div><div class=""> )</div><div class=""> ``:code</div><div class=""> </div><div class=""> Below we insert a point, a line, and a polygon:</div><div class=""> ``</div><div class=""> sp.insert(loc=geoPoint(1,1))</div><div class=""> sp.insert(loc=geoLine((100,100),(20,180),(180,180)))</div><div class=""> sp.insert(loc=geoPolygon((0,0),(150,0),(150,150),(0,150),(0,0)))</div><div class=""> ``:code</div><div class=""> </div><div class=""> Notice that</div><div class=""> ``</div><div class="insert"><span class="highlight"></span>r<span class="highlight">ows =</span> db(sp.id&gt;0).select()</div><div class=""> ``:code</div><div class=""> </div><div class="insert">+Always returns the geometry data serialized as text.</div><div class="insert">+You can also do the same more explicitely using ``st_astext()``:</div><div class=""> </div><div class=""> ``</div><div class=""> print db(sp.id&gt;0).select(sp.id, sp.loc.st_astext())</div><div class=""> spatial.id,spatial.loc.STAsText()</div><div class=""> 1, POINT (1 2)&quot;</div><div class=""> 2, LINESTRING (100 100, 20 180, 180 180)</div><div class=""> 3, POLYGON ((0 0, 150 0, 150 150, 0 150, 0 0))</div><div class=""> ``:code</div><div class=""> </div><div class="insert"><span class="highlight">You can ask f</span>or<span class="highlight"></span> the<span class="highlight"></span> <span class="highlight">native representation by using ``st_</span>as<span class="highlight">geo</span>json<span class="highlight">()`` (in PostGIS only)</span>:</div><div class=""> </div><div class=""> ``</div><div class=""> print db(sp.id&gt;0).select(sp.id, sp.loc.st_asgeojson().with_alias(&#x27;loc&#x27;))</div><div class=""> spatial.id,loc</div><div class=""> 1, [1, 2]</div><div class=""> 2, [[100, 100], [20 180], [180, 180]]</div><div class=""> 3, [[[0, 0], [150, 0], [150, 150], [0, 150], [0, 0]]]</div><div class=""> ``:code</div><div class=""> </div><div class="insert">+(notice an array is a point, an array of arrays is a line, and an array of array of arrays is a polygon).</div><div class="insert">+</div><div class=""> Here are example of how to use geographical functions:</div><div class=""> </div><div class=""> ``</div><div class=""> query = sp.loc.st_intersects(geoLine((20,120),(60,160)))</div><div class=""> query = sp.loc.st_overlaps(geoPolygon((1,1),(11,1),(11,11),(11,1),(1,1)))</div><div class=""> query = sp.loc.st_contains(geoPoint(1,1))</div><div class="insert">+print db(query).select(sp.id,sp.loc)</div><div class="insert">+spatial.id,spatial.loc</div><div class="insert">+3,&quot;POLYGNON ((0 0, 150 0, 150 150, 0 150, 0 0))&quot;</div><div class=""> ``:code</div><div class=""> </div><div class=""> Computed distances can also be retrieved as floating point numbers:</div><div class=""> </div><div class=""> ``</div><div class=""> dist = sp.loc.st_distance(geoPoint(-1,2)).with_alias(&#x27;dist&#x27;)</div><div class=""> print db(sp.id&gt;0).select(sp.id, dist)</div><div class=""> spatial.id, dist</div><div class=""> 1 2.0</div><div class=""> 2 140.714249456</div><div class=""> 3 1.0</div><div class=""> ``:code</div><div class=""> </div><div class=""> #### Copy data from one db into another</div></div></div>
    <div class="span6"><div class="diff"><div class="delete">#### <span class="highlight">p</span>ost<span class="highlight">g</span>i<span class="highlight">s</span> and <span class="highlight">spatiali</span>te<span class="highlight"></span> (experimental)</div><div class=""> </div><div class="delete">-The DAL supports geographical APIs using postgis (for postgresql) and spatialite (for MSSQL and SQLite). This is a feature that was sponosred by the Sahana project and implemented by Denes Lengyel.</div><div class=""> </div><div class=""> DAL provides geometry and geography fields types and the following functions:</div><div class=""> </div><div class=""> ``</div><div class=""> st_asgeojson (PostGIS only)</div><div class=""> st_astext</div><div class=""> st_contained</div><div class=""> st_contains</div><div class=""> st_distance</div><div class=""> st_equals</div><div class=""> st_intersects</div><div class=""> st_overlaps</div><div class=""> st_simplify (PostGIS only)</div><div class=""> st_touches</div><div class=""> st_within</div><div class=""> ``</div><div class=""> </div><div class=""> Here are some examples:</div><div class=""> </div><div class=""> ``</div><div class=""> from gluon.dal import DAL, Field, geoPoint, geoLine, geoPolygon</div><div class=""> db = DAL(&quot;mssql://user:pass@host:db&quot;)</div><div class=""> sp = db.define_table(&#x27;spatial&#x27;,</div><div class="">   Field(&#x27;loc&#x27;,&#x27;geometry()&#x27;)</div><div class=""> )</div><div class=""> ``:code</div><div class=""> </div><div class=""> Below we insert a point, a line, and a polygon:</div><div class=""> ``</div><div class=""> sp.insert(loc=geoPoint(1,1))</div><div class=""> sp.insert(loc=geoLine((100,100),(20,180),(180,180)))</div><div class=""> sp.insert(loc=geoPolygon((0,0),(150,0),(150,150),(0,150),(0,0)))</div><div class=""> ``:code</div><div class=""> </div><div class=""> Notice that</div><div class=""> ``</div><div class="delete"><span class="highlight">p</span>r<span class="highlight">int</span> db(sp.id&gt;0).select()</div><div class=""> ``:code</div><div class=""> </div><div class="delete">-will not display the values of these fields. You can print them with:</div><div class=""> </div><div class=""> ``</div><div class=""> print db(sp.id&gt;0).select(sp.id, sp.loc.st_astext())</div><div class=""> spatial.id,spatial.loc.STAsText()</div><div class=""> 1, POINT (1 2)&quot;</div><div class=""> 2, LINESTRING (100 100, 20 180, 180 180)</div><div class=""> 3, POLYGON ((0 0, 150 0, 150 150, 0 150, 0 0))</div><div class=""> ``:code</div><div class=""> </div><div class="delete"><span class="highlight"></span>or<span class="highlight"> serialize</span> the<span class="highlight">m</span> <span class="highlight"></span>as<span class="highlight"> </span>json<span class="highlight"></span>:</div><div class=""> </div><div class=""> ``</div><div class=""> print db(sp.id&gt;0).select(sp.id, sp.loc.st_asgeojson().with_alias(&#x27;loc&#x27;))</div><div class=""> spatial.id,loc</div><div class=""> 1, [1, 2]</div><div class=""> 2, [[100, 100], [20 180], [180, 180]]</div><div class=""> 3, [[[0, 0], [150, 0], [150, 150], [0, 150], [0, 0]]]</div><div class=""> ``:code</div><div class=""> </div><div class=""> Here are example of how to use geographical functions:</div><div class=""> </div><div class=""> ``</div><div class=""> query = sp.loc.st_intersects(geoLine((20,120),(60,160)))</div><div class=""> query = sp.loc.st_overlaps(geoPolygon((1,1),(11,1),(11,11),(11,1),(1,1)))</div><div class=""> query = sp.loc.st_contains(geoPoint(1,1))</div><div class="delete">-print db(query).select(sp.id,sp.loc.st_astext())</div><div class="delete">-spatial.id,spatial.loc.STAsText()</div><div class="delete">-3,&quot;POLYGON ((0 0, 150 0, 150 150, 0 150, 0 0))&quot;</div><div class=""> ``:code</div><div class=""> </div><div class=""> Computed distances can also be retrieved as floating point numbers:</div><div class=""> </div><div class=""> ``</div><div class=""> dist = sp.loc.st_distance(geoPoint(-1,2)).with_alias(&#x27;dist&#x27;)</div><div class=""> print db(sp.id&gt;0).select(sp.id, dist)</div><div class=""> spatial.id, dist</div><div class=""> 1 2.0</div><div class=""> 2 140.714249456</div><div class=""> 3 1.0</div><div class=""> ``:code</div><div class=""> </div><div class="delete">-New versions of web2py may include automatic conversions from promitive geographical types to Python geographical objects encoded, for example, as tuples.</div><div class="delete">-</div><div class=""> #### Copy data from one db into another</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/e234f6edf67361b3ba718ea10184ba8e7c2f773d">e234f6e</a><ul><li>Date : 2012-12-20</li><li>lots of improvements</li></ul></li></ul>
<div class="row-fluid" id="com_e234f6edf67361b3ba718ea10184ba8e7c2f773d">
    <div class="span6"><div class="diff"><div class="insert">web2py comes with a Database Abstraction Layer (DAL), an API that maps Python objects into database objects such as queries, tables, and records. The DAL dynamically generates the SQL in real time using the specified dialect for the database back end, so that you do not have to write SQL code or learn different SQL dialects (the term SQL is used generically), and the application will be portable among different types of databases. At the time of this writing, the supported databases are SQLite (which comes with Python and thus web2py), PostgreSQL, MySQL, Oracle, MSSQL, FireBird, DB2, Informix, Ingres, <span class="highlight">and </span>the Google App Engine (SQL and NoSQL)<span class="highlight"></span>. Experimentally we support more databases. Please check on the web2py web site and mailing list for more recent adapters. Google NoSQL is treated as a particular case in Chapter 13.</div><div class=""> </div><div class=""> The Windows binary distribution works out of the box with SQLite and MySQL. The Mac binary distribution works out of the box with SQLite.</div><div class=""> To use any other database back-end, run from the source distribution and install the appropriate driver for the required back end.</div><div class=""> ``database drivers``:inxx</div><div class=""> </div><div class=""> Once the proper driver is installed, start web2py from source, and it will find the driver. Here is a list of drivers:</div><div class=""> </div><div class=""> ``DAL``:inxx ``SQLite``:inxx ``MySQL``:inxx ``PostgresSQL``:inxx ``Oracle``:inxx ``MSSQL``:inxx ``FireBird``:inxx ``DB2``:inxx ``Informix``:inxx ``Sybase``:inxx ``Teradata``:inxx ``MongoDB``:inxx ``CouchDB``:inxx ``SAPDB``:inxx ``Cubrid``:inxx</div><div class=""> </div><div class=""> ----------</div><div class=""> database | drivers (source)</div><div class=""> SQLite | sqlite3 or pysqlite2 or zxJDBC ``zxjdbc``:cite  (on Jython)</div><div class=""> PostgreSQL | psycopg2 ``psycopg2``:cite  or pg8000 ``pg8000``:cite or zxJDBC ``zxjdbc``:cite  (on Jython)</div><div class=""> MySQL | pymysql ``pymysql``:cite or MySQLdb ``mysqldb``:cite</div><div class=""> Oracle | cx_Oracle ``cxoracle``:cite</div><div class=""> MSSQL | pyodbc ``pyodbc``:cite</div><div class=""> FireBird | kinterbasdb ``kinterbasdb``:cite or fdb or pyodbc</div><div class=""> DB2 | pyodbc ``pyodbc``:cite</div><div class=""> Informix | informixdb ``informixdb``:cite</div><div class=""> Ingres | ingresdbi ``ingresdbi``:cite</div><div class=""> A connection with the database is established by creating an instance of the DAL</div><div class=""> **MSSQL**      | ``mssql://username:password@localhost/test``</div><div class=""> **FireBird**   | ``firebird://username:password@localhost/test``</div><div class=""> **Oracle**     | ``oracle://username/password@test``</div><div class=""> **DB2**        | ``db2://username:password@test``</div><div class=""> **Ingres**     | ``ingres://username:password@localhost/test``</div><div class=""> **Sybase**     | ``sybase://username:password@localhost/test``</div><div class=""> **Informix**   | ``informix://username:password@test``</div><div class=""> **Teradata**   | ``teradata://DSN=dsn;UID=user;PWD=pass;DATABASE=database``</div><div class=""> **Cubrid**     | ``cubrid://username:password@localhost/test``</div><div class=""> **SAPDB**      | ``sapdb://username:password@localhost/test``</div><div class=""> **IMAP**       | ``imap://user:password@server:port``</div><div class=""> **MongoDB**    | ``mongodb://username:password@localhost/test``</div><div class=""> **Google App Engine/SQL** | ``google:sql``</div><div class=""> **Google App Engine/NoSQL** | ``google:datastore``</div><div class=""> -------------</div><div class=""> </div><div class=""> Notice that in SQLite the database consists of a single file. If it does not exist, it is created. This file is locked every time it is accessed. In the case of MySQL, PostgreSQL, MSSQL, FireBird, Oracle, DB2, Ingres and Informix the database &quot;test&quot; must be created outside web2py. Once the connection is established, web2py will create, alter, and drop tables appropriately.</div><div class=""> </div><div class=""> It is also possible to set the connection string to ``None``. In this case DAL will not connect to any back-end database, but the API can still be accessed for testing. Examples of this will be discussed in Chapter 7.</div><div class=""> </div><div class="insert">+Some times you may need to generate SQL as if you had a connection but without actually connecting to the database. This can be done with</div><div class="insert">+</div><div class="insert">+``</div><div class="insert">+db = DAL(..., do_connect=False)</div><div class="insert">+``:code</div><div class="insert">+</div><div class="insert">+In this case you will be able to call ``_select``, ``_insert``, ``_update``, and ``_delete`` to generate SQL but call ``select``, ``insert``, ``update``, and ``delete``. In most of the cases you can use ``do_connect=False`` even without having the required database drivers.</div><div class="insert">+</div><div class=""> #### Connection pooling</div><div class=""> ``connection pooling``:inxx</div><div class=""> </div><div class=""> The second argument of the DAL constructor is the ``pool_size``; it defaults to 0.</div><div class=""> </div><div class=""> As it is rather slow to establish a new database connection for each request, web2py implements a mechanism for connection pooling. Once a connection is established and the page has been served and the transaction completed, the connection is not closed but goes into a pool. When the next http request arrives, web2py tries to obtain a connection from the pool and use that for the new transaction. If there are no available connections in the pool, a new connection is established.</div><div class=""> </div><div class=""> The ``pool_size`` parameter is ignored by SQLite and Google App Engine.</div><div class=""> </div><div class=""> Connections in the pools are shared sequentially among threads, in the sense that they may be used by two different but not simultaneous threads. There is only one pool for each web2py process.</div><div class=""> </div><div class=""> When web2py starts, the pool is always empty. The pool grows up to the minimum between the value of ``pool_size`` and the max number of concurrent requests. This means that if ``pool_size=10`` but our server never receives more than 5 concurrent requests, then the actual pool size will only grow to 5. If ``pool_size=0`` then connection pooling is not used.</div><div class=""> </div><div class=""> Connection pooling is ignored for SQLite, since it would not yield any benefit.</div><div class=""> </div><div class=""> #### Connection failures</div><div class=""> </div><div class=""> If web2py fails to connect to the database it waits 1 seconds and tries again up to 5 times before declaring a failure. In case of connection pooling it is possible that a pooled connection that stays open but unused for some time is closed by the database end. Thanks to the retry feature web2py tries to re-establish these dropped connections.</div><div class=""> </div><div class=""> When using connection pooling a connection is used, put back in the pool and then recycled. It is possible that while the connection is idle in pool the connection is closed by the database server. This can be because of a malfunction or a timeout. When this happens web2py detects it and re-establish the connection.</div><div class=""> sqlite</div><div class=""> The connection string is called a ``_uri`` because it is an instance of a Uniform Resource Identifier.</div><div class=""> </div><div class=""> The DAL allows multiple connections with the same database or with different databases, even databases of different types. For now, we will assume the presence of a single database since this is the most common situation.</div><div class=""> </div><div class=""> ``define_table``:inxx ``Field``:inxx</div><div class=""> ``type``:inxx ``length``:inxx ``default``:inxx ``requires``:inxx ``required``:inxx ``unique``:inxx</div><div class=""> ``notnull``:inxx ``ondelete``:inxx ``uploadfield``:inxx ``uploadseparate``:inxx ``migrate``:inxx ``sql.log``:inxx</div><div class=""> </div><div class=""> The most important method of a DAL is ``define_table``:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class=""> It defines, stores and returns a ``Table`` object called &quot;person&quot; containing a field (column) &quot;name&quot;. This object can also be accessed via ``db.person``, so you do not need to catch the return value.</div><div class=""> </div><div class=""> Do not declare a field called &quot;id&quot;, because one is created by web2py anyway. Every table has a field called &quot;id&quot; by default. It is an auto-increment integer field (starting at 1) used for cross-reference and for making every record unique, so &quot;id&quot; is a primary key. (Note: the id&#x27;s starting at 1 is back-end specific. For example, this does not apply to the Google App Engine NoSQL.)</div><div class=""> </div><div class=""> ``named id field``:inxx</div><div class=""> Optionally you can define a field of ``type=&#x27;id&#x27;`` and web2py will use this field as auto-increment id field. This is not recommended except when accessing legacy database tables. With some limitation, you can also use different primary keys and this is discussed in the section on &quot;Legacy databases and keyed tables&quot;.</div><div class=""> </div><div class="insert">+Tables can be defined only once but you can force web2py to redefine an existing table:</div><div class="insert">+</div><div class="insert">+``</div><div class="insert">+db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;))</div><div class="insert">+db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;), redefine=True)</div><div class="insert">+``:code</div><div class="insert">+</div><div class="insert">+The redefinition may trigger a migration if field content is different.</div><div class="insert">+</div><div class=""> ----------</div><div class=""> Because usually in web2py models are executed before controllers, it is possible that some table are defined even if not needed. It is therefore necessary to speed up the code by making table definitions lazy. This is done by setting the ``DAL(...,lazy_tables=True)`` attributes. Tables will be actually created only when accessed.</div><div class=""> ----------</div><div class=""> </div><div class=""> ### Record representation</div><div class=""> </div><div class=""> It is optional but recommended to specify a format representation for records:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;), format=&#x27;%(name)s&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> or</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;), format=&#x27;%(name)s %(id)s&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> or even more complex ones using a function:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;),</div><div class="">        format=lambda r: r.name or &#x27;anonymous&#x27;)</div><div class=""> And you can update all records in a set by passing named arguments corresponding</div><div class=""> #### Expressions</div><div class=""> </div><div class=""> The value assigned an update statement can be an expression. For example consider this model</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;,</div><div class="">         Field(&#x27;name&#x27;),</div><div class="">         Field(&#x27;visits&#x27;, &#x27;integer&#x27;, default=0))</div><div class=""> &gt;&gt;&gt; db(db.person.name == &#x27;Massimo&#x27;).update(</div><div class="">         visits = db.person.visits + 1)</div><div class=""> ``:code</div><div class=""> </div><div class=""> The values used in queries can also be expressions</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;,</div><div class="">         Field(&#x27;name&#x27;),</div><div class="">         Field(&#x27;visits&#x27;, &#x27;integer&#x27;, default=0),</div><div class="">         Field(&#x27;clicks&#x27;, &#x27;integer&#x27;, default=0))</div><div class=""> &gt;&gt;&gt; db(db.person.visits == db.person.clicks + 1).delete()</div><div class=""> ``:code</div><div class=""> </div><div class="insert">+#### ``case`` ``case``:inxx</div><div class="insert">+</div><div class="insert">+An expression can contain a case clause for example:</div><div class="insert">+</div><div class="insert">+``</div><div class="insert">+&gt;&gt;&gt; db.define_table(&#x27;person&#x27;,Field(&#x27;name&#x27;))</div><div class="insert">+&gt;&gt;&gt; condition = db.person.name.startswith(&#x27;M&#x27;)</div><div class="insert">+&gt;&gt;&gt; yes_or_no = condition.case(&#x27;Yes&#x27;,&#x27;No&#x27;)</div><div class="insert">+&gt;&gt;&gt; for row in db().select(db.person.name, yes_or_no):</div><div class="insert">+...     print row.person.name,  row(yes_or_no)</div><div class="insert">+Max Yes</div><div class="insert">+John No</div><div class="insert">+``:code</div><div class="insert">+</div><div class=""> #### ``update_record``</div><div class=""> </div><div class=""> ``update_record``:inxx</div><div class=""> web2py also allows updating a single record that is already in memory using ``update_record``</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; row = db(db.person.id==2).select().first()</div><div class=""> &gt;&gt;&gt; row.update_record(name=&#x27;Curt&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> ``update_record`` should not be confused with</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; row.update(name=&#x27;Curt&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> because for a single row, the method ``update`` updates the row object but not the database record, as in the case of ``update_record``.</div><div class=""> </div><div class=""> It is also possible to change the attributes of a row (one at a time) and then call ``update_record()`` without arguments to save the changes:</div><div class=""> </div><div class=""> Here ``f`` is a dict of fields passed to insert or update, ``id`` is the id of t</div><div class=""> &gt;&gt;&gt; db(db.person.id==1).update(name=&#x27;Tim&#x27;)</div><div class=""> (&lt;Set (person.id = 1)&gt;, {&#x27;name&#x27;: &#x27;Tim&#x27;})</div><div class=""> (&lt;Set (person.id = 1)&gt;, {&#x27;name&#x27;: &#x27;Tim&#x27;})</div><div class=""> &gt;&gt;&gt; db(db.person.id==1).delete()</div><div class=""> (&lt;Set (person.id = 1)&gt;,)</div><div class=""> (&lt;Set (person.id = 1)&gt;,)</div><div class=""> ``:code</div><div class=""> </div><div class=""> The return values of these callback should be ``None`` or ``False``. If any of the ``_before_*`` callback returns a ``True`` value it will abort the actual insert/update/delete operation.</div><div class=""> </div><div class=""> ``update_naive``:inxx.</div><div class=""> </div><div class=""> Some times a callback may need to perform an update in the same of a different table and one wants to avoid callbacks calling themselves recursively.</div><div class=""> </div><div class=""> For this purpose there the Set objects have an ``update_naive`` method that works like ``update`` but ignores before and after callbacks.</div><div class=""> </div><div class=""> #### Record versioning </div><div class=""> </div><div class=""> ``_enable_record_versioning``:inxx</div><div class=""> </div><div class="insert">+It is possible to ask web2py to save every copy of a record when the record is modified. There are different ways to do it and it can be done for all tables at once using the syntax:</div><div class="insert">+</div><div class="insert">+``</div><div class="insert">+auth.enable_record_versioning(db)</div><div class="insert">+``:code</div><div class="insert">+</div><div class="insert">+this requires Auth and it is discussed in the chapter about authentication. </div><div class="insert">+It can also be done for each individual table as discussed below.</div><div class=""> </div><div class=""> Consider the following table:</div><div class=""> </div><div class=""> ``</div><div class=""> db.define_table(&#x27;stored_item&#x27;,</div><div class="">     Field(&#x27;name&#x27;),</div><div class="">     Field(&#x27;quantity&#x27;,&#x27;integer&#x27;),</div><div class="">     Field(&#x27;is_active&#x27;,&#x27;boolean&#x27;,</div><div class="">           writable=False,readable=False,default=True))</div><div class=""> ``:code</div><div class=""> </div><div class=""> Notice we the hidden boolean field called ``is_active`` and defaulting to </div><div class=""> True.</div><div class=""> </div><div class=""> We can tell web2py to create a new table (in the same or a different database) and store all previous versions of each record in the table, when modified.</div><div class=""> </div><div class=""> This is done in the following way:</div><div class=""> ``</div><div class=""> db.stored_item._enable_record_versioning()</div><div class=""> ``:code</div><div class=""> The DAL can be used from any Python program simply by doing this:</div><div class=""> </div><div class=""> ``</div><div class=""> from gluon import DAL, Field</div><div class=""> db = DAL(&#x27;sqlite://storage.sqlite&#x27;,folder=&#x27;path/to/app/databases&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> i.e. import the DAL, Field, connect and specify the folder which contains the .table files (the app/databases folder).</div><div class=""> </div><div class=""> To access the data and its attributes we still have to define all the tables we are going to access with ``db.define_tables(...)``.</div><div class=""> </div><div class=""> If we just need access to the data but not to the web2py table attributes, we get away without re-defining the tables but simply asking web2py to read the necessary info from the metadata in the .table files:</div><div class=""> </div><div class=""> ``</div><div class=""> from gluon import DAL, Field</div><div class=""> db = DAL(&#x27;sqlite://storage.sqlite&#x27;,folder=&#x27;path/to/app/databases&#x27;,</div><div class="">          auto_import=True))</div><div class=""> ``:code</div><div class=""> </div><div class=""> This allows us to access any ``db.table`` without need to re-define it.</div><div class=""> </div><div class="insert">+#### postgis and spatialite (experimental)</div><div class="insert">+</div><div class="insert">+The DAL supports geographical APIs using postgis (for postgresql) and spatialite (for MSSQL and SQLite). This is a feature that was sponosred by the Sahana project and implemented by Denes Lengyel.</div><div class="insert">+</div><div class="insert">+DAL provides geometry and geography fields types and the following functions:</div><div class="insert">+</div><div class="insert">+``</div><div class="insert">+st_asgeojson (PostGIS only)</div><div class="insert">+st_astext</div><div class="insert">+st_contained</div><div class="insert">+st_contains</div><div class="insert">+st_distance</div><div class="insert">+st_equals</div><div class="insert">+st_intersects</div><div class="insert">+st_overlaps</div><div class="insert">+st_simplify (PostGIS only)</div><div class="insert">+st_touches</div><div class="insert">+st_within</div><div class="insert">+``</div><div class="insert">+</div><div class="insert">+Here are some examples:</div><div class="insert">+</div><div class="insert">+``</div><div class="insert">+from gluon.dal import DAL, Field, geoPoint, geoLine, geoPolygon</div><div class="insert">+db = DAL(&quot;mssql://user:pass@host:db&quot;)</div><div class="insert">+sp = db.define_table(&#x27;spatial&#x27;,</div><div class="insert">+  Field(&#x27;loc&#x27;,&#x27;geometry()&#x27;)</div><div class="insert">+)</div><div class="insert">+``:code</div><div class="insert">+</div><div class="insert">+Below we insert a point, a line, and a polygon:</div><div class="insert">+``</div><div class="insert">+sp.insert(loc=geoPoint(1,1))</div><div class="insert">+sp.insert(loc=geoLine((100,100),(20,180),(180,180)))</div><div class="insert">+sp.insert(loc=geoPolygon((0,0),(150,0),(150,150),(0,150),(0,0)))</div><div class="insert">+``:code</div><div class="insert">+</div><div class="insert">+Notice that</div><div class="insert">+``</div><div class="insert">+print db(sp.id&gt;0).select()</div><div class="insert">+``:code</div><div class="insert">+</div><div class="insert">+will not display the values of these fields. You can print them with:</div><div class="insert">+</div><div class="insert">+``</div><div class="insert">+print db(sp.id&gt;0).select(sp.id, sp.loc.st_astext())</div><div class="insert">+spatial.id,spatial.loc.STAsText()</div><div class="insert">+1, POINT (1 2)&quot;</div><div class="insert">+2, LINESTRING (100 100, 20 180, 180 180)</div><div class="insert">+3, POLYGON ((0 0, 150 0, 150 150, 0 150, 0 0))</div><div class="insert">+``:code</div><div class="insert">+</div><div class="insert">+or serialize them as json:</div><div class="insert">+</div><div class="insert">+``</div><div class="insert">+print db(sp.id&gt;0).select(sp.id, sp.loc.st_asgeojson().with_alias(&#x27;loc&#x27;))</div><div class="insert">+spatial.id,loc</div><div class="insert">+1, [1, 2]</div><div class="insert">+2, [[100, 100], [20 180], [180, 180]]</div><div class="insert">+3, [[[0, 0], [150, 0], [150, 150], [0, 150], [0, 0]]]</div><div class="insert">+``:code</div><div class="insert">+</div><div class="insert">+Here are example of how to use geographical functions:</div><div class="insert">+</div><div class="insert">+``</div><div class="insert">+query = sp.loc.st_intersects(geoLine((20,120),(60,160)))</div><div class="insert">+query = sp.loc.st_overlaps(geoPolygon((1,1),(11,1),(11,11),(11,1),(1,1)))</div><div class="insert">+query = sp.loc.st_contains(geoPoint(1,1))</div><div class="insert">+print db(query).select(sp.id,sp.loc.st_astext())</div><div class="insert">+spatial.id,spatial.loc.STAsText()</div><div class="insert">+3,&quot;POLYGON ((0 0, 150 0, 150 150, 0 150, 0 0))&quot;</div><div class="insert">+``:code</div><div class="insert">+</div><div class="insert">+Computed distances can also be retrieved as floating point numbers:</div><div class="insert">+</div><div class="insert">+``</div><div class="insert">+dist = sp.loc.st_distance(geoPoint(-1,2)).with_alias(&#x27;dist&#x27;)</div><div class="insert">+print db(sp.id&gt;0).select(sp.id, dist)</div><div class="insert">+spatial.id, dist</div><div class="insert">+1 2.0</div><div class="insert">+2 140.714249456</div><div class="insert">+3 1.0</div><div class="insert">+``:code</div><div class="insert">+</div><div class="insert">+New versions of web2py may include automatic conversions from promitive geographical types to Python geographical objects encoded, for example, as tuples.</div><div class="insert">+</div><div class=""> #### Copy data from one db into another</div></div></div>
    <div class="span6"><div class="diff"><div class="delete">web2py comes with a Database Abstraction Layer (DAL), an API that maps Python objects into database objects such as queries, tables, and records. The DAL dynamically generates the SQL in real time using the specified dialect for the database back end, so that you do not have to write SQL code or learn different SQL dialects (the term SQL is used generically), and the application will be portable among different types of databases. At the time of this writing, the supported databases are SQLite (which comes with Python and thus web2py), PostgreSQL, MySQL, Oracle, MSSQL, FireBird, DB2, Informix, Ingres, <span class="highlight"></span>the Google App Engine (SQL and NoSQL)<span class="highlight"> and MongoDB</span>. Experimentally we support more databases. Please check on the web2py web site and mailing list for more recent adapters. Google NoSQL is treated as a particular case in Chapter 13.</div><div class=""> </div><div class=""> The Windows binary distribution works out of the box with SQLite and MySQL. The Mac binary distribution works out of the box with SQLite.</div><div class=""> To use any other database back-end, run from the source distribution and install the appropriate driver for the required back end.</div><div class=""> ``database drivers``:inxx</div><div class=""> </div><div class=""> Once the proper driver is installed, start web2py from source, and it will find the driver. Here is a list of drivers:</div><div class=""> </div><div class=""> ``DAL``:inxx ``SQLite``:inxx ``MySQL``:inxx ``PostgresSQL``:inxx ``Oracle``:inxx ``MSSQL``:inxx ``FireBird``:inxx ``DB2``:inxx ``Informix``:inxx ``Sybase``:inxx ``Teradata``:inxx ``MongoDB``:inxx ``CouchDB``:inxx ``SAPDB``:inxx ``Cubrid``:inxx</div><div class=""> </div><div class=""> ----------</div><div class=""> database | drivers (source)</div><div class=""> SQLite | sqlite3 or pysqlite2 or zxJDBC ``zxjdbc``:cite  (on Jython)</div><div class=""> PostgreSQL | psycopg2 ``psycopg2``:cite  or pg8000 ``pg8000``:cite or zxJDBC ``zxjdbc``:cite  (on Jython)</div><div class=""> MySQL | pymysql ``pymysql``:cite or MySQLdb ``mysqldb``:cite</div><div class=""> Oracle | cx_Oracle ``cxoracle``:cite</div><div class=""> MSSQL | pyodbc ``pyodbc``:cite</div><div class=""> FireBird | kinterbasdb ``kinterbasdb``:cite or fdb or pyodbc</div><div class=""> DB2 | pyodbc ``pyodbc``:cite</div><div class=""> Informix | informixdb ``informixdb``:cite</div><div class=""> Ingres | ingresdbi ``ingresdbi``:cite</div><div class=""> A connection with the database is established by creating an instance of the DAL</div><div class=""> **MSSQL**      | ``mssql://username:password@localhost/test``</div><div class=""> **FireBird**   | ``firebird://username:password@localhost/test``</div><div class=""> **Oracle**     | ``oracle://username/password@test``</div><div class=""> **DB2**        | ``db2://username:password@test``</div><div class=""> **Ingres**     | ``ingres://username:password@localhost/test``</div><div class=""> **Sybase**     | ``sybase://username:password@localhost/test``</div><div class=""> **Informix**   | ``informix://username:password@test``</div><div class=""> **Teradata**   | ``teradata://DSN=dsn;UID=user;PWD=pass;DATABASE=database``</div><div class=""> **Cubrid**     | ``cubrid://username:password@localhost/test``</div><div class=""> **SAPDB**      | ``sapdb://username:password@localhost/test``</div><div class=""> **IMAP**       | ``imap://user:password@server:port``</div><div class=""> **MongoDB**    | ``mongodb://username:password@localhost/test``</div><div class=""> **Google App Engine/SQL** | ``google:sql``</div><div class=""> **Google App Engine/NoSQL** | ``google:datastore``</div><div class=""> -------------</div><div class=""> </div><div class=""> Notice that in SQLite the database consists of a single file. If it does not exist, it is created. This file is locked every time it is accessed. In the case of MySQL, PostgreSQL, MSSQL, FireBird, Oracle, DB2, Ingres and Informix the database &quot;test&quot; must be created outside web2py. Once the connection is established, web2py will create, alter, and drop tables appropriately.</div><div class=""> </div><div class=""> It is also possible to set the connection string to ``None``. In this case DAL will not connect to any back-end database, but the API can still be accessed for testing. Examples of this will be discussed in Chapter 7.</div><div class=""> </div><div class=""> #### Connection pooling</div><div class=""> ``connection pooling``:inxx</div><div class=""> </div><div class=""> The second argument of the DAL constructor is the ``pool_size``; it defaults to 0.</div><div class=""> </div><div class=""> As it is rather slow to establish a new database connection for each request, web2py implements a mechanism for connection pooling. Once a connection is established and the page has been served and the transaction completed, the connection is not closed but goes into a pool. When the next http request arrives, web2py tries to obtain a connection from the pool and use that for the new transaction. If there are no available connections in the pool, a new connection is established.</div><div class=""> </div><div class=""> The ``pool_size`` parameter is ignored by SQLite and Google App Engine.</div><div class=""> </div><div class=""> Connections in the pools are shared sequentially among threads, in the sense that they may be used by two different but not simultaneous threads. There is only one pool for each web2py process.</div><div class=""> </div><div class=""> When web2py starts, the pool is always empty. The pool grows up to the minimum between the value of ``pool_size`` and the max number of concurrent requests. This means that if ``pool_size=10`` but our server never receives more than 5 concurrent requests, then the actual pool size will only grow to 5. If ``pool_size=0`` then connection pooling is not used.</div><div class=""> </div><div class=""> Connection pooling is ignored for SQLite, since it would not yield any benefit.</div><div class=""> </div><div class=""> #### Connection failures</div><div class=""> </div><div class=""> If web2py fails to connect to the database it waits 1 seconds and tries again up to 5 times before declaring a failure. In case of connection pooling it is possible that a pooled connection that stays open but unused for some time is closed by the database end. Thanks to the retry feature web2py tries to re-establish these dropped connections.</div><div class=""> </div><div class=""> When using connection pooling a connection is used, put back in the pool and then recycled. It is possible that while the connection is idle in pool the connection is closed by the database server. This can be because of a malfunction or a timeout. When this happens web2py detects it and re-establish the connection.</div><div class=""> sqlite</div><div class=""> The connection string is called a ``_uri`` because it is an instance of a Uniform Resource Identifier.</div><div class=""> </div><div class=""> The DAL allows multiple connections with the same database or with different databases, even databases of different types. For now, we will assume the presence of a single database since this is the most common situation.</div><div class=""> </div><div class=""> ``define_table``:inxx ``Field``:inxx</div><div class=""> ``type``:inxx ``length``:inxx ``default``:inxx ``requires``:inxx ``required``:inxx ``unique``:inxx</div><div class=""> ``notnull``:inxx ``ondelete``:inxx ``uploadfield``:inxx ``uploadseparate``:inxx ``migrate``:inxx ``sql.log``:inxx</div><div class=""> </div><div class=""> The most important method of a DAL is ``define_table``:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class=""> It defines, stores and returns a ``Table`` object called &quot;person&quot; containing a field (column) &quot;name&quot;. This object can also be accessed via ``db.person``, so you do not need to catch the return value.</div><div class=""> </div><div class=""> Do not declare a field called &quot;id&quot;, because one is created by web2py anyway. Every table has a field called &quot;id&quot; by default. It is an auto-increment integer field (starting at 1) used for cross-reference and for making every record unique, so &quot;id&quot; is a primary key. (Note: the id&#x27;s starting at 1 is back-end specific. For example, this does not apply to the Google App Engine NoSQL.)</div><div class=""> </div><div class=""> ``named id field``:inxx</div><div class=""> Optionally you can define a field of ``type=&#x27;id&#x27;`` and web2py will use this field as auto-increment id field. This is not recommended except when accessing legacy database tables. With some limitation, you can also use different primary keys and this is discussed in the section on &quot;Legacy databases and keyed tables&quot;.</div><div class=""> </div><div class=""> ----------</div><div class=""> Because usually in web2py models are executed before controllers, it is possible that some table are defined even if not needed. It is therefore necessary to speed up the code by making table definitions lazy. This is done by setting the ``DAL(...,lazy_tables=True)`` attributes. Tables will be actually created only when accessed.</div><div class=""> ----------</div><div class=""> </div><div class=""> ### Record representation</div><div class=""> </div><div class=""> It is optional but recommended to specify a format representation for records:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;), format=&#x27;%(name)s&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> or</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;), format=&#x27;%(name)s %(id)s&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> or even more complex ones using a function:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;),</div><div class="">        format=lambda r: r.name or &#x27;anonymous&#x27;)</div><div class=""> And you can update all records in a set by passing named arguments corresponding</div><div class=""> #### Expressions</div><div class=""> </div><div class=""> The value assigned an update statement can be an expression. For example consider this model</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;,</div><div class="">         Field(&#x27;name&#x27;),</div><div class="">         Field(&#x27;visits&#x27;, &#x27;integer&#x27;, default=0))</div><div class=""> &gt;&gt;&gt; db(db.person.name == &#x27;Massimo&#x27;).update(</div><div class="">         visits = db.person.visits + 1)</div><div class=""> ``:code</div><div class=""> </div><div class=""> The values used in queries can also be expressions</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;,</div><div class="">         Field(&#x27;name&#x27;),</div><div class="">         Field(&#x27;visits&#x27;, &#x27;integer&#x27;, default=0),</div><div class="">         Field(&#x27;clicks&#x27;, &#x27;integer&#x27;, default=0))</div><div class=""> &gt;&gt;&gt; db(db.person.visits == db.person.clicks + 1).delete()</div><div class=""> ``:code</div><div class=""> </div><div class=""> #### ``update_record``</div><div class=""> </div><div class=""> ``update_record``:inxx</div><div class=""> web2py also allows updating a single record that is already in memory using ``update_record``</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; row = db(db.person.id==2).select().first()</div><div class=""> &gt;&gt;&gt; row.update_record(name=&#x27;Curt&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> ``update_record`` should not be confused with</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; row.update(name=&#x27;Curt&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> because for a single row, the method ``update`` updates the row object but not the database record, as in the case of ``update_record``.</div><div class=""> </div><div class=""> It is also possible to change the attributes of a row (one at a time) and then call ``update_record()`` without arguments to save the changes:</div><div class=""> </div><div class=""> Here ``f`` is a dict of fields passed to insert or update, ``id`` is the id of t</div><div class=""> &gt;&gt;&gt; db(db.person.id==1).update(name=&#x27;Tim&#x27;)</div><div class=""> (&lt;Set (person.id = 1)&gt;, {&#x27;name&#x27;: &#x27;Tim&#x27;})</div><div class=""> (&lt;Set (person.id = 1)&gt;, {&#x27;name&#x27;: &#x27;Tim&#x27;})</div><div class=""> &gt;&gt;&gt; db(db.person.id==1).delete()</div><div class=""> (&lt;Set (person.id = 1)&gt;,)</div><div class=""> (&lt;Set (person.id = 1)&gt;,)</div><div class=""> ``:code</div><div class=""> </div><div class=""> The return values of these callback should be ``None`` or ``False``. If any of the ``_before_*`` callback returns a ``True`` value it will abort the actual insert/update/delete operation.</div><div class=""> </div><div class=""> ``update_naive``:inxx.</div><div class=""> </div><div class=""> Some times a callback may need to perform an update in the same of a different table and one wants to avoid callbacks calling themselves recursively.</div><div class=""> </div><div class=""> For this purpose there the Set objects have an ``update_naive`` method that works like ``update`` but ignores before and after callbacks.</div><div class=""> </div><div class=""> #### Record versioning </div><div class=""> </div><div class=""> ``_enable_record_versioning``:inxx</div><div class=""> </div><div class="delete">-It is possible to ask web2py to save every copy of a record when the record is modified. There are many ways to do it and it can be done for all tables at once using the ``auth.enable_record_versioning`` method, discussed in the chapter about authentication, or it can be done for each individual table as discussed here.</div><div class=""> </div><div class=""> Consider the following table:</div><div class=""> </div><div class=""> ``</div><div class=""> db.define_table(&#x27;stored_item&#x27;,</div><div class="">     Field(&#x27;name&#x27;),</div><div class="">     Field(&#x27;quantity&#x27;,&#x27;integer&#x27;),</div><div class="">     Field(&#x27;is_active&#x27;,&#x27;boolean&#x27;,</div><div class="">           writable=False,readable=False,default=True))</div><div class=""> ``:code</div><div class=""> </div><div class=""> Notice we the hidden boolean field called ``is_active`` and defaulting to </div><div class=""> True.</div><div class=""> </div><div class=""> We can tell web2py to create a new table (in the same or a different database) and store all previous versions of each record in the table, when modified.</div><div class=""> </div><div class=""> This is done in the following way:</div><div class=""> ``</div><div class=""> db.stored_item._enable_record_versioning()</div><div class=""> ``:code</div><div class=""> The DAL can be used from any Python program simply by doing this:</div><div class=""> </div><div class=""> ``</div><div class=""> from gluon import DAL, Field</div><div class=""> db = DAL(&#x27;sqlite://storage.sqlite&#x27;,folder=&#x27;path/to/app/databases&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> i.e. import the DAL, Field, connect and specify the folder which contains the .table files (the app/databases folder).</div><div class=""> </div><div class=""> To access the data and its attributes we still have to define all the tables we are going to access with ``db.define_tables(...)``.</div><div class=""> </div><div class=""> If we just need access to the data but not to the web2py table attributes, we get away without re-defining the tables but simply asking web2py to read the necessary info from the metadata in the .table files:</div><div class=""> </div><div class=""> ``</div><div class=""> from gluon import DAL, Field</div><div class=""> db = DAL(&#x27;sqlite://storage.sqlite&#x27;,folder=&#x27;path/to/app/databases&#x27;,</div><div class="">          auto_import=True))</div><div class=""> ``:code</div><div class=""> </div><div class=""> This allows us to access any ``db.table`` without need to re-define it.</div><div class=""> </div><div class=""> #### Copy data from one db into another</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/82dc64e7baa231edd3896ca7a0d41393e426f123">82dc64e</a><ul><li>Date : 2012-12-19</li><li>lots of small additions</li></ul></li></ul>
<div class="row-fluid" id="com_82dc64e7baa231edd3896ca7a0d41393e426f123">
    <div class="span6"><div class="diff"><div class=""> ``Expression``:inxx</div><div class="insert">+</div><div class=""> **Expression** is something like an ``orderby`` or ``groupby`` expression. The Field class is derived from the Expression. Here is an example.</div><div class=""> ``</div><div class=""> myorder = db.mytable.myfield.upper() | db.mytable.id</div><div class=""> db().select(db.table.ALL, orderby=myorder)</div><div class=""> ``:code</div><div class=""> </div><div class=""> ### Connection strings</div><div class=""> ``connection strings``:inxx</div><div class=""> </div><div class=""> A connection with the database is established by creating an instance of the DAL object:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db = DAL(&#x27;sqlite://storage.db&#x27;, pool_size=0)</div><div class=""> ``:code</div><div class=""> ``db`` is not a keyword; it is a local variable that stores the connection object ``DAL``. You are free to give it a different name. The constructor of ``DAL`` requires a single argument, the connection string. The connection string is the only web2py code that depends on a specific back-end database. Here are examples of connection strings for specific types of supported back-end databases (in all cases, we assume the database is running from localhost on its default port and is named &quot;test&quot;):</div><div class=""> </div><div class=""> -------------</div><div class=""> **SQLite**     | ``sqlite://storage.db``</div><div class=""> **MySQL**      | ``mysql://username:password@localhost/test``</div><div class=""> **PostgreSQL** | ``postgres://username:password@localhost/test``</div><div class=""> **MSSQL**      | ``mssql://username:password@localhost/test``</div><div class=""> which returns a tuple ``(value, error)``. ``error`` is ``None`` if the input pas</div><div class=""> </div><div class=""> We refer to this behavior as a &quot;migration&quot;. web2py logs all migrations and migration attempts in the file &quot;databases/sql.log&quot;.</div><div class=""> </div><div class=""> The first argument of ``define_table`` is always the table name. The other unnamed arguments are the fields (Field). The function also takes an optional last argument called &quot;migrate&quot; which must be referred to explicitly by name as in:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;), migrate=&#x27;person.table&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> The value of migrate is the filename (in the &quot;databases&quot; folder for the application) where web2py stores internal migration information for this table. These files are very important and should never be removed except when the entire database is dropped. In this case, the &quot;.table&quot; files have to be removed manually. By default, migrate is set to True. This causes web2py to generate the filename from a hash of the connection string. If migrate is set to False, the migration is not performed, and web2py assumes that the table exists in the datastore and it contains (at least) the fields listed in ``define_table``.</div><div class=""> The best practice is to give an explicit name to the migrate table.</div><div class=""> </div><div class=""> There may not be two tables in the same application with the same migrate filename.</div><div class=""> </div><div class=""> The DAL class also takes a &quot;migrate&quot; argument, which determines the default value of migrate for calls to ``define_table``. For example,</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db = DAL(&#x27;sqlite://storage.db&#x27;, migrate=False)</div><div class=""> ``:code</div><div class=""> </div><div class=""> will set the default value of migrate to False whenever ``db.define_table`` is called without a migrate argument.</div><div class=""> </div><div class="insert">+------</div><div class="insert">+Notice that web2py only migrates new columns, removed columns, and changes in column type (not in sqlite). web2py does not migrate changes in attributes such as changes in the values of ``default``, ``unique``, ``notnull``, and ``ondelete``.</div><div class="insert">+------</div><div class="insert">+</div><div class=""> Migrations can be disabled for all tables at the moment of connection:</div><div class=""> </div><div class=""> ``</div><div class=""> db = DAL(...,migrate_enabled=False)</div><div class=""> ``</div><div class=""> </div><div class=""> This is the recommended behavior when two apps share the same database. Only one of the two apps should perform migrations, the other should disabled them.</div><div class=""> </div><div class=""> ### Fixing broken migrations</div><div class=""> ``fake_migrate``:inxx</div><div class=""> </div><div class=""> There are two common problems with migrations and there are ways to recover from them.</div><div class=""> </div><div class=""> One problem is specific with SQLite. SQLite does not enforce column types and cannot drop columns. This means that if you have a column of type string and you remove it, it is not really removed. If you add the column again with a different type (for example datetime) you end up with a datetime column that contains strings (junk for practical purposes). web2py does not complain about this because it does not know what is in the database, until it tries to retrieve records and fails.</div><div class=""> </div><div class=""> If web2py returns an error in the gluon.sql.parse function when selecting records, this is the problem: corrupted data in a column because of the above issue.</div><div class=""> </div><div class=""> The solution consists in updating all records of the table and updating the values in the column in question with None.</div><div class=""> </div><div class=""> The other problem is more generic but typical with MySQL. MySQL does not allow more than one ALTER TABLE in a transaction. This means that web2py must break complex transactions into smaller ones (one ALTER TABLE at the time) and commit one piece at the time. It is therefore possible that part of a complex transaction gets committed and one part fails, leaving web2py in a corrupted state. Why would part of a transaction fail? Because, for example, it involves altering a table and converting a string column into a datetime column, web2py tries to convert the data, but the data cannot be converted. What happens to web2py? It gets confused about what exactly is the table structure actually stored in the database.</div><div class=""> Given a table, you can insert records</div><div class=""> 1</div><div class=""> &gt;&gt;&gt; db.person.insert(name=&quot;Bob&quot;)</div><div class=""> 2</div><div class=""> ``:code</div><div class=""> </div><div class=""> Insert returns the unique &quot;id&quot; value of each record inserted.</div><div class=""> </div><div class=""> You can truncate the table, i.e., delete all records and reset the counter of the id.</div><div class=""> </div><div class=""> ``truncate``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.person.truncate()</div><div class=""> ``:code</div><div class=""> </div><div class=""> Now, if you insert a record again, the counter starts again at 1 (this is back-end specific and does not apply to Google NoSQL):</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.person.insert(name=&quot;Alex&quot;)</div><div class=""> 1</div><div class=""> ``:code</div><div class=""> </div><div class="insert">+Notice you can pass parameters to ``truncate``, for example you can tell SQLITE to restart the id counter.</div><div class="insert">+</div><div class="insert">+``</div><div class="insert">+db.person.truncate(&#x27;RESTART IDENTITY CASCADE&#x27;)</div><div class="insert">+``:code</div><div class="insert">+</div><div class="insert">+The argument is in raw SQL and thefeore engine specific.</div><div class="insert">+</div><div class=""> ``bulk_insert``:inxx</div><div class=""> web2py also provides a bulk_insert method</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.person.bulk_insert([{&#x27;name&#x27;:&#x27;Alex&#x27;}, {&#x27;name&#x27;:&#x27;John&#x27;}, {&#x27;name&#x27;:&#x27;Tim&#x27;}])</div><div class=""> [3,4,5]</div><div class=""> ``:code</div><div class=""> </div><div class=""> It takes a list of dictionaries of fields to be inserted and performs multiple inserts at once. It returns the IDs of the inserted records. On the supported relational databases there is no advantage in using this function as opposed to looping and performing individual inserts but on Google App Engine NoSQL, there is a major speed advantage.</div><div class=""> </div><div class=""> ### ``commit`` and ``rollback``</div><div class=""> </div><div class=""> No create, drop, insert, truncate, delete, or update operation is actually committed until you issue the commit command</div><div class=""> </div><div class=""> ``commit``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.commit()</div><div class=""> ``:code</div><div class=""> </div><div class=""> To check it let&#x27;s insert a new record:</div><div class=""> ``</div><div class=""> Here is an example:</div><div class=""> ------</div><div class=""> ``SQLTABLE`` is useful but there are types when one needs more. ``SQLFORM.grid`` is an extension of SQLTABLE that creates a table with search features and pagination, as well as ability to open detailed records, create, edit and delete records. ``SQLFORM.smartgrid`` is a further generalization that allows all of the above but also creates buttons to access referencing records.</div><div class=""> ------</div><div class=""> </div><div class=""> Here is an example of usage of ``SQLFORM.grid``:</div><div class=""> </div><div class=""> ``</div><div class=""> def index():</div><div class="">     return dict(grid=SQLFORM.grid(query))</div><div class=""> ``:code</div><div class=""> </div><div class=""> and the corresponding view:</div><div class=""> </div><div class=""> ``</div><div class=""> {{extend &#x27;layout.html&#x27;}}</div><div class=""> {{=grid}}</div><div class=""> ``</div><div class=""> </div><div class=""> ``SQLFORM.grid`` and ``SQLFORM.smartgrid`` should be preferred to ``SQLTABLE`` because they are more powerful although higher level and therefore more constraining. They will be explained in more detail in chapter 8.</div><div class=""> </div><div class="insert">#### ``orderby``, ``groupby``, ``limitby``, ``distinct``<span class="highlight">, ``having``</span></div><div class=""> </div><div class=""> The ``select`` command takes five optional arguments: orderby, groupby, limitby, left and cache. Here we discuss the first three.</div><div class=""> </div><div class=""> You can fetch the records sorted by name:</div><div class=""> </div><div class="insert">``orderby``:inxx<span class="highlight"> ``groupby``:inxx ``having``:inxx</span></div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db().select(</div><div class="">         db.person.ALL, orderby=db.person.name):</div><div class="">         print row.name</div><div class=""> Alex</div><div class=""> Bob</div><div class=""> Carl</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can fetch the records sorted by name in reverse order (notice the tilde):</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db().select(</div><div class="">         db.person.ALL, orderby=~db.person.name):</div><div class="">         print row.name</div><div class=""> Carl</div><div class=""> Bob</div><div class=""> Alex</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can have the fetched records appear in random order:</div><div class=""> And you can sort the records according to multiple fields by concatenating them</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db().select(</div><div class="">         db.person.ALL, orderby=db.person.name|db.person.id):</div><div class="">         print row.name</div><div class=""> Carl</div><div class=""> Bob</div><div class=""> Alex</div><div class=""> ``:code</div><div class=""> </div><div class=""> Using ``groupby`` together with ``orderby``, you can group records with the same value for the specified field (this is back-end specific, and is not on the Google NoSQL):</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db().select(</div><div class="">         db.person.ALL,</div><div class="">         orderby=db.person.name, groupby=db.person.name):</div><div class="">         print row.name</div><div class=""> Alex</div><div class=""> Bob</div><div class=""> Carl</div><div class=""> ``:code</div><div class=""> </div><div class="insert">+You can use ``having`` in conjunction with ``groupby`` to group conditionally (only those ``having`` the condition are grouped.</div><div class="insert">+</div><div class="insert">+``</div><div class="insert">+&gt;&gt;&gt; print db(query1).select(db.person.ALL, groupby=db.person.name, having=query2)</div><div class="insert">+``</div><div class="insert">+</div><div class="insert">+Notice that query1 filters records to be displayed, query2 filters records to be grouped.</div><div class="insert">+</div><div class=""> ``distinct``:inxx</div><div class=""> </div><div class=""> With the argument ``distinct=True``, you can specify that you only want to select distinct records. This has the same effect as grouping using all specified fields except that it does not require sorting. When using distinct it is important not to select ALL fields, and in particular not to select the &quot;id&quot; field, else all records will always be distinct.</div><div class=""> </div><div class=""> Here is an example:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db().select(db.person.name, distinct=True):</div><div class="">         print row.name</div><div class=""> Alex</div><div class=""> Bob</div><div class=""> Carl</div><div class=""> ``:code</div><div class=""> </div><div class=""> Notice that ``distinct`` can also be an expression for example:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db().select(db.person.name,distinct=db.person.name):</div><div class="">         print row.name</div><div class=""> Alex</div><div class=""> Bob</div><div class=""> Carl</div><div class=""> and the binary OR operator &quot;``|``&quot;:</div><div class=""> &gt;&gt;&gt; for row in rows: print row.id, row.name</div><div class=""> 1 Alex</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can negate a query (or sub-query) with the &quot;``!=``&quot; binary operator:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows = db((db.person.name!=&#x27;Alex&#x27;) | (db.person.id&gt;3)).select()</div><div class=""> &gt;&gt;&gt; for row in rows: print row.id, row.name</div><div class=""> 2 Bob</div><div class=""> 3 Carl</div><div class=""> ``:code</div><div class=""> </div><div class=""> or by explicit negation with the &quot;``~``&quot; unary operator:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows = db((~db.person.name==&#x27;Alex&#x27;) | (db.person.id&gt;3)).select()</div><div class=""> &gt;&gt;&gt; for row in rows: print row.id, row.name</div><div class=""> 2 Bob</div><div class=""> 3 Carl</div><div class=""> ``:code</div><div class=""> </div><div class="insert">+------</div><div class=""> Due to Python restrictions in overloading &quot;``and``&quot; and &quot;``or``&quot; operators, these cannot be used in forming queries.  The binary operators &quot;``&amp;``&quot; and &quot;``|``&quot; must be used instead. Note that these operators (unlike &quot;``and``&quot; and &quot;``or``&quot;) have higher precedence than comparison operators, so the &quot;extra&quot; parentheses in the above examples are mandatory.</div><div class="insert">+------</div><div class=""> </div><div class=""> It is also possible to build queries using in-place logical operators:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; query = db.person.name!=&#x27;Alex&#x27;</div><div class=""> &gt;&gt;&gt; query &amp;= db.person.id&gt;3</div><div class=""> &gt;&gt;&gt; query |= db.person.name==&#x27;John&#x27;</div><div class=""> ``</div><div class=""> </div><div class=""> #### ``count``, ``isempty``, ``delete``, ``update``</div><div class=""> </div><div class=""> You can count records in a set:</div><div class=""> </div><div class=""> ``count``:inxx ``isempty``:inxx</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; print db(db.person.id &gt; 0).count()</div><div class=""> 3</div><div class=""> ``:code</div><div class=""> </div><div class=""> are equivalent to</div><div class=""> &gt;&gt;&gt; last_row = rows[-1] if len(rows)&gt;0 else None</div><div class=""> ``:code</div><div class=""> </div><div class=""> #### ``as_dict`` and ``as_list``</div><div class=""> ``as_list``:inxx ``as_dict``:inxx</div><div class=""> </div><div class=""> A Row object can be serialized into a regular dictionary using the ``as_dict()`` method and a Rows object can be serialized into a list of dictionaries using the ``as_list()`` method. Here are some examples:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows = db(query).select()</div><div class=""> &gt;&gt;&gt; rows_list = rows.as_list()</div><div class=""> &gt;&gt;&gt; first_row_dict = rows.first().as_dict()</div><div class=""> ``:code</div><div class=""> </div><div class=""> These methods are convenient for passing Rows to generic views and or to store Rows in sessions (since Rows objects themselves cannot be serialized since contain a reference to an open DB connection):</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows = db(query).select()</div><div class=""> &gt;&gt;&gt; session.rows = rows # not allowed!</div><div class=""> &gt;&gt;&gt; session.rows = rows.as_list() # allowed!</div><div class=""> ``:code</div><div class=""> </div><div class="insert">+#### Combining rows</div><div class="insert">+</div><div class="insert">+Row objects can be conbined at the Python level. Here we assume:</div><div class="insert">+</div><div class="insert">+``</div><div class="insert">+&gt;&gt;&gt; print rows1</div><div class="insert">+person.name</div><div class="insert">+Max</div><div class="insert">+Tim</div><div class="insert">+&gt;&gt;&gt; print rows2</div><div class="insert">+person.name</div><div class="insert">+John</div><div class="insert">+Tim</div><div class="insert">+``</div><div class="insert">+</div><div class="insert">+</div><div class="insert">+You can do a union of the records in two set of rows:</div><div class="insert">+</div><div class="insert">+``</div><div class="insert">+&gt;&gt;&gt; rows3 = rows1 &amp; rows2</div><div class="insert">+&gt;&gt;&gt; print rows3</div><div class="insert">+name</div><div class="insert">+Max</div><div class="insert">+Tim</div><div class="insert">+John</div><div class="insert">+Tim</div><div class="insert">+``:code</div><div class="insert">+</div><div class="insert">+You can do a union of the records and removing duplicates:</div><div class="insert">+</div><div class="insert">+``</div><div class="insert">+&gt;&gt;&gt; rows3 = rows1 | rows2</div><div class="insert">+&gt;&gt;&gt; print rows3</div><div class="insert">+name</div><div class="insert">+Max</div><div class="insert">+Tim</div><div class="insert">+John</div><div class="insert">+``:code</div><div class="insert">+</div><div class=""> #### ``find``, ``exclude``, ``sort``</div><div class=""> ``find``:inxx ``exclude``:inxx ``sort``:inxx</div><div class=""> </div><div class=""> There are times when one needs to perform two selects and one contains a subset of a previous select. In this case it is pointless to access the database again. The ``find``, ``exclude`` and ``sort`` objects allow you to manipulate a Rows objects and generate another one without accessing the database. More specifically:</div><div class=""> - ``find`` returns a new set of Rows filtered by a condition and leaves the original unchanged.</div><div class=""> - ``exclude`` returns a new set of Rows filtered by a condition and removes them from the original Rows.</div><div class=""> - ``sort`` returns a new set of Rows sorted by a condition and leaves the original unchanged.</div><div class=""> </div><div class=""> All these methods take a single argument, a function that acts on each individual row.</div><div class=""> </div><div class=""> Here is an example of usage:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;,Field(&#x27;name&#x27;))</div><div class=""> &gt;&gt;&gt; db.person.insert(name=&#x27;John&#x27;)</div><div class=""> &gt;&gt;&gt; db.person.insert(name=&#x27;Max&#x27;)</div><div class=""> &gt;&gt;&gt; db.person.insert(name=&#x27;Alex&#x27;)</div><div class=""> &gt;&gt;&gt; rows = db(db.person).select()</div><div class=""> &gt;&gt;&gt; for row in rows.find(lambda row: row.name[0]==&#x27;M&#x27;):</div><div class="">         print row.name</div><div class=""> Max</div><div class=""> Max</div><div class=""> &gt;&gt;&gt; print len(rows)</div><div class=""> 2</div><div class=""> &gt;&gt;&gt; for row in rows.sort(lambda row: row.name):</div><div class="">         print row.name</div><div class=""> Alex</div><div class=""> John</div><div class=""> ``:code</div><div class=""> </div><div class=""> They can be combined:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows = db(db.person).select()</div><div class=""> &gt;&gt;&gt; rows = rows.find(</div><div class="">         lambda row: &#x27;x&#x27; in row.name).sort(</div><div class="">             lambda row: row.name)</div><div class=""> &gt;&gt;&gt; for row in rows:</div><div class="">         print row.name</div><div class=""> Alex</div><div class=""> Max</div><div class=""> ``:code</div><div class=""> </div><div class="insert">+Sort takes an optional argment ``reverse=True`` which an obvious meaning.</div><div class="insert">+</div><div class=""> The ``find`` method as an optional limitby argument with the same syntax and functionality as the Set select ``method``.</div><div class=""> </div><div class=""> </div><div class=""> </div><div class=""> ### Other methods</div><div class=""> </div><div class=""> #### ``update_or_insert``</div><div class=""> ``update_or_insert``:inxx</div><div class=""> </div><div class=""> Some times you need to perform an insert only if there is no record with the same values as those being inserted.</div><div class=""> This can be done with</div><div class=""> </div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;,Field(&#x27;name&#x27;),Field(&#x27;birthplace&#x27;))</div><div class=""> db.person.update_or_insert(name=&#x27;John&#x27;,birthplace=&#x27;Chicago&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> The record will be inserted only of there is no other user called John born in Chicago.</div><div class=""> </div><div class=""> You can specify which values to use as a key to determine if the record exists. For example:</div><div class=""> Here we will consider the same example as in the previous subsection. In particu</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;item&#x27;,</div><div class="">         Field(&#x27;unit_price&#x27;,&#x27;double&#x27;),</div><div class="">         Field(&#x27;quantity&#x27;,&#x27;integer&#x27;),</div><div class=""> ``:code</div><div class=""> </div><div class=""> One can define a ``total_price`` virtual field as</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.item.total_price = Field.Virtual(lambda row: row.unit_price*row.quantity)</div><div class=""> ``:code</div><div class=""> </div><div class=""> i.e. by simply defining a new field ``total_price`` to be a ``Field.Virtual``. The only argument of the constructor is a function that takes a row and returns the computed values.</div><div class=""> </div><div class=""> A virtual field defined as the one above is automatically computed for all records when the records are selected:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db(db.item).select(): print row.total_price</div><div class=""> ``</div><div class=""> </div><div class="insert">It is also possible to define <span class="highlight">me</span>t<span class="highlight">hod</span> fields which are calculated on-demand, when called.</div><div class=""> For example:</div><div class=""> </div><div class=""> ``</div><div class="insert">&gt;&gt;&gt; db.item.<span class="highlight">discounted_</span>total<span class="highlight"></span> = Field.<span class="highlight">Method</span>(lambda row, discount=0.0: \</div><div class="">        row.unit_price*row.quantity*(1.0-discount/100))</div><div class=""> ``:code</div><div class=""> </div><div class="insert">In this case ``row.<span class="highlight">discounted</span>_<span class="highlight">total`` is not a value but a function. The function takes the same arguments as the function </span>p<span class="highlight">assed to the ``Method</span>`` constructor except for ``row`` which is implicit (think of it as ``self`` for rows objects).</div><div class=""> </div><div class=""> The lazy field in the example above allows one to compute the total price for each ``item``:</div><div class=""> </div><div class=""> ``</div><div class="insert">&gt;&gt;&gt; for row in db(db.item).select(): print row.<span class="highlight">discounted_</span>total<span class="highlight"></span>()</div><div class=""> ``</div><div class=""> </div><div class=""> And it also allows to pass an optional ``discount`` percentage (15%):</div><div class=""> </div><div class=""> ``</div><div class="insert">&gt;&gt;&gt; for row in db(db.item).select(): print row.<span class="highlight">discounted_</span>total<span class="highlight"></span>(15)</div><div class=""> ``</div><div class=""> </div><div class="insert">+Virtual and Method fields can also be defined in place when a table is defined:</div><div class="insert">+</div><div class="insert">+``</div><div class="insert">+&gt;&gt;&gt; db.define_table(&#x27;item&#x27;,</div><div class="insert">+        Field(&#x27;unit_price&#x27;,&#x27;double&#x27;),</div><div class="insert">+        Field(&#x27;quantity&#x27;,&#x27;integer&#x27;),</div><div class="insert">+        Field.Virtual(&#x27;total_price&#x27;, lambda row: ...),</div><div class="insert">+        Field.Method(&#x27;discounted_total&#x27;, lambda row, discount=0.0: ...))</div><div class="insert">+``:code</div><div class="insert">+</div><div class="insert">+</div><div class=""> ------</div><div class=""> Mind that virtual fields do not have the same attributes as the other fields (default, readable, requires, etc) and they do not appear in the list of ``db.table.fields`` and are not visualized by default in tables (TABLE) and grids (SQLFORM.grid, SQLFORM.smartgrid).</div><div class=""> ------</div><div class=""> </div><div class=""> ### One to many relation</div><div class=""> ``one to many``:inxx</div><div class=""> </div><div class=""> To illustrate how to implement one to many relations with the web2py DAL, define another table &quot;thing&quot; that refers to the table &quot;person&quot; which we redefine here:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;,</div><div class="">                     Field(&#x27;name&#x27;),</div><div class="">                     format=&#x27;%(name)s&#x27;)</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;thing&#x27;,</div><div class="">                     Field(&#x27;name&#x27;),</div><div class="">                     Field(&#x27;owner&#x27;, &#x27;reference person&#x27;),</div><div class="">                     format=&#x27;%(name)s&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> Table &quot;thing&quot; has two fields, the name of the thing and the owner of the thing. The &quot;owner&quot; field id a reference field. A reference type can be specified in two equivalent ways:</div><div class=""> </div><div class=""> generated by the DAL.</div><div class=""> #### CSV (one Table at a time)</div><div class=""> </div><div class=""> When a DALRows object is converted to a string it is automatically</div><div class=""> serialized in CSV:</div><div class=""> </div><div class=""> ``csv``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows = db(db.person.id==db.thing.owner).select()</div><div class=""> &gt;&gt;&gt; print rows</div><div class=""> person.id,person.name,thing.id,thing.name,thing.owner</div><div class=""> 1,Alex,1,Boat,1</div><div class=""> 1,Alex,2,Chair,1</div><div class=""> 2,Bob,3,Shoes,2</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can serialize a single table in CSV and store it in a file &quot;test.csv&quot;:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; open(&#x27;test.csv&#x27;, &#x27;w&#x27;).write(str(db(db.person.id).select()))</div><div class=""> ``:code</div><div class=""> </div><div class="insert">+This is equivalent to</div><div class="insert">+</div><div class="insert">+``</div><div class="insert">+&gt;&gt;&gt; rows = db(db.person.id).select()</div><div class="insert">+&gt;&gt;&gt; rows.export_to_csv_file(open(&#x27;test.csv&#x27;, &#x27;w&#x27;))</div><div class="insert">+``:code</div><div class="insert">+</div><div class="insert">+You can read the CSV file back with:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.person.import_from_csv_file(open(&#x27;test.csv&#x27;, &#x27;r&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class=""> When importing, web2py looks for the field names in the CSV header. In this example, it finds two columns: &quot;person.id&quot; and &quot;person.name&quot;. It ignores the &quot;person.&quot; prefix, and it ignores the &quot;id&quot; fields. Then all records are appended and assigned new ids. Both of these operations can be performed via the appadmin web interface.</div><div class=""> </div><div class=""> #### CSV (all tables at once)</div><div class=""> </div><div class=""> In web2py, you can backup/restore an entire database with two commands:</div><div class=""> </div><div class=""> To export:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.export_to_csv_file(open(&#x27;somefile.csv&#x27;, &#x27;wb&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class=""> To import:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.import_from_csv_file(open(&#x27;somefile.csv&#x27;, &#x27;rb&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class=""> If you need to serialize the DALRows in any other XML format with custom tags, y</div><div class="">   ...</div><div class=""> &lt;/result&gt;</div><div class=""> ``:code</div><div class=""> </div><div class=""> #### Data representation</div><div class=""> </div><div class=""> ``export_to_csv_file``:inxx</div><div class=""> The ``export_to_csv_file`` function accepts a keyword argument named ``represent``. When ``True`` it will use the columns ``represent`` function while exporting the data instead of the raw data.</div><div class=""> </div><div class=""> ``colnames``:inxx</div><div class=""> The function also accepts a keyword argument named ``colnames`` that should contain a list of column names one wish to export. It defaults to all columns.</div><div class=""> </div><div class=""> Both ``export_to_csv_file`` and ``import_from_csv_file`` accept keyword arguments that tell the csv parser the format to save/load the files:</div><div class=""> - ``delimiter``: delimiter to separate values (default &#x27;,&#x27;)</div><div class=""> - ``quotechar``: character to use to quote string values (default to double quotes)</div><div class=""> - ``quoting``: quote system (default ``csv.QUOTE_MINIMAL``)</div><div class=""> </div><div class=""> Here is some example usage:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; import csv</div><div class="insert">+&gt;&gt;&gt; rows = db(query).select()</div><div class="insert">+&gt;&gt;&gt; rows.export_to_csv_file(open(&#x27;/tmp/test.txt&#x27;, &#x27;w&#x27;),</div><div class="">         delimiter=&#x27;|&#x27;,</div><div class="">         quotechar=&#x27;&quot;&#x27;,</div><div class="">         quoting=csv.QUOTE_NONNUMERIC)</div><div class=""> ``:code</div></div></div>
    <div class="span6"><div class="diff"><div class=""> ``Expression``:inxx</div><div class=""> **Expression** is something like an ``orderby`` or ``groupby`` expression. The Field class is derived from the Expression. Here is an example.</div><div class=""> ``</div><div class=""> myorder = db.mytable.myfield.upper() | db.mytable.id</div><div class=""> db().select(db.table.ALL, orderby=myorder)</div><div class=""> ``:code</div><div class=""> </div><div class=""> ### Connection strings</div><div class=""> ``connection strings``:inxx</div><div class=""> </div><div class=""> A connection with the database is established by creating an instance of the DAL object:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db = DAL(&#x27;sqlite://storage.db&#x27;, pool_size=0)</div><div class=""> ``:code</div><div class=""> ``db`` is not a keyword; it is a local variable that stores the connection object ``DAL``. You are free to give it a different name. The constructor of ``DAL`` requires a single argument, the connection string. The connection string is the only web2py code that depends on a specific back-end database. Here are examples of connection strings for specific types of supported back-end databases (in all cases, we assume the database is running from localhost on its default port and is named &quot;test&quot;):</div><div class=""> </div><div class=""> -------------</div><div class=""> **SQLite**     | ``sqlite://storage.db``</div><div class=""> **MySQL**      | ``mysql://username:password@localhost/test``</div><div class=""> **PostgreSQL** | ``postgres://username:password@localhost/test``</div><div class=""> **MSSQL**      | ``mssql://username:password@localhost/test``</div><div class=""> which returns a tuple ``(value, error)``. ``error`` is ``None`` if the input pas</div><div class=""> </div><div class=""> We refer to this behavior as a &quot;migration&quot;. web2py logs all migrations and migration attempts in the file &quot;databases/sql.log&quot;.</div><div class=""> </div><div class=""> The first argument of ``define_table`` is always the table name. The other unnamed arguments are the fields (Field). The function also takes an optional last argument called &quot;migrate&quot; which must be referred to explicitly by name as in:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;), migrate=&#x27;person.table&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> The value of migrate is the filename (in the &quot;databases&quot; folder for the application) where web2py stores internal migration information for this table. These files are very important and should never be removed except when the entire database is dropped. In this case, the &quot;.table&quot; files have to be removed manually. By default, migrate is set to True. This causes web2py to generate the filename from a hash of the connection string. If migrate is set to False, the migration is not performed, and web2py assumes that the table exists in the datastore and it contains (at least) the fields listed in ``define_table``.</div><div class=""> The best practice is to give an explicit name to the migrate table.</div><div class=""> </div><div class=""> There may not be two tables in the same application with the same migrate filename.</div><div class=""> </div><div class=""> The DAL class also takes a &quot;migrate&quot; argument, which determines the default value of migrate for calls to ``define_table``. For example,</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db = DAL(&#x27;sqlite://storage.db&#x27;, migrate=False)</div><div class=""> ``:code</div><div class=""> </div><div class=""> will set the default value of migrate to False whenever ``db.define_table`` is called without a migrate argument.</div><div class=""> </div><div class=""> Migrations can be disabled for all tables at the moment of connection:</div><div class=""> </div><div class=""> ``</div><div class=""> db = DAL(...,migrate_enabled=False)</div><div class=""> ``</div><div class=""> </div><div class=""> This is the recommended behavior when two apps share the same database. Only one of the two apps should perform migrations, the other should disabled them.</div><div class=""> </div><div class=""> ### Fixing broken migrations</div><div class=""> ``fake_migrate``:inxx</div><div class=""> </div><div class=""> There are two common problems with migrations and there are ways to recover from them.</div><div class=""> </div><div class=""> One problem is specific with SQLite. SQLite does not enforce column types and cannot drop columns. This means that if you have a column of type string and you remove it, it is not really removed. If you add the column again with a different type (for example datetime) you end up with a datetime column that contains strings (junk for practical purposes). web2py does not complain about this because it does not know what is in the database, until it tries to retrieve records and fails.</div><div class=""> </div><div class=""> If web2py returns an error in the gluon.sql.parse function when selecting records, this is the problem: corrupted data in a column because of the above issue.</div><div class=""> </div><div class=""> The solution consists in updating all records of the table and updating the values in the column in question with None.</div><div class=""> </div><div class=""> The other problem is more generic but typical with MySQL. MySQL does not allow more than one ALTER TABLE in a transaction. This means that web2py must break complex transactions into smaller ones (one ALTER TABLE at the time) and commit one piece at the time. It is therefore possible that part of a complex transaction gets committed and one part fails, leaving web2py in a corrupted state. Why would part of a transaction fail? Because, for example, it involves altering a table and converting a string column into a datetime column, web2py tries to convert the data, but the data cannot be converted. What happens to web2py? It gets confused about what exactly is the table structure actually stored in the database.</div><div class=""> Given a table, you can insert records</div><div class=""> 1</div><div class=""> &gt;&gt;&gt; db.person.insert(name=&quot;Bob&quot;)</div><div class=""> 2</div><div class=""> ``:code</div><div class=""> </div><div class=""> Insert returns the unique &quot;id&quot; value of each record inserted.</div><div class=""> </div><div class=""> You can truncate the table, i.e., delete all records and reset the counter of the id.</div><div class=""> </div><div class=""> ``truncate``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.person.truncate()</div><div class=""> ``:code</div><div class=""> </div><div class=""> Now, if you insert a record again, the counter starts again at 1 (this is back-end specific and does not apply to Google NoSQL):</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.person.insert(name=&quot;Alex&quot;)</div><div class=""> 1</div><div class=""> ``:code</div><div class=""> </div><div class=""> ``bulk_insert``:inxx</div><div class=""> web2py also provides a bulk_insert method</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.person.bulk_insert([{&#x27;name&#x27;:&#x27;Alex&#x27;}, {&#x27;name&#x27;:&#x27;John&#x27;}, {&#x27;name&#x27;:&#x27;Tim&#x27;}])</div><div class=""> [3,4,5]</div><div class=""> ``:code</div><div class=""> </div><div class=""> It takes a list of dictionaries of fields to be inserted and performs multiple inserts at once. It returns the IDs of the inserted records. On the supported relational databases there is no advantage in using this function as opposed to looping and performing individual inserts but on Google App Engine NoSQL, there is a major speed advantage.</div><div class=""> </div><div class=""> ### ``commit`` and ``rollback``</div><div class=""> </div><div class=""> No create, drop, insert, truncate, delete, or update operation is actually committed until you issue the commit command</div><div class=""> </div><div class=""> ``commit``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.commit()</div><div class=""> ``:code</div><div class=""> </div><div class=""> To check it let&#x27;s insert a new record:</div><div class=""> ``</div><div class=""> Here is an example:</div><div class=""> ------</div><div class=""> ``SQLTABLE`` is useful but there are types when one needs more. ``SQLFORM.grid`` is an extension of SQLTABLE that creates a table with search features and pagination, as well as ability to open detailed records, create, edit and delete records. ``SQLFORM.smartgrid`` is a further generalization that allows all of the above but also creates buttons to access referencing records.</div><div class=""> ------</div><div class=""> </div><div class=""> Here is an example of usage of ``SQLFORM.grid``:</div><div class=""> </div><div class=""> ``</div><div class=""> def index():</div><div class="">     return dict(grid=SQLFORM.grid(query))</div><div class=""> ``:code</div><div class=""> </div><div class=""> and the corresponding view:</div><div class=""> </div><div class=""> ``</div><div class=""> {{extend &#x27;layout.html&#x27;}}</div><div class=""> {{=grid}}</div><div class=""> ``</div><div class=""> </div><div class=""> ``SQLFORM.grid`` and ``SQLFORM.smartgrid`` should be preferred to ``SQLTABLE`` because they are more powerful although higher level and therefore more constraining. They will be explained in more detail in chapter 8.</div><div class=""> </div><div class="delete">#### ``orderby``, ``groupby``, ``limitby``, ``distinct``<span class="highlight"></span></div><div class=""> </div><div class=""> The ``select`` command takes five optional arguments: orderby, groupby, limitby, left and cache. Here we discuss the first three.</div><div class=""> </div><div class=""> You can fetch the records sorted by name:</div><div class=""> </div><div class="delete">``orderby``:inxx<span class="highlight"></span></div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db().select(</div><div class="">         db.person.ALL, orderby=db.person.name):</div><div class="">         print row.name</div><div class=""> Alex</div><div class=""> Bob</div><div class=""> Carl</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can fetch the records sorted by name in reverse order (notice the tilde):</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db().select(</div><div class="">         db.person.ALL, orderby=~db.person.name):</div><div class="">         print row.name</div><div class=""> Carl</div><div class=""> Bob</div><div class=""> Alex</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can have the fetched records appear in random order:</div><div class=""> And you can sort the records according to multiple fields by concatenating them</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db().select(</div><div class="">         db.person.ALL, orderby=db.person.name|db.person.id):</div><div class="">         print row.name</div><div class=""> Carl</div><div class=""> Bob</div><div class=""> Alex</div><div class=""> ``:code</div><div class=""> </div><div class=""> Using ``groupby`` together with ``orderby``, you can group records with the same value for the specified field (this is back-end specific, and is not on the Google NoSQL):</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db().select(</div><div class="">         db.person.ALL,</div><div class="">         orderby=db.person.name, groupby=db.person.name):</div><div class="">         print row.name</div><div class=""> Alex</div><div class=""> Bob</div><div class=""> Carl</div><div class=""> ``:code</div><div class=""> </div><div class=""> ``distinct``:inxx</div><div class=""> </div><div class=""> With the argument ``distinct=True``, you can specify that you only want to select distinct records. This has the same effect as grouping using all specified fields except that it does not require sorting. When using distinct it is important not to select ALL fields, and in particular not to select the &quot;id&quot; field, else all records will always be distinct.</div><div class=""> </div><div class=""> Here is an example:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db().select(db.person.name, distinct=True):</div><div class="">         print row.name</div><div class=""> Alex</div><div class=""> Bob</div><div class=""> Carl</div><div class=""> ``:code</div><div class=""> </div><div class=""> Notice that ``distinct`` can also be an expression for example:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db().select(db.person.name,distinct=db.person.name):</div><div class="">         print row.name</div><div class=""> Alex</div><div class=""> Bob</div><div class=""> Carl</div><div class=""> and the binary OR operator &quot;``|``&quot;:</div><div class=""> &gt;&gt;&gt; for row in rows: print row.id, row.name</div><div class=""> 1 Alex</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can negate a query (or sub-query) with the &quot;``!=``&quot; binary operator:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows = db((db.person.name!=&#x27;Alex&#x27;) | (db.person.id&gt;3)).select()</div><div class=""> &gt;&gt;&gt; for row in rows: print row.id, row.name</div><div class=""> 2 Bob</div><div class=""> 3 Carl</div><div class=""> ``:code</div><div class=""> </div><div class=""> or by explicit negation with the &quot;``~``&quot; unary operator:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows = db((~db.person.name==&#x27;Alex&#x27;) | (db.person.id&gt;3)).select()</div><div class=""> &gt;&gt;&gt; for row in rows: print row.id, row.name</div><div class=""> 2 Bob</div><div class=""> 3 Carl</div><div class=""> ``:code</div><div class=""> </div><div class=""> Due to Python restrictions in overloading &quot;``and``&quot; and &quot;``or``&quot; operators, these cannot be used in forming queries.  The binary operators &quot;``&amp;``&quot; and &quot;``|``&quot; must be used instead. Note that these operators (unlike &quot;``and``&quot; and &quot;``or``&quot;) have higher precedence than comparison operators, so the &quot;extra&quot; parentheses in the above examples are mandatory.</div><div class=""> </div><div class=""> It is also possible to build queries using in-place logical operators:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; query = db.person.name!=&#x27;Alex&#x27;</div><div class=""> &gt;&gt;&gt; query &amp;= db.person.id&gt;3</div><div class=""> &gt;&gt;&gt; query |= db.person.name==&#x27;John&#x27;</div><div class=""> ``</div><div class=""> </div><div class=""> #### ``count``, ``isempty``, ``delete``, ``update``</div><div class=""> </div><div class=""> You can count records in a set:</div><div class=""> </div><div class=""> ``count``:inxx ``isempty``:inxx</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; print db(db.person.id &gt; 0).count()</div><div class=""> 3</div><div class=""> ``:code</div><div class=""> </div><div class=""> are equivalent to</div><div class=""> &gt;&gt;&gt; last_row = rows[-1] if len(rows)&gt;0 else None</div><div class=""> ``:code</div><div class=""> </div><div class=""> #### ``as_dict`` and ``as_list``</div><div class=""> ``as_list``:inxx ``as_dict``:inxx</div><div class=""> </div><div class=""> A Row object can be serialized into a regular dictionary using the ``as_dict()`` method and a Rows object can be serialized into a list of dictionaries using the ``as_list()`` method. Here are some examples:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows = db(query).select()</div><div class=""> &gt;&gt;&gt; rows_list = rows.as_list()</div><div class=""> &gt;&gt;&gt; first_row_dict = rows.first().as_dict()</div><div class=""> ``:code</div><div class=""> </div><div class=""> These methods are convenient for passing Rows to generic views and or to store Rows in sessions (since Rows objects themselves cannot be serialized since contain a reference to an open DB connection):</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows = db(query).select()</div><div class=""> &gt;&gt;&gt; session.rows = rows # not allowed!</div><div class=""> &gt;&gt;&gt; session.rows = rows.as_list() # allowed!</div><div class=""> ``:code</div><div class=""> </div><div class=""> #### ``find``, ``exclude``, ``sort``</div><div class=""> ``find``:inxx ``exclude``:inxx ``sort``:inxx</div><div class=""> </div><div class=""> There are times when one needs to perform two selects and one contains a subset of a previous select. In this case it is pointless to access the database again. The ``find``, ``exclude`` and ``sort`` objects allow you to manipulate a Rows objects and generate another one without accessing the database. More specifically:</div><div class=""> - ``find`` returns a new set of Rows filtered by a condition and leaves the original unchanged.</div><div class=""> - ``exclude`` returns a new set of Rows filtered by a condition and removes them from the original Rows.</div><div class=""> - ``sort`` returns a new set of Rows sorted by a condition and leaves the original unchanged.</div><div class=""> </div><div class=""> All these methods take a single argument, a function that acts on each individual row.</div><div class=""> </div><div class=""> Here is an example of usage:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;,Field(&#x27;name&#x27;))</div><div class=""> &gt;&gt;&gt; db.person.insert(name=&#x27;John&#x27;)</div><div class=""> &gt;&gt;&gt; db.person.insert(name=&#x27;Max&#x27;)</div><div class=""> &gt;&gt;&gt; db.person.insert(name=&#x27;Alex&#x27;)</div><div class=""> &gt;&gt;&gt; rows = db(db.person).select()</div><div class=""> &gt;&gt;&gt; for row in rows.find(lambda row: row.name[0]==&#x27;M&#x27;):</div><div class="">         print row.name</div><div class=""> Max</div><div class=""> Max</div><div class=""> &gt;&gt;&gt; print len(rows)</div><div class=""> 2</div><div class=""> &gt;&gt;&gt; for row in rows.sort(lambda row: row.name):</div><div class="">         print row.name</div><div class=""> Alex</div><div class=""> John</div><div class=""> ``:code</div><div class=""> </div><div class=""> They can be combined:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows = db(db.person).select()</div><div class=""> &gt;&gt;&gt; rows = rows.find(</div><div class="">         lambda row: &#x27;x&#x27; in row.name).sort(</div><div class="">             lambda row: row.name)</div><div class=""> &gt;&gt;&gt; for row in rows:</div><div class="">         print row.name</div><div class=""> Alex</div><div class=""> Max</div><div class=""> ``:code</div><div class=""> </div><div class=""> The ``find`` method as an optional limitby argument with the same syntax and functionality as the Set select ``method``.</div><div class=""> </div><div class=""> </div><div class=""> </div><div class=""> ### Other methods</div><div class=""> </div><div class=""> #### ``update_or_insert``</div><div class=""> ``update_or_insert``:inxx</div><div class=""> </div><div class=""> Some times you need to perform an insert only if there is no record with the same values as those being inserted.</div><div class=""> This can be done with</div><div class=""> </div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;,Field(&#x27;name&#x27;),Field(&#x27;birthplace&#x27;))</div><div class=""> db.person.update_or_insert(name=&#x27;John&#x27;,birthplace=&#x27;Chicago&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> The record will be inserted only of there is no other user called John born in Chicago.</div><div class=""> </div><div class=""> You can specify which values to use as a key to determine if the record exists. For example:</div><div class=""> Here we will consider the same example as in the previous subsection. In particu</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;item&#x27;,</div><div class="">         Field(&#x27;unit_price&#x27;,&#x27;double&#x27;),</div><div class="">         Field(&#x27;quantity&#x27;,&#x27;integer&#x27;),</div><div class=""> ``:code</div><div class=""> </div><div class=""> One can define a ``total_price`` virtual field as</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.item.total_price = Field.Virtual(lambda row: row.unit_price*row.quantity)</div><div class=""> ``:code</div><div class=""> </div><div class=""> i.e. by simply defining a new field ``total_price`` to be a ``Field.Virtual``. The only argument of the constructor is a function that takes a row and returns the computed values.</div><div class=""> </div><div class=""> A virtual field defined as the one above is automatically computed for all records when the records are selected:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db(db.item).select(): print row.total_price</div><div class=""> ``</div><div class=""> </div><div class="delete">It is also possible to define <span class="highlight">lazy vir</span>t<span class="highlight">ual</span> fields which are calculated on-demand, when called.</div><div class=""> For example:</div><div class=""> </div><div class=""> ``</div><div class="delete">&gt;&gt;&gt; db.item.<span class="highlight"></span>total<span class="highlight">_price</span> = Field.<span class="highlight">Lazy</span>(lambda row, discount=0.0: \</div><div class="">        row.unit_price*row.quantity*(1.0-discount/100))</div><div class=""> ``:code</div><div class=""> </div><div class="delete">In this case ``row.<span class="highlight">total</span>_<span class="highlight"></span>p<span class="highlight">rice`` is not a value but a function. The function takes the same arguments as the function passed to the ``Lazy</span>`` constructor except for ``row`` which is implicit (think of it as ``self`` for rows objects).</div><div class=""> </div><div class=""> The lazy field in the example above allows one to compute the total price for each ``item``:</div><div class=""> </div><div class=""> ``</div><div class="delete">&gt;&gt;&gt; for row in db(db.item).select(): print row.<span class="highlight"></span>total<span class="highlight">_price</span>()</div><div class=""> ``</div><div class=""> </div><div class=""> And it also allows to pass an optional ``discount`` percentage (15%):</div><div class=""> </div><div class=""> ``</div><div class="delete">&gt;&gt;&gt; for row in db(db.item).select(): print row.<span class="highlight"></span>total<span class="highlight">_price</span>(15)</div><div class=""> ``</div><div class=""> </div><div class=""> ------</div><div class=""> Mind that virtual fields do not have the same attributes as the other fields (default, readable, requires, etc) and they do not appear in the list of ``db.table.fields`` and are not visualized by default in tables (TABLE) and grids (SQLFORM.grid, SQLFORM.smartgrid).</div><div class=""> ------</div><div class=""> </div><div class=""> ### One to many relation</div><div class=""> ``one to many``:inxx</div><div class=""> </div><div class=""> To illustrate how to implement one to many relations with the web2py DAL, define another table &quot;thing&quot; that refers to the table &quot;person&quot; which we redefine here:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;,</div><div class="">                     Field(&#x27;name&#x27;),</div><div class="">                     format=&#x27;%(name)s&#x27;)</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;thing&#x27;,</div><div class="">                     Field(&#x27;name&#x27;),</div><div class="">                     Field(&#x27;owner&#x27;, &#x27;reference person&#x27;),</div><div class="">                     format=&#x27;%(name)s&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> Table &quot;thing&quot; has two fields, the name of the thing and the owner of the thing. The &quot;owner&quot; field id a reference field. A reference type can be specified in two equivalent ways:</div><div class=""> </div><div class=""> generated by the DAL.</div><div class=""> #### CSV (one Table at a time)</div><div class=""> </div><div class=""> When a DALRows object is converted to a string it is automatically</div><div class=""> serialized in CSV:</div><div class=""> </div><div class=""> ``csv``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows = db(db.person.id==db.thing.owner).select()</div><div class=""> &gt;&gt;&gt; print rows</div><div class=""> person.id,person.name,thing.id,thing.name,thing.owner</div><div class=""> 1,Alex,1,Boat,1</div><div class=""> 1,Alex,2,Chair,1</div><div class=""> 2,Bob,3,Shoes,2</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can serialize a single table in CSV and store it in a file &quot;test.csv&quot;:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; open(&#x27;test.csv&#x27;, &#x27;w&#x27;).write(str(db(db.person.id).select()))</div><div class=""> ``:code</div><div class=""> </div><div class="delete">-and you can easily read it back with:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.person.import_from_csv_file(open(&#x27;test.csv&#x27;, &#x27;r&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class=""> When importing, web2py looks for the field names in the CSV header. In this example, it finds two columns: &quot;person.id&quot; and &quot;person.name&quot;. It ignores the &quot;person.&quot; prefix, and it ignores the &quot;id&quot; fields. Then all records are appended and assigned new ids. Both of these operations can be performed via the appadmin web interface.</div><div class=""> </div><div class=""> #### CSV (all tables at once)</div><div class=""> </div><div class=""> In web2py, you can backup/restore an entire database with two commands:</div><div class=""> </div><div class=""> To export:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.export_to_csv_file(open(&#x27;somefile.csv&#x27;, &#x27;wb&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class=""> To import:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.import_from_csv_file(open(&#x27;somefile.csv&#x27;, &#x27;rb&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class=""> If you need to serialize the DALRows in any other XML format with custom tags, y</div><div class="">   ...</div><div class=""> &lt;/result&gt;</div><div class=""> ``:code</div><div class=""> </div><div class=""> #### Data representation</div><div class=""> </div><div class=""> ``export_to_csv_file``:inxx</div><div class=""> The ``export_to_csv_file`` function accepts a keyword argument named ``represent``. When ``True`` it will use the columns ``represent`` function while exporting the data instead of the raw data.</div><div class=""> </div><div class=""> ``colnames``:inxx</div><div class=""> The function also accepts a keyword argument named ``colnames`` that should contain a list of column names one wish to export. It defaults to all columns.</div><div class=""> </div><div class=""> Both ``export_to_csv_file`` and ``import_from_csv_file`` accept keyword arguments that tell the csv parser the format to save/load the files:</div><div class=""> - ``delimiter``: delimiter to separate values (default &#x27;,&#x27;)</div><div class=""> - ``quotechar``: character to use to quote string values (default to double quotes)</div><div class=""> - ``quoting``: quote system (default ``csv.QUOTE_MINIMAL``)</div><div class=""> </div><div class=""> Here is some example usage:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; import csv</div><div class="delete">-&gt;&gt;&gt; db.export_to_csv_file(open(&#x27;/tmp/test.txt&#x27;, &#x27;w&#x27;),</div><div class="">         delimiter=&#x27;|&#x27;,</div><div class="">         quotechar=&#x27;&quot;&#x27;,</div><div class="">         quoting=csv.QUOTE_NONNUMERIC)</div><div class=""> ``:code</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/b0baf2e1e67f2011176a7cdd13861bb2c7504551">b0baf2e</a><ul><li>Date : 2012-11-12</li><li>Document conditions for update_record to be available</li></ul></li></ul>
<div class="row-fluid" id="com_b0baf2e1e67f2011176a7cdd13861bb2c7504551">
    <div class="span6"><div class="diff"><div class="insert">+The ``update_record`` method is available only if the table&#x27;s ``id`` field is included in the select, and ``cacheable`` is not set to ``True``.</div><div class="insert">+</div><div class=""> #### ``first`` and ``last``</div><div class=""> ``first``:inxx ``last``:inxx</div></div></div>
    <div class="span6"><div class="diff"><div class=""> #### ``first`` and ``last``</div><div class=""> ``first``:inxx ``last``:inxx</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/4d53788f2d863d91713a5f41b0bb589d6fd18162">4d53788</a><ul><li>Date : 2012-11-11</li><li>trivial wording fix</li></ul></li></ul>
<div class="row-fluid" id="com_4d53788f2d863d91713a5f41b0bb589d6fd18162">
    <div class="span6"><div class="diff"><div class="insert">It is also possible to change the attributes of a row (one at <span class="highlight">a</span> time) and then call ``update_record()`` without arguments to save the changes:</div></div></div>
    <div class="span6"><div class="diff"><div class="delete">It is also possible to change the attributes of a row (one at <span class="highlight">the</span> time) and then call ``update_record()`` without arguments to save the changes:</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/b1e25b8418671e7607065dd8a0b7dbddf306791a">b1e25b8</a><ul><li>Date : 2012-09-15</li><li>Update sources/29-web2py-english/06.markmin</li></ul></li></ul>
<div class="row-fluid" id="com_b1e25b8418671e7607065dd8a0b7dbddf306791a">
    <div class="span6"><div class="diff"><div class="insert">``sqlite3``, ``pymysql``, ``pg8000``, and ``imaplib`` ship with web2py. Support of MongoDB is experimental. The IMAP option allows to use DAL to access I<span class="highlight">M</span>A<span class="highlight"></span>P.</div></div></div>
    <div class="span6"><div class="diff"><div class="delete">``sqlite3``, ``pymysql``, ``pg8000``, and ``imaplib`` ship with web2py. Support of MongoDB is experimental. The IMAP option allows to use DAL to access I<span class="highlight"></span>A<span class="highlight">M</span>P.</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/11e58b1472eca0f2d66fa2b9bc3bef1cad1981f7">11e58b1</a><ul><li>Date : 2012-09-08</li><li>fixed some errors</li></ul></li></ul>
<div class="row-fluid" id="com_11e58b1472eca0f2d66fa2b9bc3bef1cad1981f7">
    <div class="span6"><div class="diff"><div class=""> Consider the previous table person and a new table &quot;thing&quot; referencing a &quot;person&quot;:</div><div class=""> ``</div><div class="insert">+&gt;&gt;&gt; db.define_table(&#x27;thing&#x27;, </div><div class="insert">+        Field(&#x27;name&#x27;), </div><div class="insert">+        Field(&#x27;owner&#x27;,&#x27;reference person&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class=""> and a simple select from this table:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; things = db(db.thing).select()</div><div class=""> ``:code</div><div class=""> </div><div class=""> which is equivalent to</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; things = db(db.thing._id&gt;0).select()</div><div class=""> ``:code</div><div class=""> </div><div class=""> where ``._id`` is a reference to the primary key of the table. Normally ``db.thing._id`` is the same as ``db.thing.id`` and we will assume that in most of this book. ``_id``:inxx</div><div class=""> </div><div class=""> </div><div class=""> For each Row of things it is possible to fetch not just fields from the selected table (thing) but also from linked tables (recursively):</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for thing in things: print thing.name, thing.owner.name</div><div class=""> ``:code</div><div class=""> And it also allows to pass an optional ``discount`` percentage (15%):</div><div class=""> ``</div><div class=""> </div><div class=""> ------</div><div class=""> Mind that virtual fields do not have the same attributes as the other fields (default, readable, requires, etc) and they do not appear in the list of ``db.table.fields`` and are not visualized by default in tables (TABLE) and grids (SQLFORM.grid, SQLFORM.smartgrid).</div><div class=""> ------</div><div class=""> </div><div class=""> ### One to many relation</div><div class=""> ``one to many``:inxx</div><div class=""> </div><div class=""> To illustrate how to implement one to many relations with the web2py DAL, define another table &quot;thing&quot; that refers to the table &quot;person&quot; which we redefine here:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;,</div><div class="">                     Field(&#x27;name&#x27;),</div><div class="">                     format=&#x27;%(name)s&#x27;)</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;thing&#x27;,</div><div class="">                     Field(&#x27;name&#x27;),</div><div class="">                     Field(&#x27;owner&#x27;, &#x27;reference person&#x27;),</div><div class="">                     format=&#x27;%(name)s&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class="insert">+Table &quot;thing&quot; has two fields, the name of the thing and the owner of the thing. The &quot;owner&quot; field id a reference field. A reference type can be specified in two equivalent ways:</div><div class="insert">+</div><div class="insert">+``</div><div class="insert">+Field(&#x27;owner&#x27;, &#x27;reference person&#x27;)</div><div class="insert">+Field(&#x27;owner&#x27;, db.person)</div><div class="insert">+``:code</div><div class="insert">+</div><div class="insert">+The latter is always converted to the former. They are equivalent except in the case of lazy tables, self references or other types of cyclic references where the former notation is the only allowed notation.</div><div class="insert">+</div><div class="insert">+When a field type is another table, it is intended that the field reference the other table by its id. In fact, you can print the actual type value and get:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; print db.thing.owner.type</div><div class=""> reference person</div><div class=""> ``:code</div><div class=""> </div><div class=""> Now, insert three things, two owned by Alex and one by Bob:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.thing.insert(name=&#x27;Boat&#x27;, owner=1)</div><div class=""> 1</div><div class=""> &gt;&gt;&gt; db.thing.insert(name=&#x27;Chair&#x27;, owner=1)</div><div class=""> 2</div><div class=""> &gt;&gt;&gt; db.thing.insert(name=&#x27;Shoes&#x27;, owner=2)</div><div class=""> 3</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can select as you did for any other table:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db(db.thing.owner==1).select():</div><div class="">         print row.name</div><div class=""> Boat</div><div class=""> Which would render something similar to</div><div class=""> &quot;hello&quot;|35|&quot;this is the text description&quot;|&quot;2009-03-03&quot;</div><div class=""> ``:code</div><div class=""> </div><div class=""> For more information consult the official Python documentation ``quoteall``:cite</div><div class=""> </div><div class=""> ### Caching selects</div><div class=""> </div><div class=""> The select method also takes a cache argument, which defaults to None. For caching purposes, it should be set to a tuple where the first element is the cache model (cache.ram, cache.disk, etc.), and the second element is the expiration time in seconds.</div><div class=""> </div><div class=""> In the following example, you see a controller that caches a select on the previously defined db.log table. The actual select fetches data from the back-end database no more frequently than once every 60 seconds and stores the result in cache.ram. If the next call to this controller occurs in less than 60 seconds since the last database IO, it simply fetches the previous data from cache.ram.</div><div class=""> </div><div class=""> ``cache select``:inxx </div><div class=""> ``</div><div class=""> def cache_db_select():</div><div class="">     logs = db().select(db.log.ALL, cache=(cache.ram, 60))</div><div class="">     return dict(logs=logs)</div><div class=""> ``:code</div><div class=""> </div><div class=""> ``cacheable``:inxx</div><div class=""> </div><div class="insert">The ``select`` method has an optional ``cacheable`` argument, normally set to ``False``. When <span class="highlight">``cacheable=</span>True``<span class="highlight"> the resulting ``Rows`` is serializable but The ``Row``s lack ``update_record`` and ``delete_record`` methods</span>.<span class="highlight"></span></div><div class=""> </div><div class="insert">If you do not need these methods you can speed up selects <span class="highlight">a</span> <span class="highlight">l</span>ot<span class="highlight"></span> by setting the cacheable attribute:</div><div class=""> </div><div class=""> ``</div><div class=""> rows = db(query).select(cacheable=True)</div><div class=""> ``:code</div><div class=""> </div><div class=""> -------</div><div class=""> The results of a ``select`` are normally complex, un-pickleable objects; they cannot be stored in a session and cannot be cached in any other way than the one explained here unless the ``cache`` attribute is set or ``cacheable=True``.</div><div class=""> -------</div><div class=""> </div><div class="insert">+When the ``cache`` argument is set but ``cacheable=False`` (default) only the database results are cached, not the actual Rows object. When the ``cache`` argument is used in conjuction with ``cacheable=True`` the entire Rows object is cached and this results in much baster caching:</div><div class="insert">+</div><div class="insert">+``</div><div class="insert">+rows = db(query).select(cache=(cache.ram,3600),cacheable=True)</div><div class="insert">+``:code</div><div class="insert">+</div><div class=""> ### Self-Reference and aliases</div><div class=""> </div><div class=""> ``self reference``:inxx</div><div class=""> ``alias``:inxx</div><div class="insert">+It is possible to define tables with fields that refer to themselves, here is an example:</div><div class="insert">+``reference table``:inxx</div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;,</div><div class="">     Field(&#x27;name&#x27;),</div><div class="">     Field(&#x27;father_id&#x27;, &#x27;reference person&#x27;),</div><div class="">     Field(&#x27;mother_id&#x27;, &#x27;reference person&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class="insert"><span class="highlight">Notic</span>e<span class="highlight"> that the alt</span>er<span class="highlight">antiv</span>e<span class="highlight"> </span>n<span class="highlight">otation of using a</span> table<span class="highlight"> object as field type will fail in this case, because it uses a variable </span>``<span class="highlight">db.person`` before it is def</span>in<span class="highlight">ed:</span></div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;,</div><div class="">     Field(&#x27;name&#x27;),</div><div class="insert">+    Field(&#x27;father_id&#x27;, db.person), # wrong!</div><div class="insert">+    Field(&#x27;mother_id&#x27;, db.person)) # wrong!</div><div class=""> ``:code</div><div class=""> </div><div class="insert">In <span class="highlight">gener</span>a<span class="highlight">l</span> ``db.tablename`` and ``&quot;reference tablename&quot;`` are equivalent field types<span class="highlight">, but the latter is the only one allowed for self</span>.<span class="highlight">references.</span></div></div></div>
    <div class="span6"><div class="diff"><div class=""> Consider the previous table person and a new table &quot;thing&quot; referencing a &quot;person&quot;:</div><div class=""> ``</div><div class="delete">-&gt;&gt;&gt; db.define_table(&#x27;thing&#x27;, Field(&#x27;name&#x27;), Field(&#x27;owner&#x27;,&#x27;reference person&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class=""> and a simple select from this table:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; things = db(db.thing).select()</div><div class=""> ``:code</div><div class=""> </div><div class=""> which is equivalent to</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; things = db(db.thing._id&gt;0).select()</div><div class=""> ``:code</div><div class=""> </div><div class=""> where ``._id`` is a reference to the primary key of the table. Normally ``db.thing._id`` is the same as ``db.thing.id`` and we will assume that in most of this book. ``_id``:inxx</div><div class=""> </div><div class=""> </div><div class=""> For each Row of things it is possible to fetch not just fields from the selected table (thing) but also from linked tables (recursively):</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for thing in things: print thing.name, thing.owner.name</div><div class=""> ``:code</div><div class=""> And it also allows to pass an optional ``discount`` percentage (15%):</div><div class=""> ``</div><div class=""> </div><div class=""> ------</div><div class=""> Mind that virtual fields do not have the same attributes as the other fields (default, readable, requires, etc) and they do not appear in the list of ``db.table.fields`` and are not visualized by default in tables (TABLE) and grids (SQLFORM.grid, SQLFORM.smartgrid).</div><div class=""> ------</div><div class=""> </div><div class=""> ### One to many relation</div><div class=""> ``one to many``:inxx</div><div class=""> </div><div class=""> To illustrate how to implement one to many relations with the web2py DAL, define another table &quot;thing&quot; that refers to the table &quot;person&quot; which we redefine here:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;,</div><div class="">                     Field(&#x27;name&#x27;),</div><div class="">                     format=&#x27;%(name)s&#x27;)</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;thing&#x27;,</div><div class="">                     Field(&#x27;name&#x27;),</div><div class="">                     Field(&#x27;owner&#x27;, &#x27;reference person&#x27;),</div><div class="">                     format=&#x27;%(name)s&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class="delete">-Table &quot;thing&quot; has two fields, the name of the thing and the owner of the thing. When a field type is another table, it is intended that the field reference the other table by its id. In fact, you can print the actual type value and get:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; print db.thing.owner.type</div><div class=""> reference person</div><div class=""> ``:code</div><div class=""> </div><div class=""> Now, insert three things, two owned by Alex and one by Bob:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.thing.insert(name=&#x27;Boat&#x27;, owner=1)</div><div class=""> 1</div><div class=""> &gt;&gt;&gt; db.thing.insert(name=&#x27;Chair&#x27;, owner=1)</div><div class=""> 2</div><div class=""> &gt;&gt;&gt; db.thing.insert(name=&#x27;Shoes&#x27;, owner=2)</div><div class=""> 3</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can select as you did for any other table:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db(db.thing.owner==1).select():</div><div class="">         print row.name</div><div class=""> Boat</div><div class=""> Which would render something similar to</div><div class=""> &quot;hello&quot;|35|&quot;this is the text description&quot;|&quot;2009-03-03&quot;</div><div class=""> ``:code</div><div class=""> </div><div class=""> For more information consult the official Python documentation ``quoteall``:cite</div><div class=""> </div><div class=""> ### Caching selects</div><div class=""> </div><div class=""> The select method also takes a cache argument, which defaults to None. For caching purposes, it should be set to a tuple where the first element is the cache model (cache.ram, cache.disk, etc.), and the second element is the expiration time in seconds.</div><div class=""> </div><div class=""> In the following example, you see a controller that caches a select on the previously defined db.log table. The actual select fetches data from the back-end database no more frequently than once every 60 seconds and stores the result in cache.ram. If the next call to this controller occurs in less than 60 seconds since the last database IO, it simply fetches the previous data from cache.ram.</div><div class=""> </div><div class=""> ``cache select``:inxx </div><div class=""> ``</div><div class=""> def cache_db_select():</div><div class="">     logs = db().select(db.log.ALL, cache=(cache.ram, 60))</div><div class="">     return dict(logs=logs)</div><div class=""> ``:code</div><div class=""> </div><div class=""> ``cacheable``:inxx</div><div class=""> </div><div class="delete">The ``select`` method has an optional ``cacheable`` argument, normally set to ``False``. When <span class="highlight">a select is cached, ``cacheable`` is set to ``</span>True``<span class="highlight"></span>.<span class="highlight"> This makes a simple ``Rows`` result which is serializable but The ``Row``s lack ``update_record`` and ``delete_record`` methods.</span></div><div class=""> </div><div class="delete">If you do not need these methods you can speed up selects <span class="highlight">even</span> <span class="highlight">if you do n</span>ot<span class="highlight"> plan to cache then</span> by setting the cacheable attribute:</div><div class=""> </div><div class=""> ``</div><div class=""> rows = db(query).select(cacheable=True)</div><div class=""> ``:code</div><div class=""> </div><div class=""> -------</div><div class=""> The results of a ``select`` are normally complex, un-pickleable objects; they cannot be stored in a session and cannot be cached in any other way than the one explained here unless the ``cache`` attribute is set or ``cacheable=True``.</div><div class=""> -------</div><div class=""> </div><div class=""> ### Self-Reference and aliases</div><div class=""> </div><div class=""> ``self reference``:inxx</div><div class=""> ``alias``:inxx</div><div class="delete">-It is possible to define tables with fields that refer to themselves although the usual notation may fail. The following code would be wrong because it uses a variable ``db.person`` before it is defined:</div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;,</div><div class="">     Field(&#x27;name&#x27;),</div><div class="">     Field(&#x27;father_id&#x27;, &#x27;reference person&#x27;),</div><div class="">     Field(&#x27;mother_id&#x27;, &#x27;reference person&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class="delete">-The solution consists of using an alternate notation</div><div class="delete"><span class="highlight">``r</span>e<span class="highlight">f</span>er<span class="highlight"></span>e<span class="highlight"></span>n<span class="highlight">ce</span> table<span class="highlight"></span>``<span class="highlight">:</span>in<span class="highlight">xx</span></div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;,</div><div class="">     Field(&#x27;name&#x27;),</div><div class="delete">-    Field(&#x27;father_id&#x27;, &#x27;reference person&#x27;),</div><div class="delete">-    Field(&#x27;mother_id&#x27;, &#x27;reference person&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class="delete">In <span class="highlight">f</span>a<span class="highlight">ct</span> ``db.tablename`` and ``&quot;reference tablename&quot;`` are equivalent field types<span class="highlight"></span>.<span class="highlight"></span></div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/c0da1a23055a3368a1a4b20f5e90fcd6ef18f4f8">c0da1a2</a><ul><li>Date : 2012-09-06</li><li>fix more typos</li></ul></li></ul>
<div class="row-fluid" id="com_c0da1a23055a3368a1a4b20f5e90fcd6ef18f4f8">
    <div class="span6"><div class="diff"><div class="insert">The ``big-id`` and, ``big-reference`` are only supported by some of the database engines and are experimental. They are not normally used as field types unless for legacy tables, however, the DAL constructor has a ``bigint_id`` argument that when set to ``True`` makes the ``id`` fields and ``reference`` fields ``big-id`` and ``big-refere<span class="highlight">n</span>ce`` respectively.</div><div class=""> </div><div class=""> The ``list:`` fields are special because they are designed to take advantage of certain denormalization features on NoSQL (in the case of Google App Engine NoSQL, the field types ``ListProperty`` and ``StringListProperty``) and back-port them all the other supported relational databases. On relational databases lists are stored as a ``text`` field. The items are separated by a ``|`` and each ``|`` in string item is escaped as a ``||``. They are discussed in their own section.</div><div class=""> </div><div class=""> -------</div><div class=""> Notice that ``requires=...`` is enforced at the level of forms, ``required=True`` is enforced at the level of the DAL (insert), while ``notnull``, ``unique`` and ``ondelete`` are enforced at the level of the database. While they sometimes may seem redundant, it is important to maintain the distinction when programming with the DAL.</div><div class=""> -------</div><div class=""> </div><div class=""> ``ondelete``:inxx</div><div class=""> </div><div class=""> - ``ondelete`` translates into the &quot;ON DELETE&quot; SQL statement. By default it is set to &quot;CASCADE&quot;. This tells the database that when it deletes a record, it should also delete all records that refer to it. To disable this feature, set ``ondelete`` to &quot;NO ACTION&quot; or &quot;SET NULL&quot;.</div><div class=""> - ``notnull=True`` translates into the &quot;NOT NULL&quot; SQL statement. It prevents the database from inserting null values for the field.</div><div class=""> - ``unique=True`` translates into the &quot;UNIQUE&quot; SQL statement and it makes sure that values of this field are unique within the table. It is enforced at the database level.</div><div class=""> - ``uploadfield`` applies only to fields of type &quot;upload&quot;. A field of type &quot;upload&quot; stores the name of a file saved somewhere else, by default on the filesystem under the application &quot;uploads/&quot; folder. If ``uploadfield`` is set, then the file is stored in a blob field within the same table and the value of ``uploadfield`` is the name of the blob field. This will be discussed in more detail later in the context of SQLFORM.</div><div class=""> - ``uploadfolder`` defaults to the application&#x27;s &quot;uploads/&quot; folder. If set to a different path, files will uploaded to a different folder. For example, uploadfolder=os.path.join(request.folder,&#x27;static/temp&#x27;) will upload files to the web2py/applications/myapp/static/temp folder.</div><div class=""> - ``uploadseparate`` if set to True will upload files under different subfolders of the &#x27;&#x27;uploadfolder&#x27;&#x27; folder. This is optimized to avoid too many files under the same folder/subfolder. ATTENTION: You cannot change the value of ``uploadseparate`` from True to False without breaking the system. web2py either uses the separate subfolders or it does not. Changing the behavior after files have been uploaded will prevent web2py from being able to retrieve those files. If this happens it is possible to move files and fix the problem but this is not described here.</div><div class=""> - ``uploadfs`` allows you specify a different filessystem where to upload files, including an Amazon S3 storage or a remote FTP storage. This option requires PyFileSystem installed. ``uploadfs`` must point to ``PyFileSystem``. ``PyFileSystem``:inxx ``uploadfs``:idxx</div><div class=""> - ``widget`` must be one of the available widget objects, including custom widgets, for example: ``SQLFORM.widgets.string.widget``. A list of available widgets will be discussed later. Each field type has a default widget.</div><div class=""> - ``label`` is a string (or something that can be serialized to a string) that contains the label to be used for this field in autogenerated forms.</div><div class=""> - ``comment``  is a string (or something that can be serialized to a string) that contains a comment associated with this field, and will be displayed to the right of the input field in the autogenerated forms.</div><div class=""> - ``writable`` if a field is writable, it can be edited in autogenerated create and update forms.</div><div class=""> The first argument of ``define_table`` is always the table name. The other unnam</div><div class=""> ``:code</div><div class=""> </div><div class=""> The value of migrate is the filename (in the &quot;databases&quot; folder for the application) where web2py stores internal migration information for this table. These files are very important and should never be removed except when the entire database is dropped. In this case, the &quot;.table&quot; files have to be removed manually. By default, migrate is set to True. This causes web2py to generate the filename from a hash of the connection string. If migrate is set to False, the migration is not performed, and web2py assumes that the table exists in the datastore and it contains (at least) the fields listed in ``define_table``.</div><div class=""> The best practice is to give an explicit name to the migrate table.</div><div class=""> </div><div class=""> There may not be two tables in the same application with the same migrate filename.</div><div class=""> </div><div class=""> The DAL class also takes a &quot;migrate&quot; argument, which determines the default value of migrate for calls to ``define_table``. For example,</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db = DAL(&#x27;sqlite://storage.db&#x27;, migrate=False)</div><div class=""> ``:code</div><div class=""> </div><div class=""> will set the default value of migrate to False whenever ``db.define_table`` is called without a migrate argument.</div><div class=""> </div><div class=""> Migrations can be disabled for all tables at the moment of connection:</div><div class=""> </div><div class=""> ``</div><div class=""> db = DAL(...,migrate_enabled=False)</div><div class=""> ``</div><div class=""> </div><div class="insert">This is the recommended behavio<span class="highlight"></span>r when two apps share the same database. Only one of the two apps should perform migrations, the other should disabled them.</div><div class=""> </div><div class=""> ### Fixing broken migrations</div><div class=""> ``fake_migrate``:inxx</div><div class=""> </div><div class=""> There are two common problems with migrations and there are ways to recover from them.</div><div class=""> </div><div class=""> One problem is specific with SQLite. SQLite does not enforce column types and cannot drop columns. This means that if you have a column of type string and you remove it, it is not really removed. If you add the column again with a different type (for example datetime) you end up with a datetime column that contains strings (junk for practical purposes). web2py does not complain about this because it does not know what is in the database, until it tries to retrieve records and fails.</div><div class=""> </div><div class=""> If web2py returns an error in the gluon.sql.parse function when selecting records, this is the problem: corrupted data in a column because of the above issue.</div><div class=""> </div><div class=""> The solution consists in updating all records of the table and updating the values in the column in question with None.</div><div class=""> </div><div class=""> The other problem is more generic but typical with MySQL. MySQL does not allow more than one ALTER TABLE in a transaction. This means that web2py must break complex transactions into smaller ones (one ALTER TABLE at the time) and commit one piece at the time. It is therefore possible that part of a complex transaction gets committed and one part fails, leaving web2py in a corrupted state. Why would part of a transaction fail? Because, for example, it involves altering a table and converting a string column into a datetime column, web2py tries to convert the data, but the data cannot be converted. What happens to web2py? It gets confused about what exactly is the table structure actually stored in the database.</div><div class=""> </div><div class=""> The solution consists of disabling migrations for all tables and enabling fake migrations:</div><div class=""> ``</div><div class=""> db.define_table(....,migrate=False,fake_migrate=True)</div><div class=""> ``:code</div><div class=""> </div><div class=""> This will rebuild web2py metadata about the table according to the table definition. Try multiple table definitions to see which one works (the one before the failed migration and the one after the failed migration). Once successful remove the ``fake_migrate=True`` attribute.</div><div class=""> The DAL allows you to explicitly issue SQL statements.</div><div class=""> &gt;&gt;&gt; print db.executesql(&#x27;SELECT * FROM person;&#x27;)</div><div class=""> [(1, u&#x27;Massimo&#x27;), (2, u&#x27;Massimo&#x27;)]</div><div class=""> ``:code</div><div class=""> </div><div class=""> In this case, the return values are not parsed or transformed by the DAL, and the format depends on the specific database driver. This usage with selects is normally not needed, but it is more common with indexes.</div><div class=""> ``executesql`` takes two optional arguments: ``placeholders`` and ``as_dict``</div><div class=""> ``placeholders`` is an optional</div><div class=""> sequence of values to be substituted in</div><div class=""> or, if supported by the DB driver, a dictionary with keys</div><div class=""> matching named placeholders in your SQL.</div><div class=""> </div><div class=""> If ``as_dict`` is set to True,</div><div class=""> and the results cursor returned by the DB driver will be</div><div class=""> converted to a sequence of dictionaries keyed with the db</div><div class=""> field names.  Results returned with ``as_dict = True ``are</div><div class=""> the same as those returned when applying **.as_list()** to a normal select.</div><div class=""> ``</div><div class=""> [{field1: value1, field2: value2}, {field1: value1b, field2: value2b}]</div><div class=""> ``:code</div><div class=""> </div><div class="insert">``executesql`` have two optional argumen<span class="highlight">t</span>s: ``fields`` and ``colnames``.</div><div class=""> </div><div class=""> The ``fields`` argument is a list of DAL Field objects that match the                    </div><div class=""> fields returned from the DB. The Field objects should be part of one or                </div><div class=""> more Table objects defined on the DAL object. The ``fields`` list can                    </div><div class=""> include one or more DAL Table objects in addition to or instead of                     </div><div class=""> including Field objects, or it can be just a single table (not in a                    </div><div class=""> list). In that case, the Field objects will be extracted from the                      </div><div class=""> table(s).                                                                              </div><div class="">                                                                                                </div><div class=""> Instead of specifying the ``fields`` argument, the ``colnames`` argument                   </div><div class=""> can be specified as a list of field names in tablename.fieldname format.               </div><div class=""> Again, these should represent tables and fields defined on the DAL                     </div><div class=""> object.                                                                                </div><div class="">        </div><div class=""> It is also possible to specify both ``fields`` and the associated</div><div class=""> ``colnames``. In that case, ``fields`` can also include DAL Expression     </div><div class=""> objects in addition to Field objects. For Field objects in &quot;fields&quot;,   </div><div class=""> the associated ``colnames`` must still be in tablename.fieldname format. </div><div class=""> For Expression objects in ``fields``, the associated ``colnames`` can      </div><div class=""> be any arbitrary labels.       </div><div class=""> The easiest way is when these conditions are met:</div><div class=""> When accessing an existing table, i.e., a table not created by web2py in the current application, always set ``migrate=False``.</div><div class=""> -------</div><div class=""> </div><div class=""> If the legacy table has an auto-increment integer field but it is not called &quot;id&quot;, web2py can still access it but the table definition must contain explicitly as ``Field(&#x27;....&#x27;,&#x27;id&#x27;)`` where ... is the name of the auto-increment integer field.</div><div class=""> </div><div class=""> ``keyed table``:inxx</div><div class=""> </div><div class=""> Finally if the legacy table uses a primary key that is not an auto-increment id field it is possible to use a &quot;keyed table&quot;, for example:</div><div class=""> ``</div><div class=""> db.define_table(&#x27;account&#x27;,</div><div class="">     Field(&#x27;accnum&#x27;,&#x27;integer&#x27;),</div><div class="">     Field(&#x27;acctype&#x27;),</div><div class="">     Field(&#x27;accdesc&#x27;),</div><div class="">     primarykey=[&#x27;accnum&#x27;,&#x27;acctype&#x27;],</div><div class="">     migrate=False)</div><div class=""> ``:code</div><div class=""> </div><div class=""> - ``primarykey`` is a list of the field names that make up the primary key. </div><div class=""> - All primarykey fields have a ``NOT NULL`` set even if not specified.</div><div class=""> - Keyed table can only refer are to other keyed tables.</div><div class="insert">- Referenc<span class="highlight"></span>ing fields must use the ``reference tablename.fieldname`` format.</div><div class=""> - The ``update_record`` function is not available for Rows of keyed tables.</div><div class=""> </div><div class=""> -------</div><div class=""> Note that currently this is only available for DB2, MS-SQL, Ingres and Informix, but others can be easily added.</div><div class=""> -------</div><div class=""> </div><div class=""> At the time of writing, we cannot guarantee that the ``primarykey`` attribute works with every existing legacy table and every supported database backend.</div><div class=""> For simplicity, we recommend, if possible, creating a database view that has an auto-increment id field.</div><div class=""> </div><div class=""> </div><div class=""> ### Distributed transaction</div><div class=""> ``distributed transactions``:inxx</div><div class=""> </div><div class=""> ------</div><div class=""> At the time of writing this feature is only supported</div><div class=""> by PostgreSQL, MySQL and Firebird, since they expose API for two-phase commits.</div><div class=""> ------</div><div class=""> </div><div class=""> Assuming you have two (or more) connections to distinct PostgreSQL databases, for example:</div><div class=""> ``</div><div class=""> The SQLTABLE constructor takes the following optional arguments:</div><div class=""> - ``headers`` a dictionary mapping field names to their labels to be used as headers (default to ``{}``). It can also be an instruction. Currently we support ``headers=&#x27;fieldname:capitalize&#x27;``.</div><div class=""> - ``truncate`` the number of characters for truncating long values in the table (default is 16)</div><div class=""> - ``columns`` the list of fieldnames to be shown as columns (in tablename.fieldname format).</div><div class="">    Those not listed are not displayed (defaults to all).</div><div class=""> - ``**attributes`` generic helper attributes to be passed to the most external TABLE object.</div><div class=""> </div><div class=""> Here is an example:</div><div class=""> ``</div><div class=""> {{extend &#x27;layout.html&#x27;}}</div><div class=""> &lt;h1&gt;Records&lt;/h1&gt;</div><div class=""> {{=SQLTABLE(rows,</div><div class="">      headers=&#x27;fieldname:capitalize&#x27;,</div><div class="">      truncate=100,</div><div class="">      upload=URL(&#x27;download&#x27;))</div><div class=""> }}</div><div class=""> ``:code</div><div class=""> </div><div class=""> ``SQLFORM.grid``:inxx ``SQLFORM.smartgrid``:inxx</div><div class=""> </div><div class=""> ------</div><div class="insert">``SQLTABLE`` is useful but there are types when one needs more. ``SQLFORM.grid`` is an extension of SQLTABLE that creates a table with search features and pagination, as well as ability to open detailed records, create, edit and delete records. ``SQLFORM.smartgrid`` is a further generaliza<span class="highlight">ti</span>on that allows all of the above but also creates buttons to access referencing records.</div><div class=""> ------</div><div class=""> </div><div class=""> Here is an example of usage of ``SQLFORM.grid``:</div><div class=""> </div><div class=""> ``</div><div class=""> def index():</div><div class="">     return dict(grid=SQLFORM.grid(query))</div><div class=""> ``:code</div><div class=""> </div><div class=""> and the corresponding view:</div><div class=""> </div><div class=""> ``</div><div class=""> {{extend &#x27;layout.html&#x27;}}</div><div class=""> {{=grid}}</div><div class=""> ``</div><div class=""> </div><div class="insert">``SQLFORM.grid`` and ``SQLFORM.smartgrid`` should be preferr<span class="highlight">ed</span> to ``SQLTABLE`` because they are more powerful although higher level and therefore more constraining. They will be explained in more detail in chapter 8.</div><div class=""> </div><div class=""> #### ``orderby``, ``groupby``, ``limitby``, ``distinct``</div><div class=""> </div><div class=""> The ``select`` command takes five optional arguments: orderby, groupby, limitby, left and cache. Here we discuss the first three.</div><div class=""> </div><div class=""> You can fetch the records sorted by name:</div><div class=""> </div><div class=""> ``orderby``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db().select(</div><div class="">         db.person.ALL, orderby=db.person.name):</div><div class="">         print row.name</div><div class=""> Alex</div><div class=""> Bob</div><div class=""> Carl</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can fetch the records sorted by name in reverse order (notice the tilde):</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db().select(</div><div class=""> Another way to achieve a similar result is by using a join, specifically an INNE</div><div class=""> Alex has Boat</div><div class=""> Alex has Chair</div><div class=""> Bob has Shoes</div><div class=""> ``:code</div><div class=""> </div><div class=""> Observe that web2py did a join, so the rows now contain two records, one from each table, linked together. Because the two records may have fields with conflicting names, you need to specify the table when extracting a field value from a row. This means that while before you could do:</div><div class=""> ``</div><div class=""> row.name</div><div class=""> ``:code</div><div class=""> </div><div class=""> and it was obvious whether this was the name of a person or a thing, in the result of a join you have to be more explicit and say:</div><div class=""> ``</div><div class=""> row.person.name</div><div class=""> ``:code</div><div class=""> </div><div class=""> or:</div><div class=""> ``</div><div class=""> row.thing.name</div><div class=""> ``:code</div><div class=""> </div><div class="insert">There is an alter<span class="highlight">n</span>a<span class="highlight"></span>tive syntax for INNER JOINS:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows = db(db.person).select(join=db.thing.on(db.person.id==db.thing.owner))</div><div class=""> &gt;&gt;&gt; for row in rows:</div><div class="">     print row.person.name, &#x27;has&#x27;, row.thing.name</div><div class=""> Alex has Boat</div><div class=""> Alex has Chair</div><div class=""> Bob has Shoes</div><div class=""> ``:code</div><div class=""> </div><div class=""> While the output is the same, the generated SQL in the two cases can be different. The latter syntax removes possible ambiguities when the same table is joined twice and aliased:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;thing&#x27;,</div><div class="">         Field(&#x27;name&#x27;),</div><div class="">         Field(&#x27;owner1&#x27;,&#x27;reference person&#x27;),</div><div class="">         Field(&#x27;owner2&#x27;,&#x27;reference person&#x27;))</div><div class=""> &gt;&gt;&gt; rows = db(db.person).select(</div><div class="">     join=[db.person.with_alias(&#x27;owner1&#x27;).on(db.person.id==db.thing.owner1).</div><div class="">           db.person.with_alias(&#x27;owner2&#x27;).on(db.person.id==db.thing.owner2)])</div><div class=""> ``</div><div class=""> For the sake of the example, you can log events with the same event_time but wit</div><div class=""> &gt;&gt;&gt; print db.log.insert(</div><div class="">         event=&#x27;unauthorized login&#x27;, event_time=now, severity=3)</div><div class=""> 3</div><div class=""> ``:code</div><div class=""> </div><div class=""> #### ``like``, ``regexp``, ``startswith``, ``contains``, ``upper``, ``lower``</div><div class=""> </div><div class=""> ``like``:inxx ``startswith``:inxx ``regexp``:inxx</div><div class=""> ``contains``:inxx ``upper``:inxx ``lower``:inxx</div><div class=""> </div><div class=""> Fields have a like operator that you can use to match strings:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db(db.log.event.like(&#x27;port%&#x27;)).select():</div><div class="">         print row.event</div><div class=""> port scan</div><div class=""> ``:code</div><div class=""> </div><div class=""> Here &quot;port%&quot; indicates a string starting with &quot;port&quot;. The percent sign character, &quot;%&quot;, is a wild-card character that means &quot;any sequence of characters&quot;.</div><div class=""> </div><div class="insert">The like operator is case<span class="highlight">-</span>ins<span class="highlight">en</span>sit<span class="highlight">iv</span>e but it can be made case<span class="highlight">-</span>sensitive with</div><div class=""> </div><div class=""> ``</div><div class=""> db.mytable.myfield.like(&#x27;value&#x27;,case_sensitive=True)</div><div class=""> ``:code</div><div class=""> </div><div class=""> </div><div class=""> web2py also provides some shortcuts:</div><div class=""> </div><div class=""> ``</div><div class=""> db.mytable.myfield.startswith(&#x27;value&#x27;)</div><div class=""> db.mytable.myfield.contains(&#x27;value&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> which are equivalent respectively to</div><div class=""> </div><div class=""> ``</div><div class=""> db.mytable.myfield.like(&#x27;value%&#x27;)</div><div class=""> db.mytable.myfield.like(&#x27;%value%&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> port scan</div><div class=""> xss injection</div><div class=""> ``:code</div><div class=""> </div><div class=""> The DAL also allows a nested select as the argument of the belongs operator. The only caveat is that the nested select has to be a ``_select``, not a ``select``, and only one field has to be selected explicitly, the one that defines the set.</div><div class=""> </div><div class=""> ``nested select``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; bad_days = db(db.log.severity==3)._select(db.log.event_time)</div><div class=""> &gt;&gt;&gt; for row in db(db.log.event_time.belongs(bad_days)).select():</div><div class="">         print row.event</div><div class=""> port scan</div><div class=""> xss injection</div><div class=""> unauthorized login</div><div class=""> ``:code</div><div class=""> </div><div class=""> In those cases where a nested select is required and the loop-up field is a reference we can also use a query as argument. For example:</div><div class=""> </div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;,Field(&#x27;name&#x27;))</div><div class=""> db.define_table(&#x27;thing&#x27;,Field(&#x27;owner&#x27;),Field(&#x27;owner&#x27;,&#x27;reference thing&#x27;))</div><div class="insert">db(db.thing.owner.belongs(db.person.name==&#x27;Jo<span class="highlight"></span>nathan&#x27;)).select()</div><div class=""> ``:code</div><div class=""> </div><div class=""> In this case it is obvious that the next select only needs the field referenced by the ``db.thing.owner`` field so we do not need the more verbose ``_select`` notation.</div><div class=""> </div><div class=""> ``nested_select``:inxx</div><div class=""> </div><div class="insert">A nested select can also be used as insert/update value but in this case the sy<span class="highlight">n</span>tax is different:</div><div class=""> </div><div class=""> ``</div><div class=""> lazy = db(db.person.name==&#x27;Jonathan&#x27;).nested_select(db.person.id)</div><div class=""> db(db.thing.id==1).update(owner = lazy)</div><div class=""> ``:code</div><div class=""> </div><div class=""> In this case ``lazy`` is a nested expression that computes the ``id`` of person &quot;Jonathan&quot;. The two lines result in one single SQL query.</div><div class=""> </div><div class=""> #### ``sum``, ``avg``, ``min``, ``max`` and ``len``</div><div class=""> </div><div class=""> ``sum``:inxx ``avg``:inxx ``min``:inxx ``max``:inxx</div><div class=""> Previously, you have used the count operator to count records. Similarly, you can use the sum operator to add (sum) the values of a specific field from a group of records. As in the case of count, the result of a sum is retrieved via the store object:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; sum = db.log.severity.sum()</div><div class=""> &gt;&gt;&gt; print db().select(sum).first()[sum]</div><div class=""> 6</div><div class=""> ``:code</div><div class=""> </div><div class="insert">You can also use ``avg``, ``min``, and ``max`` to the average, mini<span class="highlight">m</span>um, and maximum value respectively for the selected records. For example:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; max = db.log.severity.max()</div><div class=""> &gt;&gt;&gt; print db().select(max).first()[max]</div><div class=""> 3</div><div class=""> ``:code</div><div class=""> </div><div class=""> ``.len()`` computes the length of a string, text or boolean fields.</div><div class=""> </div><div class=""> Expressions can be combined to form more complex expressions. For example here we are computing the sum of the length of all the severity strings in the logs, increased of one:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; sum = (db.log.severity.len()+1).sum()</div><div class=""> &gt;&gt;&gt; print db().select(sum).first()[sum]</div><div class=""> ``:code</div><div class=""> </div><div class=""> #### Substrings</div><div class=""> </div><div class=""> One can build an expression to refer to a substring. For example, we can group things whose name starts with the same three characters and select only one from each group:</div><div class=""> </div><div class=""> ``</div><div class="insert">db(db.thing).select(di<span class="highlight">s</span>tinct = db.thing.name[:3])</div><div class=""> ``:code</div><div class=""> </div><div class=""> </div><div class=""> #### Default values with ``coalesce`` and ``coalesce_zero``</div><div class=""> </div><div class=""> There are times when you need to pull a value from database but also need a default values if the value for a record is set to NULL. In SQL there is a keyword, ``COALESCE``, for this. web2py has an equivalent ``coalesce`` method:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;sysuser&#x27;,Field(&#x27;username&#x27;),Field(&#x27;fullname&#x27;))</div><div class=""> &gt;&gt;&gt; db.sysuser.insert(username=&#x27;max&#x27;,fullname=&#x27;Max Power&#x27;)</div><div class=""> &gt;&gt;&gt; db.sysuser.insert(username=&#x27;tim&#x27;,fullname=None)</div><div class=""> print db(db.sysuser).select(db.sysuser.fullname.coalesce(db.sysuser.username))</div><div class=""> &quot;COALESCE(sysuser.fullname,sysuser.username)&quot;</div><div class=""> Max Power</div><div class=""> tim</div><div class=""> ``</div><div class=""> </div><div class=""> Other times you need to compute a mathematical expression but some fields have a value set to None while it should be zero.</div><div class=""> ``coalesce_zero`` comes to the rescue by defaulting None to zero in the query:</div><div class=""> </div><div class=""> This is best explained via some examples.</div><div class=""> ``:code</div><div class=""> </div><div class=""> Here ``f`` is a dict of fields passed to insert or update, ``id`` is the id of the newly inserted record, ``s`` is the Set object used for update or delete.</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.person.insert(name=&#x27;John&#x27;)</div><div class=""> ({&#x27;name&#x27;: &#x27;John&#x27;},)</div><div class=""> ({&#x27;name&#x27;: &#x27;John&#x27;}, 1)</div><div class=""> &gt;&gt;&gt; db(db.person.id==1).update(name=&#x27;Tim&#x27;)</div><div class=""> (&lt;Set (person.id = 1)&gt;, {&#x27;name&#x27;: &#x27;Tim&#x27;})</div><div class=""> (&lt;Set (person.id = 1)&gt;, {&#x27;name&#x27;: &#x27;Tim&#x27;})</div><div class=""> &gt;&gt;&gt; db(db.person.id==1).delete()</div><div class=""> (&lt;Set (person.id = 1)&gt;,)</div><div class=""> (&lt;Set (person.id = 1)&gt;,)</div><div class=""> ``:code</div><div class=""> </div><div class=""> The return values of these callback should be ``None`` or ``False``. If any of the ``_before_*`` callback returns a ``True`` value it will abort the actual insert/update/delete operation.</div><div class=""> </div><div class=""> ``update_naive``:inxx.</div><div class=""> </div><div class="insert">Some times a callback may need to perform an update in the same of a different table an<span class="highlight">d</span> one wants to avoid callbacks calling themselves recursively.</div><div class=""> </div><div class=""> For this purpose there the Set objects have an ``update_naive`` method that works like ``update`` but ignores before and after callbacks.</div><div class=""> </div><div class=""> #### Record versioning </div><div class=""> </div><div class=""> ``_enable_record_versioning``:inxx</div><div class=""> </div><div class=""> It is possible to ask web2py to save every copy of a record when the record is modified. There are many ways to do it and it can be done for all tables at once using the ``auth.enable_record_versioning`` method, discussed in the chapter about authentication, or it can be done for each individual table as discussed here.</div><div class=""> </div><div class=""> Consider the following table:</div><div class=""> </div><div class=""> ``</div><div class=""> db.define_table(&#x27;stored_item&#x27;,</div><div class="">     Field(&#x27;name&#x27;),</div><div class="">     Field(&#x27;quantity&#x27;,&#x27;integer&#x27;),</div><div class="">     Field(&#x27;is_active&#x27;,&#x27;boolean&#x27;,</div><div class="">           writable=False,readable=False,default=True))</div><div class=""> ``:code</div><div class=""> </div><div class=""> Notice we the hidden boolean field called ``is_active`` and defaulting to </div><div class=""> True.</div><div class=""> </div><div class=""> We can tell web2py to create a new table (in the same or a different database) and store all previous versions of each record in the table, when modified.</div><div class=""> </div><div class=""> This is done in the following way:</div><div class=""> ``</div><div class=""> db.stored_item._enable_record_versioning()</div><div class=""> ``:code</div><div class=""> </div><div class=""> or in a more verbose syntax:</div><div class=""> </div><div class=""> ``</div><div class=""> db.stored_item._enable_record_versioning(</div><div class="">     archive_db = db,</div><div class="insert">    archive_name = &#x27;st<span class="highlight"></span>ored_item_archive&#x27;,</div><div class="">     current_record = &#x27;current_record&#x27;,</div><div class="">     is_active = &#x27;is_active&#x27;)</div><div class=""> ``</div><div class=""> </div><div class="insert">The ``ar<span class="highlight">ch</span>ive_db=db`` tells web2py to store the archive table in the same database as the ``stored_item`` table. The ``archive_name`` sets the name for the ar<span class="highlight"></span>chive table. The archive table has the same fields as the original table ``stored_item`` except that unique fields are no longer unique (because it needs to store multiple versions) and has an extra field which name is specified by ``current_record`` and which is a reference to the current record in the ``stored_item`` table.</div><div class=""> </div><div class="insert">When records are deleted, they are not really deleted. A deleted record is copied in the ``st<span class="highlight"></span>ored_item_archive`` table (like when it is modified) and the ``is_active`` field is set to False. By enabling record versi<span class="highlight">o</span>ning web2py sets a ``custom_filter`` on this table that hides all fields in table ``st<span class="highlight"></span>ored_item`` where the ``is_active`` field is set to False. The ``is_active`` parameter in the ``_enable_record_versioning`` method allows to specify the name of the field used by the ``custom_filter`` to determine if the field was deleted or not.</div><div class=""> </div><div class=""> ``custom_filter``s are ignored by the appadmin interface.</div><div class=""> </div><div class=""> #### Common fields and multi-tenancy</div><div class=""> ``common fields``:inxx</div><div class=""> ``multi tenancy``:inxx</div><div class=""> </div><div class=""> ``db._common_fields`` is a list of fields that should belong to all the tables. This list can also contain tables and it it is understood as all fields from the table. For example occasionally you find yourself in need to add a signature to all your tables but the ```auth`` tables. In this case, after you ``db.define_tables()`` but before defining any other table, insert</div><div class=""> </div><div class=""> ``</div><div class=""> db._common_fields.append(auth.signature)</div><div class=""> ``</div><div class=""> </div><div class=""> One field is special: &quot;request_tenant&quot;.</div><div class=""> This field does not exist but you can create it and add it to any of your tables (or them all):</div><div class=""> </div><div class=""> ``</div><div class=""> db._common_fields.append(Field(&#x27;request_tenant&#x27;,</div><div class="">     default=request.env.http_host,writable=False))</div><div class=""> ``</div><div class=""> The file &quot;gluon/dal.py&quot; defines, among other, the following classes.</div><div class=""> </div><div class=""> ``</div><div class=""> ConnectionPool</div><div class=""> BaseAdapter extends ConnectionPool</div><div class=""> Row</div><div class=""> DAL</div><div class=""> Reference</div><div class=""> Table</div><div class=""> Expression</div><div class=""> Field</div><div class=""> Query</div><div class=""> Set</div><div class=""> Rows</div><div class=""> ``</div><div class=""> </div><div class=""> Their use has been explained in the previous sections, except for ``BaseAdapter``. When the methods of a ``Table`` or ``Set`` object need to communicate with the database they delegate to methods of the adapter the task to generate the SQL and or the function call.</div><div class=""> </div><div class=""> For example:</div><div class=""> </div><div class=""> ``</div><div class="insert">db.my<span class="highlight">t</span>able.insert(myfield=&#x27;myvalue&#x27;)</div><div class=""> ``</div><div class=""> </div><div class=""> calls</div><div class=""> </div><div class=""> ``</div><div class=""> Table.insert(myfield=&#x27;myvalue&#x27;)</div><div class=""> ``</div><div class=""> </div><div class=""> which delegates the adapter by returning:</div><div class=""> </div><div class=""> ``</div><div class=""> db._adapter.insert(db.mytable,db.mytable._listify(dict(myfield=&#x27;myvalue&#x27;)))</div><div class=""> ``</div><div class=""> </div><div class=""> Here ``db.mytable._listify`` converts the dict of arguments into a list of ``(field,value)`` and calls the ``insert`` method of the ``adapter``. ``db._adapter`` does more or less the following:</div><div class=""> </div><div class=""> ``</div><div class=""> query = db._adapter._insert(db.mytable,list_of_fields)</div><div class=""> db._adapter.execute(query)</div><div class=""> ``</div><div class=""> MySQLAdapter.driver = mysqldb</div><div class=""> ``</div><div class=""> </div><div class=""> and you can specify optional driver arguments and adapter arguments:</div><div class=""> </div><div class=""> ``</div><div class=""> db =DAL(..., driver_args={}, adapter_args={})</div><div class=""> ``</div><div class=""> </div><div class=""> </div><div class=""> #### Gotchas</div><div class=""> </div><div class=""> **SQLite** does not support dropping and altering columns. That means that web2py migrations will work up to a point. If you delete a field from a table, the column will remain in the database but be invisible to web2py. If you decide to reinstate the column, web2py will try re-create it and fail. In this case you must set ``fake_migrate=True`` so that metadata is rebuilt without attempting to add the column again. Also, for the same reason, **SQLite** is not aware of any change of column type. If you insert a number in a string field, it will be stored as string. If you later change the model and replace the type &quot;string&quot; with type &quot;integer&quot;, SQLite will continue to keep the number as a string and this may cause problem when you try to extract the data.</div><div class=""> </div><div class=""> **MySQL** does not support multiple ALTER TABLE within a single transaction. This means that any migration process is broken into multiple commits. If something happens that causes a failure it is possible to break a migration (the web2py metadata are no longer in sync with the actual table structure in the database). This is unfortunate but it can be prevented (migrate one table at the time) or it can be fixed a posteriori (revert the web2py model to what corresponds to the table structure in database, set ``fake_migrate=True`` and after the metadata has been rebuilt, set ``fake_migrate=False`` and migrate the table again).</div><div class=""> </div><div class=""> **Google SQL** has the same problems as MySQL and more. In particular table metadata itself must be stored in the database in a table that is not migrated by web2py. This is because Google App Engine has a readonly file system. Web2py migrations in Google:SQL combined with the MySQL issue described above can result in metadata corruption. Again, this can be prevented (my migrating the table at once and then setting migrate=False so that the metadata table is not accessed any more) or it can fixed a posteriori (my accessing the database using the Google dashboard and deleting any corrupted entry from the table called ``web2py_filesystem``.</div><div class=""> </div><div class=""> ``limitby``:inxx</div><div class=""> **MSSQL** does not support the SQL OFFSET keyword. Therefore the database cannot do pagination. When doing a ``limitby=(a,b)`` web2py will fetch the first ``b`` rows and discard the first the ``a``. This may result in a considerable overhead when compared with other database engines.</div><div class=""> </div><div class="insert">**Oracle** also does not support pagination. It does not support neither the OFFSET nor the LIMIT keywords. Web2py achieves pagination by translating a ``db(...).select(limitby=(a,b))`` into a complex three-way nested select (as suggested by official Oracle documentation). This works for simple select but may break for complex selects involving ali<span class="highlight">a</span>sed fields and or joins.</div></div></div>
    <div class="span6"><div class="diff"><div class="delete">The ``big-id`` and, ``big-reference`` are only supported by some of the database engines and are experimental. They are not normally used as field types unless for legacy tables, however, the DAL constructor has a ``bigint_id`` argument that when set to ``True`` makes the ``id`` fields and ``reference`` fields ``big-id`` and ``big-refere<span class="highlight"></span>ce`` respectively.</div><div class=""> </div><div class=""> The ``list:`` fields are special because they are designed to take advantage of certain denormalization features on NoSQL (in the case of Google App Engine NoSQL, the field types ``ListProperty`` and ``StringListProperty``) and back-port them all the other supported relational databases. On relational databases lists are stored as a ``text`` field. The items are separated by a ``|`` and each ``|`` in string item is escaped as a ``||``. They are discussed in their own section.</div><div class=""> </div><div class=""> -------</div><div class=""> Notice that ``requires=...`` is enforced at the level of forms, ``required=True`` is enforced at the level of the DAL (insert), while ``notnull``, ``unique`` and ``ondelete`` are enforced at the level of the database. While they sometimes may seem redundant, it is important to maintain the distinction when programming with the DAL.</div><div class=""> -------</div><div class=""> </div><div class=""> ``ondelete``:inxx</div><div class=""> </div><div class=""> - ``ondelete`` translates into the &quot;ON DELETE&quot; SQL statement. By default it is set to &quot;CASCADE&quot;. This tells the database that when it deletes a record, it should also delete all records that refer to it. To disable this feature, set ``ondelete`` to &quot;NO ACTION&quot; or &quot;SET NULL&quot;.</div><div class=""> - ``notnull=True`` translates into the &quot;NOT NULL&quot; SQL statement. It prevents the database from inserting null values for the field.</div><div class=""> - ``unique=True`` translates into the &quot;UNIQUE&quot; SQL statement and it makes sure that values of this field are unique within the table. It is enforced at the database level.</div><div class=""> - ``uploadfield`` applies only to fields of type &quot;upload&quot;. A field of type &quot;upload&quot; stores the name of a file saved somewhere else, by default on the filesystem under the application &quot;uploads/&quot; folder. If ``uploadfield`` is set, then the file is stored in a blob field within the same table and the value of ``uploadfield`` is the name of the blob field. This will be discussed in more detail later in the context of SQLFORM.</div><div class=""> - ``uploadfolder`` defaults to the application&#x27;s &quot;uploads/&quot; folder. If set to a different path, files will uploaded to a different folder. For example, uploadfolder=os.path.join(request.folder,&#x27;static/temp&#x27;) will upload files to the web2py/applications/myapp/static/temp folder.</div><div class=""> - ``uploadseparate`` if set to True will upload files under different subfolders of the &#x27;&#x27;uploadfolder&#x27;&#x27; folder. This is optimized to avoid too many files under the same folder/subfolder. ATTENTION: You cannot change the value of ``uploadseparate`` from True to False without breaking the system. web2py either uses the separate subfolders or it does not. Changing the behavior after files have been uploaded will prevent web2py from being able to retrieve those files. If this happens it is possible to move files and fix the problem but this is not described here.</div><div class=""> - ``uploadfs`` allows you specify a different filessystem where to upload files, including an Amazon S3 storage or a remote FTP storage. This option requires PyFileSystem installed. ``uploadfs`` must point to ``PyFileSystem``. ``PyFileSystem``:inxx ``uploadfs``:idxx</div><div class=""> - ``widget`` must be one of the available widget objects, including custom widgets, for example: ``SQLFORM.widgets.string.widget``. A list of available widgets will be discussed later. Each field type has a default widget.</div><div class=""> - ``label`` is a string (or something that can be serialized to a string) that contains the label to be used for this field in autogenerated forms.</div><div class=""> - ``comment``  is a string (or something that can be serialized to a string) that contains a comment associated with this field, and will be displayed to the right of the input field in the autogenerated forms.</div><div class=""> - ``writable`` if a field is writable, it can be edited in autogenerated create and update forms.</div><div class=""> The first argument of ``define_table`` is always the table name. The other unnam</div><div class=""> ``:code</div><div class=""> </div><div class=""> The value of migrate is the filename (in the &quot;databases&quot; folder for the application) where web2py stores internal migration information for this table. These files are very important and should never be removed except when the entire database is dropped. In this case, the &quot;.table&quot; files have to be removed manually. By default, migrate is set to True. This causes web2py to generate the filename from a hash of the connection string. If migrate is set to False, the migration is not performed, and web2py assumes that the table exists in the datastore and it contains (at least) the fields listed in ``define_table``.</div><div class=""> The best practice is to give an explicit name to the migrate table.</div><div class=""> </div><div class=""> There may not be two tables in the same application with the same migrate filename.</div><div class=""> </div><div class=""> The DAL class also takes a &quot;migrate&quot; argument, which determines the default value of migrate for calls to ``define_table``. For example,</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db = DAL(&#x27;sqlite://storage.db&#x27;, migrate=False)</div><div class=""> ``:code</div><div class=""> </div><div class=""> will set the default value of migrate to False whenever ``db.define_table`` is called without a migrate argument.</div><div class=""> </div><div class=""> Migrations can be disabled for all tables at the moment of connection:</div><div class=""> </div><div class=""> ``</div><div class=""> db = DAL(...,migrate_enabled=False)</div><div class=""> ``</div><div class=""> </div><div class="delete">This is the recommended behavio<span class="highlight">u</span>r when two apps share the same database. Only one of the two apps should perform migrations, the other should disabled them.</div><div class=""> </div><div class=""> ### Fixing broken migrations</div><div class=""> ``fake_migrate``:inxx</div><div class=""> </div><div class=""> There are two common problems with migrations and there are ways to recover from them.</div><div class=""> </div><div class=""> One problem is specific with SQLite. SQLite does not enforce column types and cannot drop columns. This means that if you have a column of type string and you remove it, it is not really removed. If you add the column again with a different type (for example datetime) you end up with a datetime column that contains strings (junk for practical purposes). web2py does not complain about this because it does not know what is in the database, until it tries to retrieve records and fails.</div><div class=""> </div><div class=""> If web2py returns an error in the gluon.sql.parse function when selecting records, this is the problem: corrupted data in a column because of the above issue.</div><div class=""> </div><div class=""> The solution consists in updating all records of the table and updating the values in the column in question with None.</div><div class=""> </div><div class=""> The other problem is more generic but typical with MySQL. MySQL does not allow more than one ALTER TABLE in a transaction. This means that web2py must break complex transactions into smaller ones (one ALTER TABLE at the time) and commit one piece at the time. It is therefore possible that part of a complex transaction gets committed and one part fails, leaving web2py in a corrupted state. Why would part of a transaction fail? Because, for example, it involves altering a table and converting a string column into a datetime column, web2py tries to convert the data, but the data cannot be converted. What happens to web2py? It gets confused about what exactly is the table structure actually stored in the database.</div><div class=""> </div><div class=""> The solution consists of disabling migrations for all tables and enabling fake migrations:</div><div class=""> ``</div><div class=""> db.define_table(....,migrate=False,fake_migrate=True)</div><div class=""> ``:code</div><div class=""> </div><div class=""> This will rebuild web2py metadata about the table according to the table definition. Try multiple table definitions to see which one works (the one before the failed migration and the one after the failed migration). Once successful remove the ``fake_migrate=True`` attribute.</div><div class=""> The DAL allows you to explicitly issue SQL statements.</div><div class=""> &gt;&gt;&gt; print db.executesql(&#x27;SELECT * FROM person;&#x27;)</div><div class=""> [(1, u&#x27;Massimo&#x27;), (2, u&#x27;Massimo&#x27;)]</div><div class=""> ``:code</div><div class=""> </div><div class=""> In this case, the return values are not parsed or transformed by the DAL, and the format depends on the specific database driver. This usage with selects is normally not needed, but it is more common with indexes.</div><div class=""> ``executesql`` takes two optional arguments: ``placeholders`` and ``as_dict``</div><div class=""> ``placeholders`` is an optional</div><div class=""> sequence of values to be substituted in</div><div class=""> or, if supported by the DB driver, a dictionary with keys</div><div class=""> matching named placeholders in your SQL.</div><div class=""> </div><div class=""> If ``as_dict`` is set to True,</div><div class=""> and the results cursor returned by the DB driver will be</div><div class=""> converted to a sequence of dictionaries keyed with the db</div><div class=""> field names.  Results returned with ``as_dict = True ``are</div><div class=""> the same as those returned when applying **.as_list()** to a normal select.</div><div class=""> ``</div><div class=""> [{field1: value1, field2: value2}, {field1: value1b, field2: value2b}]</div><div class=""> ``:code</div><div class=""> </div><div class="delete">``executesql`` have two optional argumen<span class="highlight"></span>s: ``fields`` and ``colnames``.</div><div class=""> </div><div class=""> The ``fields`` argument is a list of DAL Field objects that match the                    </div><div class=""> fields returned from the DB. The Field objects should be part of one or                </div><div class=""> more Table objects defined on the DAL object. The ``fields`` list can                    </div><div class=""> include one or more DAL Table objects in addition to or instead of                     </div><div class=""> including Field objects, or it can be just a single table (not in a                    </div><div class=""> list). In that case, the Field objects will be extracted from the                      </div><div class=""> table(s).                                                                              </div><div class="">                                                                                                </div><div class=""> Instead of specifying the ``fields`` argument, the ``colnames`` argument                   </div><div class=""> can be specified as a list of field names in tablename.fieldname format.               </div><div class=""> Again, these should represent tables and fields defined on the DAL                     </div><div class=""> object.                                                                                </div><div class="">        </div><div class=""> It is also possible to specify both ``fields`` and the associated</div><div class=""> ``colnames``. In that case, ``fields`` can also include DAL Expression     </div><div class=""> objects in addition to Field objects. For Field objects in &quot;fields&quot;,   </div><div class=""> the associated ``colnames`` must still be in tablename.fieldname format. </div><div class=""> For Expression objects in ``fields``, the associated ``colnames`` can      </div><div class=""> be any arbitrary labels.       </div><div class=""> The easiest way is when these conditions are met:</div><div class=""> When accessing an existing table, i.e., a table not created by web2py in the current application, always set ``migrate=False``.</div><div class=""> -------</div><div class=""> </div><div class=""> If the legacy table has an auto-increment integer field but it is not called &quot;id&quot;, web2py can still access it but the table definition must contain explicitly as ``Field(&#x27;....&#x27;,&#x27;id&#x27;)`` where ... is the name of the auto-increment integer field.</div><div class=""> </div><div class=""> ``keyed table``:inxx</div><div class=""> </div><div class=""> Finally if the legacy table uses a primary key that is not an auto-increment id field it is possible to use a &quot;keyed table&quot;, for example:</div><div class=""> ``</div><div class=""> db.define_table(&#x27;account&#x27;,</div><div class="">     Field(&#x27;accnum&#x27;,&#x27;integer&#x27;),</div><div class="">     Field(&#x27;acctype&#x27;),</div><div class="">     Field(&#x27;accdesc&#x27;),</div><div class="">     primarykey=[&#x27;accnum&#x27;,&#x27;acctype&#x27;],</div><div class="">     migrate=False)</div><div class=""> ``:code</div><div class=""> </div><div class=""> - ``primarykey`` is a list of the field names that make up the primary key. </div><div class=""> - All primarykey fields have a ``NOT NULL`` set even if not specified.</div><div class=""> - Keyed table can only refer are to other keyed tables.</div><div class="delete">- Referenc<span class="highlight">e</span>ing fields must use the ``reference tablename.fieldname`` format.</div><div class=""> - The ``update_record`` function is not available for Rows of keyed tables.</div><div class=""> </div><div class=""> -------</div><div class=""> Note that currently this is only available for DB2, MS-SQL, Ingres and Informix, but others can be easily added.</div><div class=""> -------</div><div class=""> </div><div class=""> At the time of writing, we cannot guarantee that the ``primarykey`` attribute works with every existing legacy table and every supported database backend.</div><div class=""> For simplicity, we recommend, if possible, creating a database view that has an auto-increment id field.</div><div class=""> </div><div class=""> </div><div class=""> ### Distributed transaction</div><div class=""> ``distributed transactions``:inxx</div><div class=""> </div><div class=""> ------</div><div class=""> At the time of writing this feature is only supported</div><div class=""> by PostgreSQL, MySQL and Firebird, since they expose API for two-phase commits.</div><div class=""> ------</div><div class=""> </div><div class=""> Assuming you have two (or more) connections to distinct PostgreSQL databases, for example:</div><div class=""> ``</div><div class=""> The SQLTABLE constructor takes the following optional arguments:</div><div class=""> - ``headers`` a dictionary mapping field names to their labels to be used as headers (default to ``{}``). It can also be an instruction. Currently we support ``headers=&#x27;fieldname:capitalize&#x27;``.</div><div class=""> - ``truncate`` the number of characters for truncating long values in the table (default is 16)</div><div class=""> - ``columns`` the list of fieldnames to be shown as columns (in tablename.fieldname format).</div><div class="">    Those not listed are not displayed (defaults to all).</div><div class=""> - ``**attributes`` generic helper attributes to be passed to the most external TABLE object.</div><div class=""> </div><div class=""> Here is an example:</div><div class=""> ``</div><div class=""> {{extend &#x27;layout.html&#x27;}}</div><div class=""> &lt;h1&gt;Records&lt;/h1&gt;</div><div class=""> {{=SQLTABLE(rows,</div><div class="">      headers=&#x27;fieldname:capitalize&#x27;,</div><div class="">      truncate=100,</div><div class="">      upload=URL(&#x27;download&#x27;))</div><div class=""> }}</div><div class=""> ``:code</div><div class=""> </div><div class=""> ``SQLFORM.grid``:inxx ``SQLFORM.smartgrid``:inxx</div><div class=""> </div><div class=""> ------</div><div class="delete">``SQLTABLE`` is useful but there are types when one needs more. ``SQLFORM.grid`` is an extension of SQLTABLE that creates a table with search features and pagination, as well as ability to open detailed records, create, edit and delete records. ``SQLFORM.smartgrid`` is a further generaliza<span class="highlight">it</span>on that allows all of the above but also creates buttons to access referencing records.</div><div class=""> ------</div><div class=""> </div><div class=""> Here is an example of usage of ``SQLFORM.grid``:</div><div class=""> </div><div class=""> ``</div><div class=""> def index():</div><div class="">     return dict(grid=SQLFORM.grid(query))</div><div class=""> ``:code</div><div class=""> </div><div class=""> and the corresponding view:</div><div class=""> </div><div class=""> ``</div><div class=""> {{extend &#x27;layout.html&#x27;}}</div><div class=""> {{=grid}}</div><div class=""> ``</div><div class=""> </div><div class="delete">``SQLFORM.grid`` and ``SQLFORM.smartgrid`` should be preferr<span class="highlight">able</span> to ``SQLTABLE`` because they are more powerful although higher level and therefore more constraining. They will be explained in more detail in chapter 8.</div><div class=""> </div><div class=""> #### ``orderby``, ``groupby``, ``limitby``, ``distinct``</div><div class=""> </div><div class=""> The ``select`` command takes five optional arguments: orderby, groupby, limitby, left and cache. Here we discuss the first three.</div><div class=""> </div><div class=""> You can fetch the records sorted by name:</div><div class=""> </div><div class=""> ``orderby``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db().select(</div><div class="">         db.person.ALL, orderby=db.person.name):</div><div class="">         print row.name</div><div class=""> Alex</div><div class=""> Bob</div><div class=""> Carl</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can fetch the records sorted by name in reverse order (notice the tilde):</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db().select(</div><div class=""> Another way to achieve a similar result is by using a join, specifically an INNE</div><div class=""> Alex has Boat</div><div class=""> Alex has Chair</div><div class=""> Bob has Shoes</div><div class=""> ``:code</div><div class=""> </div><div class=""> Observe that web2py did a join, so the rows now contain two records, one from each table, linked together. Because the two records may have fields with conflicting names, you need to specify the table when extracting a field value from a row. This means that while before you could do:</div><div class=""> ``</div><div class=""> row.name</div><div class=""> ``:code</div><div class=""> </div><div class=""> and it was obvious whether this was the name of a person or a thing, in the result of a join you have to be more explicit and say:</div><div class=""> ``</div><div class=""> row.person.name</div><div class=""> ``:code</div><div class=""> </div><div class=""> or:</div><div class=""> ``</div><div class=""> row.thing.name</div><div class=""> ``:code</div><div class=""> </div><div class="delete">There is an alter<span class="highlight"></span>a<span class="highlight">n</span>tive syntax for INNER JOINS:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows = db(db.person).select(join=db.thing.on(db.person.id==db.thing.owner))</div><div class=""> &gt;&gt;&gt; for row in rows:</div><div class="">     print row.person.name, &#x27;has&#x27;, row.thing.name</div><div class=""> Alex has Boat</div><div class=""> Alex has Chair</div><div class=""> Bob has Shoes</div><div class=""> ``:code</div><div class=""> </div><div class=""> While the output is the same, the generated SQL in the two cases can be different. The latter syntax removes possible ambiguities when the same table is joined twice and aliased:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;thing&#x27;,</div><div class="">         Field(&#x27;name&#x27;),</div><div class="">         Field(&#x27;owner1&#x27;,&#x27;reference person&#x27;),</div><div class="">         Field(&#x27;owner2&#x27;,&#x27;reference person&#x27;))</div><div class=""> &gt;&gt;&gt; rows = db(db.person).select(</div><div class="">     join=[db.person.with_alias(&#x27;owner1&#x27;).on(db.person.id==db.thing.owner1).</div><div class="">           db.person.with_alias(&#x27;owner2&#x27;).on(db.person.id==db.thing.owner2)])</div><div class=""> ``</div><div class=""> For the sake of the example, you can log events with the same event_time but wit</div><div class=""> &gt;&gt;&gt; print db.log.insert(</div><div class="">         event=&#x27;unauthorized login&#x27;, event_time=now, severity=3)</div><div class=""> 3</div><div class=""> ``:code</div><div class=""> </div><div class=""> #### ``like``, ``regexp``, ``startswith``, ``contains``, ``upper``, ``lower``</div><div class=""> </div><div class=""> ``like``:inxx ``startswith``:inxx ``regexp``:inxx</div><div class=""> ``contains``:inxx ``upper``:inxx ``lower``:inxx</div><div class=""> </div><div class=""> Fields have a like operator that you can use to match strings:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db(db.log.event.like(&#x27;port%&#x27;)).select():</div><div class="">         print row.event</div><div class=""> port scan</div><div class=""> ``:code</div><div class=""> </div><div class=""> Here &quot;port%&quot; indicates a string starting with &quot;port&quot;. The percent sign character, &quot;%&quot;, is a wild-card character that means &quot;any sequence of characters&quot;.</div><div class=""> </div><div class="delete">The like operator is case<span class="highlight"> </span>ins<span class="highlight">i</span>sit<span class="highlight"></span>e but it can be made case<span class="highlight"> </span>sensitive with</div><div class=""> </div><div class=""> ``</div><div class=""> db.mytable.myfield.like(&#x27;value&#x27;,case_sensitive=True)</div><div class=""> ``:code</div><div class=""> </div><div class=""> </div><div class=""> web2py also provides some shortcuts:</div><div class=""> </div><div class=""> ``</div><div class=""> db.mytable.myfield.startswith(&#x27;value&#x27;)</div><div class=""> db.mytable.myfield.contains(&#x27;value&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> which are equivalent respectively to</div><div class=""> </div><div class=""> ``</div><div class=""> db.mytable.myfield.like(&#x27;value%&#x27;)</div><div class=""> db.mytable.myfield.like(&#x27;%value%&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> port scan</div><div class=""> xss injection</div><div class=""> ``:code</div><div class=""> </div><div class=""> The DAL also allows a nested select as the argument of the belongs operator. The only caveat is that the nested select has to be a ``_select``, not a ``select``, and only one field has to be selected explicitly, the one that defines the set.</div><div class=""> </div><div class=""> ``nested select``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; bad_days = db(db.log.severity==3)._select(db.log.event_time)</div><div class=""> &gt;&gt;&gt; for row in db(db.log.event_time.belongs(bad_days)).select():</div><div class="">         print row.event</div><div class=""> port scan</div><div class=""> xss injection</div><div class=""> unauthorized login</div><div class=""> ``:code</div><div class=""> </div><div class=""> In those cases where a nested select is required and the loop-up field is a reference we can also use a query as argument. For example:</div><div class=""> </div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;,Field(&#x27;name&#x27;))</div><div class=""> db.define_table(&#x27;thing&#x27;,Field(&#x27;owner&#x27;),Field(&#x27;owner&#x27;,&#x27;reference thing&#x27;))</div><div class="delete">db(db.thing.owner.belongs(db.person.name==&#x27;Jo<span class="highlight">h</span>nathan&#x27;)).select()</div><div class=""> ``:code</div><div class=""> </div><div class=""> In this case it is obvious that the next select only needs the field referenced by the ``db.thing.owner`` field so we do not need the more verbose ``_select`` notation.</div><div class=""> </div><div class=""> ``nested_select``:inxx</div><div class=""> </div><div class="delete">A nested select can also be used as insert/update value but in this case the sy<span class="highlight">m</span>tax is different:</div><div class=""> </div><div class=""> ``</div><div class=""> lazy = db(db.person.name==&#x27;Jonathan&#x27;).nested_select(db.person.id)</div><div class=""> db(db.thing.id==1).update(owner = lazy)</div><div class=""> ``:code</div><div class=""> </div><div class=""> In this case ``lazy`` is a nested expression that computes the ``id`` of person &quot;Jonathan&quot;. The two lines result in one single SQL query.</div><div class=""> </div><div class=""> #### ``sum``, ``avg``, ``min``, ``max`` and ``len``</div><div class=""> </div><div class=""> ``sum``:inxx ``avg``:inxx ``min``:inxx ``max``:inxx</div><div class=""> Previously, you have used the count operator to count records. Similarly, you can use the sum operator to add (sum) the values of a specific field from a group of records. As in the case of count, the result of a sum is retrieved via the store object:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; sum = db.log.severity.sum()</div><div class=""> &gt;&gt;&gt; print db().select(sum).first()[sum]</div><div class=""> 6</div><div class=""> ``:code</div><div class=""> </div><div class="delete">You can also use ``avg``, ``min``, and ``max`` to the average, mini<span class="highlight">n</span>um, and maximum value respectively for the selected records. For example:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; max = db.log.severity.max()</div><div class=""> &gt;&gt;&gt; print db().select(max).first()[max]</div><div class=""> 3</div><div class=""> ``:code</div><div class=""> </div><div class=""> ``.len()`` computes the length of a string, text or boolean fields.</div><div class=""> </div><div class=""> Expressions can be combined to form more complex expressions. For example here we are computing the sum of the length of all the severity strings in the logs, increased of one:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; sum = (db.log.severity.len()+1).sum()</div><div class=""> &gt;&gt;&gt; print db().select(sum).first()[sum]</div><div class=""> ``:code</div><div class=""> </div><div class=""> #### Substrings</div><div class=""> </div><div class=""> One can build an expression to refer to a substring. For example, we can group things whose name starts with the same three characters and select only one from each group:</div><div class=""> </div><div class=""> ``</div><div class="delete">db(db.thing).select(di<span class="highlight">c</span>tinct = db.thing.name[:3])</div><div class=""> ``:code</div><div class=""> </div><div class=""> </div><div class=""> #### Default values with ``coalesce`` and ``coalesce_zero``</div><div class=""> </div><div class=""> There are times when you need to pull a value from database but also need a default values if the value for a record is set to NULL. In SQL there is a keyword, ``COALESCE``, for this. web2py has an equivalent ``coalesce`` method:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;sysuser&#x27;,Field(&#x27;username&#x27;),Field(&#x27;fullname&#x27;))</div><div class=""> &gt;&gt;&gt; db.sysuser.insert(username=&#x27;max&#x27;,fullname=&#x27;Max Power&#x27;)</div><div class=""> &gt;&gt;&gt; db.sysuser.insert(username=&#x27;tim&#x27;,fullname=None)</div><div class=""> print db(db.sysuser).select(db.sysuser.fullname.coalesce(db.sysuser.username))</div><div class=""> &quot;COALESCE(sysuser.fullname,sysuser.username)&quot;</div><div class=""> Max Power</div><div class=""> tim</div><div class=""> ``</div><div class=""> </div><div class=""> Other times you need to compute a mathematical expression but some fields have a value set to None while it should be zero.</div><div class=""> ``coalesce_zero`` comes to the rescue by defaulting None to zero in the query:</div><div class=""> </div><div class=""> This is best explained via some examples.</div><div class=""> ``:code</div><div class=""> </div><div class=""> Here ``f`` is a dict of fields passed to insert or update, ``id`` is the id of the newly inserted record, ``s`` is the Set object used for update or delete.</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.person.insert(name=&#x27;John&#x27;)</div><div class=""> ({&#x27;name&#x27;: &#x27;John&#x27;},)</div><div class=""> ({&#x27;name&#x27;: &#x27;John&#x27;}, 1)</div><div class=""> &gt;&gt;&gt; db(db.person.id==1).update(name=&#x27;Tim&#x27;)</div><div class=""> (&lt;Set (person.id = 1)&gt;, {&#x27;name&#x27;: &#x27;Tim&#x27;})</div><div class=""> (&lt;Set (person.id = 1)&gt;, {&#x27;name&#x27;: &#x27;Tim&#x27;})</div><div class=""> &gt;&gt;&gt; db(db.person.id==1).delete()</div><div class=""> (&lt;Set (person.id = 1)&gt;,)</div><div class=""> (&lt;Set (person.id = 1)&gt;,)</div><div class=""> ``:code</div><div class=""> </div><div class=""> The return values of these callback should be ``None`` or ``False``. If any of the ``_before_*`` callback returns a ``True`` value it will abort the actual insert/update/delete operation.</div><div class=""> </div><div class=""> ``update_naive``:inxx.</div><div class=""> </div><div class="delete">Some times a callback may need to perform an update in the same of a different table an<span class="highlight">e</span> one wants to avoid callbacks calling themselves recursively.</div><div class=""> </div><div class=""> For this purpose there the Set objects have an ``update_naive`` method that works like ``update`` but ignores before and after callbacks.</div><div class=""> </div><div class=""> #### Record versioning </div><div class=""> </div><div class=""> ``_enable_record_versioning``:inxx</div><div class=""> </div><div class=""> It is possible to ask web2py to save every copy of a record when the record is modified. There are many ways to do it and it can be done for all tables at once using the ``auth.enable_record_versioning`` method, discussed in the chapter about authentication, or it can be done for each individual table as discussed here.</div><div class=""> </div><div class=""> Consider the following table:</div><div class=""> </div><div class=""> ``</div><div class=""> db.define_table(&#x27;stored_item&#x27;,</div><div class="">     Field(&#x27;name&#x27;),</div><div class="">     Field(&#x27;quantity&#x27;,&#x27;integer&#x27;),</div><div class="">     Field(&#x27;is_active&#x27;,&#x27;boolean&#x27;,</div><div class="">           writable=False,readable=False,default=True))</div><div class=""> ``:code</div><div class=""> </div><div class=""> Notice we the hidden boolean field called ``is_active`` and defaulting to </div><div class=""> True.</div><div class=""> </div><div class=""> We can tell web2py to create a new table (in the same or a different database) and store all previous versions of each record in the table, when modified.</div><div class=""> </div><div class=""> This is done in the following way:</div><div class=""> ``</div><div class=""> db.stored_item._enable_record_versioning()</div><div class=""> ``:code</div><div class=""> </div><div class=""> or in a more verbose syntax:</div><div class=""> </div><div class=""> ``</div><div class=""> db.stored_item._enable_record_versioning(</div><div class="">     archive_db = db,</div><div class="delete">    archive_name = &#x27;st<span class="highlight">r</span>ored_item_archive&#x27;,</div><div class="">     current_record = &#x27;current_record&#x27;,</div><div class="">     is_active = &#x27;is_active&#x27;)</div><div class=""> ``</div><div class=""> </div><div class="delete">The ``ar<span class="highlight">hc</span>ive_db=db`` tells web2py to store the archive table in the same database as the ``stored_item`` table. The ``archive_name`` sets the name for the ar<span class="highlight">v</span>chive table. The archive table has the same fields as the original table ``stored_item`` except that unique fields are no longer unique (because it needs to store multiple versions) and has an extra field which name is specified by ``current_record`` and which is a reference to the current record in the ``stored_item`` table.</div><div class=""> </div><div class="delete">When records are deleted, they are not really deleted. A deleted record is copied in the ``st<span class="highlight">r</span>ored_item_archive`` table (like when it is modified) and the ``is_active`` field is set to False. By enabling record versi<span class="highlight"></span>ning web2py sets a ``custom_filter`` on this table that hides all fields in table ``st<span class="highlight">r</span>ored_item`` where the ``is_active`` field is set to False. The ``is_active`` parameter in the ``_enable_record_versioning`` method allows to specify the name of the field used by the ``custom_filter`` to determine if the field was deleted or not.</div><div class=""> </div><div class=""> ``custom_filter``s are ignored by the appadmin interface.</div><div class=""> </div><div class=""> #### Common fields and multi-tenancy</div><div class=""> ``common fields``:inxx</div><div class=""> ``multi tenancy``:inxx</div><div class=""> </div><div class=""> ``db._common_fields`` is a list of fields that should belong to all the tables. This list can also contain tables and it it is understood as all fields from the table. For example occasionally you find yourself in need to add a signature to all your tables but the ```auth`` tables. In this case, after you ``db.define_tables()`` but before defining any other table, insert</div><div class=""> </div><div class=""> ``</div><div class=""> db._common_fields.append(auth.signature)</div><div class=""> ``</div><div class=""> </div><div class=""> One field is special: &quot;request_tenant&quot;.</div><div class=""> This field does not exist but you can create it and add it to any of your tables (or them all):</div><div class=""> </div><div class=""> ``</div><div class=""> db._common_fields.append(Field(&#x27;request_tenant&#x27;,</div><div class="">     default=request.env.http_host,writable=False))</div><div class=""> ``</div><div class=""> The file &quot;gluon/dal.py&quot; defines, among other, the following classes.</div><div class=""> </div><div class=""> ``</div><div class=""> ConnectionPool</div><div class=""> BaseAdapter extends ConnectionPool</div><div class=""> Row</div><div class=""> DAL</div><div class=""> Reference</div><div class=""> Table</div><div class=""> Expression</div><div class=""> Field</div><div class=""> Query</div><div class=""> Set</div><div class=""> Rows</div><div class=""> ``</div><div class=""> </div><div class=""> Their use has been explained in the previous sections, except for ``BaseAdapter``. When the methods of a ``Table`` or ``Set`` object need to communicate with the database they delegate to methods of the adapter the task to generate the SQL and or the function call.</div><div class=""> </div><div class=""> For example:</div><div class=""> </div><div class=""> ``</div><div class="delete">db.my<span class="highlight"></span>able.insert(myfield=&#x27;myvalue&#x27;)</div><div class=""> ``</div><div class=""> </div><div class=""> calls</div><div class=""> </div><div class=""> ``</div><div class=""> Table.insert(myfield=&#x27;myvalue&#x27;)</div><div class=""> ``</div><div class=""> </div><div class=""> which delegates the adapter by returning:</div><div class=""> </div><div class=""> ``</div><div class=""> db._adapter.insert(db.mytable,db.mytable._listify(dict(myfield=&#x27;myvalue&#x27;)))</div><div class=""> ``</div><div class=""> </div><div class=""> Here ``db.mytable._listify`` converts the dict of arguments into a list of ``(field,value)`` and calls the ``insert`` method of the ``adapter``. ``db._adapter`` does more or less the following:</div><div class=""> </div><div class=""> ``</div><div class=""> query = db._adapter._insert(db.mytable,list_of_fields)</div><div class=""> db._adapter.execute(query)</div><div class=""> ``</div><div class=""> MySQLAdapter.driver = mysqldb</div><div class=""> ``</div><div class=""> </div><div class=""> and you can specify optional driver arguments and adapter arguments:</div><div class=""> </div><div class=""> ``</div><div class=""> db =DAL(..., driver_args={}, adapter_args={})</div><div class=""> ``</div><div class=""> </div><div class=""> </div><div class=""> #### Gotchas</div><div class=""> </div><div class=""> **SQLite** does not support dropping and altering columns. That means that web2py migrations will work up to a point. If you delete a field from a table, the column will remain in the database but be invisible to web2py. If you decide to reinstate the column, web2py will try re-create it and fail. In this case you must set ``fake_migrate=True`` so that metadata is rebuilt without attempting to add the column again. Also, for the same reason, **SQLite** is not aware of any change of column type. If you insert a number in a string field, it will be stored as string. If you later change the model and replace the type &quot;string&quot; with type &quot;integer&quot;, SQLite will continue to keep the number as a string and this may cause problem when you try to extract the data.</div><div class=""> </div><div class=""> **MySQL** does not support multiple ALTER TABLE within a single transaction. This means that any migration process is broken into multiple commits. If something happens that causes a failure it is possible to break a migration (the web2py metadata are no longer in sync with the actual table structure in the database). This is unfortunate but it can be prevented (migrate one table at the time) or it can be fixed a posteriori (revert the web2py model to what corresponds to the table structure in database, set ``fake_migrate=True`` and after the metadata has been rebuilt, set ``fake_migrate=False`` and migrate the table again).</div><div class=""> </div><div class=""> **Google SQL** has the same problems as MySQL and more. In particular table metadata itself must be stored in the database in a table that is not migrated by web2py. This is because Google App Engine has a readonly file system. Web2py migrations in Google:SQL combined with the MySQL issue described above can result in metadata corruption. Again, this can be prevented (my migrating the table at once and then setting migrate=False so that the metadata table is not accessed any more) or it can fixed a posteriori (my accessing the database using the Google dashboard and deleting any corrupted entry from the table called ``web2py_filesystem``.</div><div class=""> </div><div class=""> ``limitby``:inxx</div><div class=""> **MSSQL** does not support the SQL OFFSET keyword. Therefore the database cannot do pagination. When doing a ``limitby=(a,b)`` web2py will fetch the first ``b`` rows and discard the first the ``a``. This may result in a considerable overhead when compared with other database engines.</div><div class=""> </div><div class="delete">**Oracle** also does not support pagination. It does not support neither the OFFSET nor the LIMIT keywords. Web2py achieves pagination by translating a ``db(...).select(limitby=(a,b))`` into a complex three-way nested select (as suggested by official Oracle documentation). This works for simple select but may break for complex selects involving ali<span class="highlight"></span>sed fields and or joins.</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/189c12f17f3e21b5a8782723a2e75a89c8342098">189c12f</a><ul><li>Date : 2012-09-04</li><li>fixed bugs and added scheduler info, thanks Niphlod</li></ul></li></ul>
<div class="row-fluid" id="com_189c12f17f3e21b5a8782723a2e75a89c8342098">
    <div class="span6"><div class="diff"><div class="insert">#### ``filter_in`` and `<span class="highlight">`</span>filter_out``</div><div class=""> ``filter_in``:inxx ``filter_out``:inxx</div></div></div>
    <div class="span6"><div class="diff"><div class="delete">#### ``filter_in`` and `<span class="highlight"></span>filter_out``</div><div class=""> ``filter_in``:inxx ``filter_out``:inxx</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/7f182418fe4935588e8d4183dcf4fd351c6ca92b">7f18241</a><ul><li>Date : 2012-09-03</li><li>added db.table_enable_record_versioning</li></ul></li></ul>
<div class="row-fluid" id="com_7f182418fe4935588e8d4183dcf4fd351c6ca92b">
    <div class="span6"><div class="diff"><div class="insert">+#### ``filter_in`` and `filter_out``</div><div class="insert">+``filter_in``:inxx ``filter_out``:inxx</div><div class="insert">+</div><div class="insert">+It is possible to define a filter for each field to be called before a value is inserted into the database for that field and after a value is retrieved from the database. </div><div class="insert">+</div><div class="insert">+Imagine for example that you want to store a serializable Python data structure in a field in the json format. Here is how it could be accomplished:</div><div class="insert">+</div><div class="insert">+``</div><div class="insert">+&gt;&gt;&gt; from simplejson import loads, dumps</div><div class="insert">+&gt;&gt;&gt; db.define_table(&#x27;anyobj&#x27;,Field(&#x27;name&#x27;),Field(&#x27;data&#x27;,&#x27;text&#x27;))</div><div class="insert">+&gt;&gt;&gt; db.anyobj.data.filter_in = lambda obj, dumps=dumps: dumps(obj)</div><div class="insert">+&gt;&gt;&gt; db.anyobj.data.filter_out = lambda txt, loads=loads: loads(txt)</div><div class="insert">+&gt;&gt;&gt; myobj = [&#x27;hello&#x27;, &#x27;world&#x27;, 1, {2: 3}]</div><div class="insert">+&gt;&gt;&gt; id = db.anyobj.insert(name=&#x27;myobjname&#x27;, data=myobj)</div><div class="insert">+&gt;&gt;&gt; row = db.anyobj(id)</div><div class="insert">+&gt;&gt;&gt; row.data</div><div class="insert">+[&#x27;hello&#x27;, &#x27;world&#x27;, 1, {2: 3}] </div><div class="insert">+``:code</div><div class="insert">+</div><div class="insert">+Another way to accomplish the same is by using a Field of type ``SQLCustomType``, as discussed later.</div><div class="insert">+</div><div class=""> #### before and after callbacks</div><div class=""> </div><div class=""> ``_before_insert``:inxx</div><div class=""> ``_after_insert``:inxx</div><div class=""> ``_before_update``:inxx</div><div class=""> ``_after_update``:inxx</div><div class=""> ``_before_delete``:inxx</div><div class=""> ``_after_delete``:inxx</div><div class=""> </div><div class=""> Web2py provides a mechanism to register callbacks to be called before and/or after insert, update and delete of records.</div><div class=""> </div><div class=""> Each table stores six lists of callbacks:</div><div class=""> </div><div class=""> ``</div><div class=""> db.mytable._before_insert</div><div class=""> db.mytable._after_insert</div><div class=""> db.mytable._before_update</div><div class=""> db.mytable._after_update</div><div class=""> db.mytable._before_delete</div><div class=""> db.mytable._after_delete</div><div class=""> Here ``f`` is a dict of fields passed to insert or update, ``id`` is the id of t</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.person.insert(name=&#x27;John&#x27;)</div><div class=""> ({&#x27;name&#x27;: &#x27;John&#x27;},)</div><div class=""> ({&#x27;name&#x27;: &#x27;John&#x27;}, 1)</div><div class=""> &gt;&gt;&gt; db(db.person.id==1).update(name=&#x27;Tim&#x27;)</div><div class=""> (&lt;Set (person.id = 1)&gt;, {&#x27;name&#x27;: &#x27;Tim&#x27;})</div><div class=""> (&lt;Set (person.id = 1)&gt;, {&#x27;name&#x27;: &#x27;Tim&#x27;})</div><div class=""> &gt;&gt;&gt; db(db.person.id==1).delete()</div><div class=""> (&lt;Set (person.id = 1)&gt;,)</div><div class=""> (&lt;Set (person.id = 1)&gt;,)</div><div class=""> ``:code</div><div class=""> </div><div class=""> The return values of these callback should be ``None`` or ``False``. If any of the ``_before_*`` callback returns a ``True`` value it will abort the actual insert/update/delete operation.</div><div class=""> </div><div class=""> ``update_naive``:inxx.</div><div class=""> </div><div class=""> Some times a callback may need to perform an update in the same of a different table ane one wants to avoid callbacks calling themselves recursively.</div><div class=""> </div><div class=""> For this purpose there the Set objects have an ``update_naive`` method that works like ``update`` but ignores before and after callbacks.</div><div class=""> </div><div class="insert">+#### Record versioning </div><div class="insert">+</div><div class="insert">+``_enable_record_versioning``:inxx</div><div class="insert">+</div><div class="insert">+It is possible to ask web2py to save every copy of a record when the record is modified. There are many ways to do it and it can be done for all tables at once using the ``auth.enable_record_versioning`` method, discussed in the chapter about authentication, or it can be done for each individual table as discussed here.</div><div class="insert">+</div><div class="insert">+Consider the following table:</div><div class="insert">+</div><div class="insert">+``</div><div class="insert">+db.define_table(&#x27;stored_item&#x27;,</div><div class="insert">+    Field(&#x27;name&#x27;),</div><div class="insert">+    Field(&#x27;quantity&#x27;,&#x27;integer&#x27;),</div><div class="insert">+    Field(&#x27;is_active&#x27;,&#x27;boolean&#x27;,</div><div class="insert">+          writable=False,readable=False,default=True))</div><div class="insert">+``:code</div><div class="insert">+</div><div class="insert">+Notice we the hidden boolean field called ``is_active`` and defaulting to </div><div class="insert">+True.</div><div class="insert">+</div><div class="insert">+We can tell web2py to create a new table (in the same or a different database) and store all previous versions of each record in the table, when modified.</div><div class="insert">+</div><div class="insert">+This is done in the following way:</div><div class="insert">+``</div><div class="insert">+db.stored_item._enable_record_versioning()</div><div class="insert">+``:code</div><div class="insert">+</div><div class="insert">+or in a more verbose syntax:</div><div class="insert">+</div><div class="insert">+``</div><div class="insert">+db.stored_item._enable_record_versioning(</div><div class="insert">+    archive_db = db,</div><div class="insert">+    archive_name = &#x27;strored_item_archive&#x27;,</div><div class="insert">+    current_record = &#x27;current_record&#x27;,</div><div class="insert">+    is_active = &#x27;is_active&#x27;)</div><div class="insert">+``</div><div class="insert">+</div><div class="insert">+The ``arhcive_db=db`` tells web2py to store the archive table in the same database as the ``stored_item`` table. The ``archive_name`` sets the name for the arvchive table. The archive table has the same fields as the original table ``stored_item`` except that unique fields are no longer unique (because it needs to store multiple versions) and has an extra field which name is specified by ``current_record`` and which is a reference to the current record in the ``stored_item`` table.</div><div class="insert">+</div><div class="insert">+When records are deleted, they are not really deleted. A deleted record is copied in the ``strored_item_archive`` table (like when it is modified) and the ``is_active`` field is set to False. By enabling record versining web2py sets a ``custom_filter`` on this table that hides all fields in table ``strored_item`` where the ``is_active`` field is set to False. The ``is_active`` parameter in the ``_enable_record_versioning`` method allows to specify the name of the field used by the ``custom_filter`` to determine if the field was deleted or not.</div><div class="insert">+</div><div class="insert">+``custom_filter``s are ignored by the appadmin interface.</div><div class="insert">+</div><div class=""> #### Common fields and multi-tenancy</div><div class=""> ``common fields``:inxx</div><div class=""> ``multi tenancy``:inxx</div></div></div>
    <div class="span6"><div class="diff"><div class=""> #### before and after callbacks</div><div class=""> </div><div class=""> ``_before_insert``:inxx</div><div class=""> ``_after_insert``:inxx</div><div class=""> ``_before_update``:inxx</div><div class=""> ``_after_update``:inxx</div><div class=""> ``_before_delete``:inxx</div><div class=""> ``_after_delete``:inxx</div><div class=""> </div><div class=""> Web2py provides a mechanism to register callbacks to be called before and/or after insert, update and delete of records.</div><div class=""> </div><div class=""> Each table stores six lists of callbacks:</div><div class=""> </div><div class=""> ``</div><div class=""> db.mytable._before_insert</div><div class=""> db.mytable._after_insert</div><div class=""> db.mytable._before_update</div><div class=""> db.mytable._after_update</div><div class=""> db.mytable._before_delete</div><div class=""> db.mytable._after_delete</div><div class=""> Here ``f`` is a dict of fields passed to insert or update, ``id`` is the id of t</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.person.insert(name=&#x27;John&#x27;)</div><div class=""> ({&#x27;name&#x27;: &#x27;John&#x27;},)</div><div class=""> ({&#x27;name&#x27;: &#x27;John&#x27;}, 1)</div><div class=""> &gt;&gt;&gt; db(db.person.id==1).update(name=&#x27;Tim&#x27;)</div><div class=""> (&lt;Set (person.id = 1)&gt;, {&#x27;name&#x27;: &#x27;Tim&#x27;})</div><div class=""> (&lt;Set (person.id = 1)&gt;, {&#x27;name&#x27;: &#x27;Tim&#x27;})</div><div class=""> &gt;&gt;&gt; db(db.person.id==1).delete()</div><div class=""> (&lt;Set (person.id = 1)&gt;,)</div><div class=""> (&lt;Set (person.id = 1)&gt;,)</div><div class=""> ``:code</div><div class=""> </div><div class=""> The return values of these callback should be ``None`` or ``False``. If any of the ``_before_*`` callback returns a ``True`` value it will abort the actual insert/update/delete operation.</div><div class=""> </div><div class=""> ``update_naive``:inxx.</div><div class=""> </div><div class=""> Some times a callback may need to perform an update in the same of a different table ane one wants to avoid callbacks calling themselves recursively.</div><div class=""> </div><div class=""> For this purpose there the Set objects have an ``update_naive`` method that works like ``update`` but ignores before and after callbacks.</div><div class=""> </div><div class=""> #### Common fields and multi-tenancy</div><div class=""> ``common fields``:inxx</div><div class=""> ``multi tenancy``:inxx</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/fe2d532209d3ced4b9b5d8b72c52e588b4338d9e">fe2d532</a><ul><li>Date : 2012-09-03</li><li>updated description of executesql, thanks Anthony</li></ul></li></ul>
<div class="row-fluid" id="com_fe2d532209d3ced4b9b5d8b72c52e588b4338d9e">
    <div class="span6"><div class="diff"><div class="insert">+``executesql`` have two optional argumens: ``fields`` and ``colnames``.</div><div class="insert">+</div><div class="insert">+The ``fields`` argument is a list of DAL Field objects that match the                    </div><div class="insert">+fields returned from the DB. The Field objects should be part of one or                </div><div class="insert">+more Table objects defined on the DAL object. The ``fields`` list can                    </div><div class="insert">+include one or more DAL Table objects in addition to or instead of                     </div><div class="insert">+including Field objects, or it can be just a single table (not in a                    </div><div class="insert">+list). In that case, the Field objects will be extracted from the                      </div><div class="insert">+table(s).                                                                              </div><div class="insert">+                                                                                               </div><div class="insert">+Instead of specifying the ``fields`` argument, the ``colnames`` argument                   </div><div class="insert">+can be specified as a list of field names in tablename.fieldname format.               </div><div class="insert">+Again, these should represent tables and fields defined on the DAL                     </div><div class="insert">+object.                                                                                </div><div class="insert">+       </div><div class="insert">+It is also possible to specify both ``fields`` and the associated</div><div class="insert">+``colnames``. In that case, ``fields`` can also include DAL Expression     </div><div class="insert">+objects in addition to Field objects. For Field objects in &quot;fields&quot;,   </div><div class="insert">+the associated ``colnames`` must still be in tablename.fieldname format. </div><div class="insert">+For Expression objects in ``fields``, the associated ``colnames`` can      </div><div class="insert">+be any arbitrary labels.       </div><div class="insert">+       </div><div class="insert">+Notice, the DAL Table objects referred to by ``fields`` or ``colnames`` can  </div><div class="insert">+be dummy tables and do not have to represent any real tables in the    </div><div class="insert">+database. Also, note that the ``fields`` and ``colnames`` must be in the   </div><div class="insert">+same order as the fields in the results cursor returned from the DB. </div><div class="insert">+</div></div></div>
    <div class="span6"><div class="diff"><div class="delete">-executesql have an optional ``fields`` argument.</div><div class="delete">-If not None, the   </div><div class="delete">-results cursor returned by the DB driver will be converted to a            </div><div class="delete">-DAL Rows object using the ``db._adapter.parse()`` method. This requires        </div><div class="delete">-specifying the &quot;fields&quot; argument as a list of DAL Field objects            </div><div class="delete">-that match the fields returned from the DB. The Field objects should       </div><div class="delete">-be part of one or more Table objects defined on the DAL object.            </div><div class="delete">-        </div><div class="delete">-The ``fields`` list can include one or more DAL Table objects in addition    </div><div class="delete">-to or instead of including Field objects, or it can be just a single       </div><div class="delete">-table (not in a list). In that case, the Field objects will be             </div><div class="delete">-extracted from the table(s).</div><div class="delete">-</div><div class="delete">-The field names will be extracted from the Field objects, or optionally,</div><div class="delete">-a list of field names can be provided (in tablename.fieldname format)      </div><div class="delete">-via the ``colnames`` argument. Note, the fields and colnames must be in      </div><div class="delete">-the same order as the fields in the results cursor returned from the DB.</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/be8da74855713dabb0c2a0a05a7d67002ace209b">be8da74</a><ul><li>Date : 2012-09-02</li><li>more examples</li></ul></li></ul>
<div class="row-fluid" id="com_be8da74855713dabb0c2a0a05a7d67002ace209b">
    <div class="span6"><div class="diff"><div class="insert">+</div><div class=""> ### Other methods</div><div class=""> </div><div class=""> #### ``update_or_insert``</div><div class=""> ``update_or_insert``:inxx</div><div class=""> </div><div class=""> Some times you need to perform an insert only if there is no record with the same values as those being inserted.</div><div class=""> This can be done with</div><div class=""> </div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;,Field(&#x27;name&#x27;),Field(&#x27;birthplace&#x27;))</div><div class=""> db.person.update_or_insert(name=&#x27;John&#x27;,birthplace=&#x27;Chicago&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> The record will be inserted only of there is no other user called John born in Chicago.</div><div class=""> </div><div class=""> You can specify which values to use as a key to determine if the record exists. For example:</div><div class=""> ``</div><div class=""> db.person.update_or_insert(db.person.name==&#x27;John&#x27;,</div><div class="">      name=&#x27;John&#x27;,birthplace=&#x27;Chicago&#x27;)</div><div class=""> ``:code</div><div class=""> xss injection</div><div class=""> ``:code</div><div class=""> </div><div class=""> The DAL also allows a nested select as the argument of the belongs operator. The only caveat is that the nested select has to be a ``_select``, not a ``select``, and only one field has to be selected explicitly, the one that defines the set.</div><div class=""> </div><div class=""> ``nested select``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; bad_days = db(db.log.severity==3)._select(db.log.event_time)</div><div class=""> &gt;&gt;&gt; for row in db(db.log.event_time.belongs(bad_days)).select():</div><div class="">         print row.event</div><div class=""> port scan</div><div class=""> xss injection</div><div class=""> unauthorized login</div><div class=""> ``:code</div><div class=""> </div><div class=""> In those cases where a nested select is required and the loop-up field is a reference we can also use a query as argument. For example:</div><div class=""> </div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;,Field(&#x27;name&#x27;))</div><div class=""> db.define_table(&#x27;thing&#x27;,Field(&#x27;owner&#x27;),Field(&#x27;owner&#x27;,&#x27;reference thing&#x27;))</div><div class=""> db(db.thing.owner.belongs(db.person.name==&#x27;Johnathan&#x27;)).select()</div><div class="insert">``:c<span class="highlight">od</span>e</div><div class=""> </div><div class=""> In this case it is obvious that the next select only needs the field referenced by the ``db.thing.owner`` field so we do not need the more verbose ``_select`` notation.</div><div class=""> </div><div class="insert">+``nested_select``:inxx</div><div class="insert">+</div><div class="insert">+A nested select can also be used as insert/update value but in this case the symtax is different:</div><div class="insert">+</div><div class="insert">+``</div><div class="insert">+lazy = db(db.person.name==&#x27;Jonathan&#x27;).nested_select(db.person.id)</div><div class="insert">+db(db.thing.id==1).update(owner = lazy)</div><div class="insert">+``:code</div><div class="insert">+</div><div class="insert">+In this case ``lazy`` is a nested expression that computes the ``id`` of person &quot;Jonathan&quot;. The two lines result in one single SQL query.</div><div class="insert">+</div><div class=""> #### ``sum``, ``avg``, ``min``, ``max`` and ``len``</div><div class=""> </div><div class=""> ``sum``:inxx ``avg``:inxx ``min``:inxx ``max``:inxx</div><div class=""> Previously, you have used the count operator to count records. Similarly, you can use the sum operator to add (sum) the values of a specific field from a group of records. As in the case of count, the result of a sum is retrieved via the store object:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; sum = db.log.severity.sum()</div><div class=""> &gt;&gt;&gt; print db().select(sum).first()[sum]</div><div class=""> 6</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can also use ``avg``, ``min``, and ``max`` to the average, mininum, and maximum value respectively for the selected records. For example:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; max = db.log.severity.max()</div><div class=""> &gt;&gt;&gt; print db().select(max).first()[max]</div><div class=""> 3</div><div class=""> ``:code</div><div class=""> </div><div class=""> ``.len()`` computes the length of a string, text or boolean fields.</div><div class=""> </div><div class=""> It is also possible to define a dummy table that is not stored in a database in</div><div class=""> signature = db.Table(db, &#x27;signature&#x27;,</div><div class="">     Field(&#x27;created_on&#x27;, &#x27;datetime&#x27;, default=request.now),</div><div class="">     Field(&#x27;created_by&#x27;, db.auth_user, default=auth.user_id),</div><div class="">     Field(&#x27;updated_on&#x27;, &#x27;datetime&#x27;, update=request.now),</div><div class="">     Field(&#x27;updated_by&#x27;, db.auth_user, update=auth.user_id))</div><div class=""> </div><div class=""> db.define_table(&#x27;payment&#x27;, Field(&#x27;amount&#x27;, &#x27;double&#x27;), signature)</div><div class=""> ``:code</div><div class=""> </div><div class=""> This example assumes that standard web2py authentication is enabled.</div><div class=""> </div><div class=""> Notice that if you user ``Auth`` web2py already creates one such table for you:</div><div class=""> </div><div class=""> ``</div><div class=""> auth = Auth(db)</div><div class=""> db.define_table(&#x27;payment&#x27;, Field(&#x27;amount&#x27;, &#x27;double&#x27;), auth.signature)</div><div class=""> ``</div><div class=""> </div><div class=""> When using table inheritance, if you want the inheriting table to inherit validators, be sure to define the validators of the parent table before defining the inheriting table.</div><div class=""> </div><div class="insert">+#### before and after callbacks</div><div class="insert">+</div><div class="insert">+``_before_insert``:inxx</div><div class="insert">+``_after_insert``:inxx</div><div class="insert">+``_before_update``:inxx</div><div class="insert">+``_after_update``:inxx</div><div class="insert">+``_before_delete``:inxx</div><div class="insert">+``_after_delete``:inxx</div><div class="insert">+</div><div class="insert">+Web2py provides a mechanism to register callbacks to be called before and/or after insert, update and delete of records.</div><div class="insert">+</div><div class="insert">+Each table stores six lists of callbacks:</div><div class="insert">+</div><div class="insert">+``</div><div class="insert">+db.mytable._before_insert</div><div class="insert">+db.mytable._after_insert</div><div class="insert">+db.mytable._before_update</div><div class="insert">+db.mytable._after_update</div><div class="insert">+db.mytable._before_delete</div><div class="insert">+db.mytable._after_delete</div><div class="insert">+``:code</div><div class="insert">+</div><div class="insert">+You can register callback function by appending it the corresponding function to one of those lists. The caveat is that depending on the functionality, the callback has different signature.</div><div class="insert">+</div><div class="insert">+This is best explained via some examples.</div><div class="insert">+</div><div class="insert">+``</div><div class="insert">+&gt;&gt;&gt; db.define_table(&#x27;person&#x27;,Field(&#x27;name&#x27;))</div><div class="insert">+&gt;&gt;&gt; def pprint(*args): print args</div><div class="insert">+&gt;&gt;&gt; db.person._before_insert.append(lambda f: pprint(f))</div><div class="insert">+&gt;&gt;&gt; db.person._after_insert.append(lambda f,id: pprint(f,id))</div><div class="insert">+&gt;&gt;&gt; db.person._before_update.append(lambda s,f: pprint(s,f))</div><div class="insert">+&gt;&gt;&gt; db.person._after_update.append(lambda s,f: pprint(s,f))</div><div class="insert">+&gt;&gt;&gt; db.person._before_delete.append(lambda s: pprint(s))</div><div class="insert">+&gt;&gt;&gt; db.person._after_delete.append(lambda s: pprint(s))</div><div class="insert">+``:code</div><div class="insert">+</div><div class="insert">+Here ``f`` is a dict of fields passed to insert or update, ``id`` is the id of the newly inserted record, ``s`` is the Set object used for update or delete.</div><div class="insert">+</div><div class="insert">+``</div><div class="insert">+&gt;&gt;&gt; db.person.insert(name=&#x27;John&#x27;)</div><div class="insert">+({&#x27;name&#x27;: &#x27;John&#x27;},)</div><div class="insert">+({&#x27;name&#x27;: &#x27;John&#x27;}, 1)</div><div class="insert">+&gt;&gt;&gt; db(db.person.id==1).update(name=&#x27;Tim&#x27;)</div><div class="insert">+(&lt;Set (person.id = 1)&gt;, {&#x27;name&#x27;: &#x27;Tim&#x27;})</div><div class="insert">+(&lt;Set (person.id = 1)&gt;, {&#x27;name&#x27;: &#x27;Tim&#x27;})</div><div class="insert">+&gt;&gt;&gt; db(db.person.id==1).delete()</div><div class="insert">+(&lt;Set (person.id = 1)&gt;,)</div><div class="insert">+(&lt;Set (person.id = 1)&gt;,)</div><div class="insert">+``:code</div><div class="insert">+</div><div class="insert">+The return values of these callback should be ``None`` or ``False``. If any of the ``_before_*`` callback returns a ``True`` value it will abort the actual insert/update/delete operation.</div><div class="insert">+</div><div class="insert">+``update_naive``:inxx.</div><div class="insert">+</div><div class="insert">+Some times a callback may need to perform an update in the same of a different table ane one wants to avoid callbacks calling themselves recursively.</div><div class="insert">+</div><div class="insert">+For this purpose there the Set objects have an ``update_naive`` method that works like ``update`` but ignores before and after callbacks.</div><div class="insert">+</div><div class=""> #### Common fields and multi-tenancy</div><div class=""> ``common fields``:inxx</div><div class=""> ``multi tenancy``:inxx</div></div></div>
    <div class="span6"><div class="diff"><div class=""> ### Other methods</div><div class=""> </div><div class=""> #### ``update_or_insert``</div><div class=""> ``update_or_insert``:inxx</div><div class=""> </div><div class=""> Some times you need to perform an insert only if there is no record with the same values as those being inserted.</div><div class=""> This can be done with</div><div class=""> </div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;,Field(&#x27;name&#x27;),Field(&#x27;birthplace&#x27;))</div><div class=""> db.person.update_or_insert(name=&#x27;John&#x27;,birthplace=&#x27;Chicago&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> The record will be inserted only of there is no other user called John born in Chicago.</div><div class=""> </div><div class=""> You can specify which values to use as a key to determine if the record exists. For example:</div><div class=""> ``</div><div class=""> db.person.update_or_insert(db.person.name==&#x27;John&#x27;,</div><div class="">      name=&#x27;John&#x27;,birthplace=&#x27;Chicago&#x27;)</div><div class=""> ``:code</div><div class=""> xss injection</div><div class=""> ``:code</div><div class=""> </div><div class=""> The DAL also allows a nested select as the argument of the belongs operator. The only caveat is that the nested select has to be a ``_select``, not a ``select``, and only one field has to be selected explicitly, the one that defines the set.</div><div class=""> </div><div class=""> ``nested select``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; bad_days = db(db.log.severity==3)._select(db.log.event_time)</div><div class=""> &gt;&gt;&gt; for row in db(db.log.event_time.belongs(bad_days)).select():</div><div class="">         print row.event</div><div class=""> port scan</div><div class=""> xss injection</div><div class=""> unauthorized login</div><div class=""> ``:code</div><div class=""> </div><div class=""> In those cases where a nested select is required and the loop-up field is a reference we can also use a query as argument. For example:</div><div class=""> </div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;,Field(&#x27;name&#x27;))</div><div class=""> db.define_table(&#x27;thing&#x27;,Field(&#x27;owner&#x27;),Field(&#x27;owner&#x27;,&#x27;reference thing&#x27;))</div><div class=""> db(db.thing.owner.belongs(db.person.name==&#x27;Johnathan&#x27;)).select()</div><div class="delete">``:c<span class="highlight">it</span>e</div><div class=""> </div><div class=""> In this case it is obvious that the next select only needs the field referenced by the ``db.thing.owner`` field so we do not need the more verbose ``_select`` notation.</div><div class=""> </div><div class=""> #### ``sum``, ``avg``, ``min``, ``max`` and ``len``</div><div class=""> </div><div class=""> ``sum``:inxx ``avg``:inxx ``min``:inxx ``max``:inxx</div><div class=""> Previously, you have used the count operator to count records. Similarly, you can use the sum operator to add (sum) the values of a specific field from a group of records. As in the case of count, the result of a sum is retrieved via the store object:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; sum = db.log.severity.sum()</div><div class=""> &gt;&gt;&gt; print db().select(sum).first()[sum]</div><div class=""> 6</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can also use ``avg``, ``min``, and ``max`` to the average, mininum, and maximum value respectively for the selected records. For example:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; max = db.log.severity.max()</div><div class=""> &gt;&gt;&gt; print db().select(max).first()[max]</div><div class=""> 3</div><div class=""> ``:code</div><div class=""> </div><div class=""> ``.len()`` computes the length of a string, text or boolean fields.</div><div class=""> </div><div class=""> It is also possible to define a dummy table that is not stored in a database in</div><div class=""> signature = db.Table(db, &#x27;signature&#x27;,</div><div class="">     Field(&#x27;created_on&#x27;, &#x27;datetime&#x27;, default=request.now),</div><div class="">     Field(&#x27;created_by&#x27;, db.auth_user, default=auth.user_id),</div><div class="">     Field(&#x27;updated_on&#x27;, &#x27;datetime&#x27;, update=request.now),</div><div class="">     Field(&#x27;updated_by&#x27;, db.auth_user, update=auth.user_id))</div><div class=""> </div><div class=""> db.define_table(&#x27;payment&#x27;, Field(&#x27;amount&#x27;, &#x27;double&#x27;), signature)</div><div class=""> ``:code</div><div class=""> </div><div class=""> This example assumes that standard web2py authentication is enabled.</div><div class=""> </div><div class=""> Notice that if you user ``Auth`` web2py already creates one such table for you:</div><div class=""> </div><div class=""> ``</div><div class=""> auth = Auth(db)</div><div class=""> db.define_table(&#x27;payment&#x27;, Field(&#x27;amount&#x27;, &#x27;double&#x27;), auth.signature)</div><div class=""> ``</div><div class=""> </div><div class=""> When using table inheritance, if you want the inheriting table to inherit validators, be sure to define the validators of the parent table before defining the inheriting table.</div><div class=""> </div><div class=""> #### Common fields and multi-tenancy</div><div class=""> ``common fields``:inxx</div><div class=""> ``multi tenancy``:inxx</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/9e10b63ca42973fcccba175ef95076d74f292d1b">9e10b63</a><ul><li>Date : 2012-09-01</li><li>router patch, thanks Jonathan</li></ul></li></ul>
<div class="row-fluid" id="com_9e10b63ca42973fcccba175ef95076d74f292d1b">
    <div class="span6"><div class="diff"><div class="insert">+The ``find`` method as an optional limitby argument with the same syntax and functionality as the Set select ``method``.</div><div class="insert">+</div><div class=""> </div><div class=""> ### Other methods</div><div class=""> </div><div class=""> #### ``update_or_insert``</div><div class=""> ``update_or_insert``:inxx</div><div class=""> </div><div class=""> Some times you need to perform an insert only if there is no record with the same values as those being inserted.</div><div class=""> This can be done with</div><div class=""> </div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;,Field(&#x27;name&#x27;),Field(&#x27;birthplace&#x27;))</div><div class=""> db.person.update_or_insert(name=&#x27;John&#x27;,birthplace=&#x27;Chicago&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> The record will be inserted only of there is no other user called John born in Chicago.</div><div class=""> </div><div class=""> You can specify which values to use as a key to determine if the record exists. For example:</div><div class=""> ``</div><div class=""> db.person.update_or_insert(db.person.name==&#x27;John&#x27;,</div><div class="">      name=&#x27;John&#x27;,birthplace=&#x27;Chicago&#x27;)</div><div class=""> xss injection</div><div class=""> The DAL also allows a nested select as the argument of the belongs operator. The only caveat is that the nested select has to be a ``_select``, not a ``select``, and only one field has to be selected explicitly, the one that defines the set.</div><div class=""> </div><div class=""> ``nested select``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; bad_days = db(db.log.severity==3)._select(db.log.event_time)</div><div class=""> &gt;&gt;&gt; for row in db(db.log.event_time.belongs(bad_days)).select():</div><div class="">         print row.event</div><div class=""> port scan</div><div class=""> xss injection</div><div class=""> unauthorized login</div><div class=""> ``:code</div><div class=""> </div><div class=""> In those cases where a nested select is required and the loop-up field is a reference we can also use a query as argument. For example:</div><div class=""> </div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;,Field(&#x27;name&#x27;))</div><div class=""> db.define_table(&#x27;thing&#x27;,Field(&#x27;owner&#x27;),Field(&#x27;owner&#x27;,&#x27;reference thing&#x27;))</div><div class=""> db(db.thing.owner.belongs(db.person.name==&#x27;Johnathan&#x27;)).select()</div><div class=""> ``:cite</div><div class=""> </div><div class="insert">In this case it is obvious that the next select only needs the field referenced by the ``db.thing.owner`<span class="highlight">`</span> field so we do not need the more verbose ``_select`` notation.</div></div></div>
    <div class="span6"><div class="diff"><div class=""> </div><div class=""> ### Other methods</div><div class=""> </div><div class=""> #### ``update_or_insert``</div><div class=""> ``update_or_insert``:inxx</div><div class=""> </div><div class=""> Some times you need to perform an insert only if there is no record with the same values as those being inserted.</div><div class=""> This can be done with</div><div class=""> </div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;,Field(&#x27;name&#x27;),Field(&#x27;birthplace&#x27;))</div><div class=""> db.person.update_or_insert(name=&#x27;John&#x27;,birthplace=&#x27;Chicago&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> The record will be inserted only of there is no other user called John born in Chicago.</div><div class=""> </div><div class=""> You can specify which values to use as a key to determine if the record exists. For example:</div><div class=""> ``</div><div class=""> db.person.update_or_insert(db.person.name==&#x27;John&#x27;,</div><div class="">      name=&#x27;John&#x27;,birthplace=&#x27;Chicago&#x27;)</div><div class=""> xss injection</div><div class=""> The DAL also allows a nested select as the argument of the belongs operator. The only caveat is that the nested select has to be a ``_select``, not a ``select``, and only one field has to be selected explicitly, the one that defines the set.</div><div class=""> </div><div class=""> ``nested select``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; bad_days = db(db.log.severity==3)._select(db.log.event_time)</div><div class=""> &gt;&gt;&gt; for row in db(db.log.event_time.belongs(bad_days)).select():</div><div class="">         print row.event</div><div class=""> port scan</div><div class=""> xss injection</div><div class=""> unauthorized login</div><div class=""> ``:code</div><div class=""> </div><div class=""> In those cases where a nested select is required and the loop-up field is a reference we can also use a query as argument. For example:</div><div class=""> </div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;,Field(&#x27;name&#x27;))</div><div class=""> db.define_table(&#x27;thing&#x27;,Field(&#x27;owner&#x27;),Field(&#x27;owner&#x27;,&#x27;reference thing&#x27;))</div><div class=""> db(db.thing.owner.belongs(db.person.name==&#x27;Johnathan&#x27;)).select()</div><div class=""> ``:cite</div><div class=""> </div><div class="delete">In this case it is obvious that the next select only needs the field referenced by the ``db.thing.owner`<span class="highlight"></span> field so we do not need the more verbose ``_select`` notation.</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/1964e274f1b0a0a41db2aeb76ac294b0bfbb212b">1964e27</a><ul><li>Date : 2012-09-01</li><li>fixed spelling mistakes, thanks Rif</li></ul></li></ul>
<div class="row-fluid" id="com_1964e274f1b0a0a41db2aeb76ac294b0bfbb212b">
    <div class="span6"><div class="diff"><div class=""> ``</div><div class="insert">db = DAL(&#x27;postgres<span class="highlight"></span>://username:password@<span class="highlight">l</span>ocalhost/mydb&#x27;)</div><div class=""> ``</div><div class=""> </div><div class=""> Before you switch, you want to move the data and rebuild all the metadata for the new database. We assume the new database to exist but we also assume it is empty.</div><div class=""> </div><div class=""> Web2py provides a script that does this work for you:</div><div class=""> </div><div class=""> ``</div><div class=""> cd web2py</div><div class=""> python scripts/cpdb.py \</div><div class="">    -f applications/app/databases \</div><div class="">    -y &#x27;sqlite://storage.sqlite&#x27; \</div><div class="insert">   -Y &#x27;postgres<span class="highlight"></span>://username:password@<span class="highlight">l</span>ocalhost/mydb&#x27;</div><div class=""> ``</div></div></div>
    <div class="span6"><div class="diff"><div class=""> ``</div><div class="delete">db = DAL(&#x27;postgres<span class="highlight">ql</span>://username:password@<span class="highlight">h</span>ocalhost/mydb&#x27;)</div><div class=""> ``</div><div class=""> </div><div class=""> Before you switch, you want to move the data and rebuild all the metadata for the new database. We assume the new database to exist but we also assume it is empty.</div><div class=""> </div><div class=""> Web2py provides a script that does this work for you:</div><div class=""> </div><div class=""> ``</div><div class=""> cd web2py</div><div class=""> python scripts/cpdb.py \</div><div class="">    -f applications/app/databases \</div><div class="">    -y &#x27;sqlite://storage.sqlite&#x27; \</div><div class="delete">   -Y &#x27;postgres<span class="highlight">ql</span>://username:password@<span class="highlight">h</span>ocalhost/mydb&#x27;</div><div class=""> ``</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/ac4003f4349f9ee22c67309ceeb48de5539b0308">ac4003f</a><ul><li>Date : 2012-09-01</li><li>added lots of new features to book</li></ul></li></ul>
<div class="row-fluid" id="com_ac4003f4349f9ee22c67309ceeb48de5539b0308">
    <div class="span6"><div class="diff"><div class="insert">web2py comes with a Database Abstraction Layer (DAL), an API that maps Python objects into database objects such as queries, tables, and records. The DAL dynamically generates the SQL in real time using the specified dialect for the database back end, so that you do not have to write SQL code or learn different SQL dialects (the term SQL is used generically), and the application will be portable among different types of databases. At the time of this writing, the supported databases are SQLite (which comes with Python and thus web2py), PostgreSQL, MySQL, Oracle, MSSQL, FireBird, DB2, Informix, <span class="highlight"></span>Ingres<span class="highlight">, the Google App Engine</span> (<span class="highlight">SQL and NoSQL</span>) <span class="highlight">and MongoDB</span>. Experimentally we support more databases. Please check on the web2py web site and mailing list for more recent adapters. Google NoSQL is treated as a particular case in Chapter 13.</div><div class=""> </div><div class=""> The Windows binary distribution works out of the box with SQLite and MySQL. The Mac binary distribution works out of the box with SQLite.</div><div class=""> To use any other database back-end, run from the source distribution and install the appropriate driver for the required back end.</div><div class=""> ``database drivers``:inxx</div><div class=""> </div><div class=""> Once the proper driver is installed, start web2py from source, and it will find the driver. Here is a list of drivers:</div><div class=""> </div><div class="insert">+``DAL``:inxx ``SQLite``:inxx ``MySQL``:inxx ``PostgresSQL``:inxx ``Oracle``:inxx ``MSSQL``:inxx ``FireBird``:inxx ``DB2``:inxx ``Informix``:inxx ``Sybase``:inxx ``Teradata``:inxx ``MongoDB``:inxx ``CouchDB``:inxx ``SAPDB``:inxx ``Cubrid``:inxx</div><div class="insert">+</div><div class=""> ----------</div><div class="insert">database | driver<span class="highlight">s</span> (source)</div><div class=""> SQLite | sqlite3 or pysqlite2 or zxJDBC ``zxjdbc``:cite  (on Jython)</div><div class="insert">PostgreSQL | psycopg2 ``psycopg2``:cite  or <span class="highlight">pg8000 ``pg8000``:cite or </span>zxJDBC ``zxjdbc``:cite  (on Jython)</div><div class=""> MySQL | pymysql ``pymysql``:cite or MySQLdb ``mysqldb``:cite</div><div class=""> Oracle | cx_Oracle ``cxoracle``:cite</div><div class=""> MSSQL | pyodbc ``pyodbc``:cite</div><div class="insert">FireBird | kinterbasdb ``kinterbasdb``:cite<span class="highlight"> or fdb or pyodbc</span></div><div class=""> DB2 | pyodbc ``pyodbc``:cite</div><div class=""> Informix | informixdb ``informixdb``:cite</div><div class=""> Ingres | ingresdbi ``ingresdbi``:cite</div><div class="insert">+Cubrid | cubriddb ``cubriddb``:cite ``cubrid``:cite</div><div class="insert">+Sybase | Sybase ``Sybase``:cite</div><div class="insert">+Teradata | pyodbc ``Teradata``:cite </div><div class="insert">+SAPDB    | sapdb ``SAPDB``:cite</div><div class="insert">+MongoDB | pymongo ``pymongo``:cite</div><div class="insert">+IMAP | imaplib ``IMAP``:cite </div><div class=""> ---------</div><div class=""> </div><div class="insert"><span class="highlight">``sqlite3``, </span>``pymysql``<span class="highlight">, ``pg8000``, and ``imaplib``</span> ship<span class="highlight"></span> with web2py<span class="highlight">. Support of MongoDB is experimental. The IMAP option allows to use DAL to access IAMP.</span></div><div class=""> </div><div class=""> web2py defines the following classes that make up the DAL:</div><div class=""> </div><div class=""> **DAL** represents a database connection. For example:</div><div class=""> ``sqlite``:inxx</div><div class=""> ``</div><div class=""> db = DAL(&#x27;sqlite://storage.db&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> ``define_table``:inxx</div><div class=""> **Table** represents a database table.  You do not directly instantiate Table; instead, ``DAL.define_table`` instantiates it.</div><div class=""> ``</div><div class=""> db.define_table(&#x27;mytable&#x27;, Field(&#x27;myfield&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class=""> The most important methods of a Table are:</div><div class=""> ``insert``:inxx</div><div class=""> ``truncate``:inxx</div><div class=""> ``drop``:inxx</div><div class=""> ``import_from_csv_file``:inxx</div><div class=""> db().select(db.table.ALL, orderby=myorder)</div><div class=""> ``:code</div><div class=""> </div><div class=""> ### Connection strings</div><div class=""> ``connection strings``:inxx</div><div class=""> </div><div class=""> A connection with the database is established by creating an instance of the DAL object:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db = DAL(&#x27;sqlite://storage.db&#x27;, pool_size=0)</div><div class=""> ``:code</div><div class=""> ``db`` is not a keyword; it is a local variable that stores the connection object ``DAL``. You are free to give it a different name. The constructor of ``DAL`` requires a single argument, the connection string. The connection string is the only web2py code that depends on a specific back-end database. Here are examples of connection strings for specific types of supported back-end databases (in all cases, we assume the database is running from localhost on its default port and is named &quot;test&quot;):</div><div class=""> </div><div class=""> -------------</div><div class=""> **SQLite**     | ``sqlite://storage.db``</div><div class=""> **MySQL**      | ``mysql://username:password@localhost/test``</div><div class=""> **PostgreSQL** | ``postgres://username:password@localhost/test``</div><div class=""> **MSSQL**      | ``mssql://username:password@localhost/test``</div><div class=""> **FireBird**   | ``firebird://username:password@localhost/test``</div><div class=""> **Oracle**     | ``oracle://username/password@test``</div><div class=""> **DB2**        | ``db2://username:password@test``</div><div class=""> **Ingres**     | ``ingres://username:password@localhost/test``</div><div class="insert">+**Sybase**     | ``sybase://username:password@localhost/test``</div><div class=""> **Informix**   | ``informix://username:password@test``</div><div class="insert">+**Teradata**   | ``teradata://DSN=dsn;UID=user;PWD=pass;DATABASE=database``</div><div class="insert">+**Cubrid**     | ``cubrid://username:password@localhost/test``</div><div class="insert">+**SAPDB**      | ``sapdb://username:password@localhost/test``</div><div class="insert">+**IMAP**       | ``imap://user:password@server:port``</div><div class="insert">+**MongoDB**    | ``mongodb://username:password@localhost/test``</div><div class=""> **Google App Engine/SQL** | ``google:sql``</div><div class=""> **Google App Engine/NoSQL** | ``google:datastore``</div><div class=""> -------------</div><div class=""> </div><div class=""> Notice that in SQLite the database consists of a single file. If it does not exist, it is created. This file is locked every time it is accessed. In the case of MySQL, PostgreSQL, MSSQL, FireBird, Oracle, DB2, Ingres and Informix the database &quot;test&quot; must be created outside web2py. Once the connection is established, web2py will create, alter, and drop tables appropriately.</div><div class=""> </div><div class=""> It is also possible to set the connection string to ``None``. In this case DAL will not connect to any back-end database, but the API can still be accessed for testing. Examples of this will be discussed in Chapter 7.</div><div class=""> </div><div class=""> #### Connection pooling</div><div class=""> ``connection pooling``:inxx</div><div class=""> </div><div class=""> The second argument of the DAL constructor is the ``pool_size``; it defaults to 0.</div><div class=""> </div><div class=""> As it is rather slow to establish a new database connection for each request, web2py implements a mechanism for connection pooling. Once a connection is established and the page has been served and the transaction completed, the connection is not closed but goes into a pool. When the next http request arrives, web2py tries to obtain a connection from the pool and use that for the new transaction. If there are no available connections in the pool, a new connection is established.</div><div class=""> </div><div class=""> The ``pool_size`` parameter is ignored by SQLite and Google App Engine.</div><div class=""> </div><div class=""> Connections in the pools are shared sequentially among threads, in the sense that they may be used by two different but not simultaneous threads. There is only one pool for each web2py process.</div><div class=""> </div><div class=""> When web2py starts, the pool is always empty. The pool grows up to the minimum between the value of ``pool_size`` and the max number of concurrent requests. This means that if ``pool_size=10`` but our server never receives more than 5 concurrent requests, then the actual pool size will only grow to 5. If ``pool_size=0`` then connection pooling is not used.</div><div class=""> For supported back-ends you may also specify if you would like to check against</div><div class=""> ``</div><div class=""> check_reserved=[&#x27;postgres&#x27;, &#x27;postgres_nonreserved&#x27;]</div><div class=""> ``:code</div><div class=""> </div><div class=""> The following database backends support reserved words checking.</div><div class=""> </div><div class=""> -----</div><div class=""> **PostgreSQL** | ``postgres(_nonreserved)``</div><div class=""> **MySQL** | ``mysql``</div><div class=""> **FireBird** | ``firebird(_nonreserved)``</div><div class=""> **MSSQL** | ``mssql``</div><div class=""> **Oracle** | ``oracle``</div><div class=""> -----</div><div class=""> </div><div class=""> ### ``DAL``, ``Table``, ``Field``</div><div class=""> </div><div class=""> The best way to understand the DAL API is to try each function yourself. This can be done interactively via the web2py shell, although ultimately, DAL code goes in the models and controllers.</div><div class=""> </div><div class=""> Start by creating a connection. For the sake of example, you can use SQLite. Nothing in this discussion changes when you change the back-end engine.</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db = DAL(&#x27;sqlite://storage.db&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> The database is now connected and the connection is stored in the global variable ``db``.</div><div class=""> </div><div class=""> At any time you can retrieve the connection string.</div><div class=""> ``_uri``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; print db._uri</div><div class=""> sqlite://storage.db</div><div class=""> ``:code</div><div class=""> </div><div class=""> and the database name</div><div class=""> ``_dbname``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; print db._dbname</div><div class=""> sqlite</div><div class=""> ``:code</div><div class=""> </div><div class=""> or even more complex ones using a function:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;),</div><div class="">        format=lambda r: r.name or &#x27;anonymous&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> The format attribute will be used for two purposes:</div><div class=""> - To represent referenced records in select/option drop-downs.</div><div class=""> - To set the ``db.othertable.person.represent`` attribute for all fields referencing this table. This means that SQLTABLE will not show references by id but will use the format preferred representation instead.</div><div class=""> </div><div class=""> </div><div class=""> ``Field constructor``:inxx</div><div class=""> These are the default values of a Field constructor:</div><div class=""> ``</div><div class=""> Field(name, &#x27;string&#x27;, length=None, default=None,</div><div class="">       required=False, requires=&#x27;&lt;default&gt;&#x27;,</div><div class="">       ondelete=&#x27;CASCADE&#x27;, notnull=False, unique=False,</div><div class="">       uploadfield=True, widget=None, label=None, comment=None,</div><div class="">       writable=True, readable=True, update=None, authorize=None,</div><div class="">       autodelete=False, represent=None, compute=None,</div><div class="">       uploadfolder=os.path.join(request.folder,&#x27;uploads&#x27;),</div><div class="insert">      uploadseparate=None<span class="highlight">,uploadfs=None</span>)</div><div class=""> ``:code</div><div class=""> </div><div class=""> Not all of them are relevant for every field. &quot;length&quot; is relevant only for fields of type &quot;string&quot;. &quot;uploadfield&quot; and &quot;authorize&quot; are relevant only for fields of type &quot;upload&quot;. &quot;ondelete&quot; is relevant only for fields of type &quot;reference&quot; and &quot;upload&quot;.</div><div class=""> - ``length`` sets the maximum length of a &quot;string&quot;, &quot;password&quot; or &quot;upload&quot; field.  If ``length`` is not specified a default value is used but the default value is not guaranteed to be backward compatible. &#x27;&#x27;To avoid unwanted migrations on upgrades, we recommend that you always specify the length for string, password and upload fields.&#x27;&#x27;</div><div class=""> - ``default`` sets the default value for the field. The default value is used when performing an insert if a value is not explicitly specified. It is also used to pre-populate forms built from the table using SQLFORM. Note, rather than being a fixed value, the default can instead be a function (including a lambda function) that returns a value of the appropriate type for the field. In that case, the function is called once for each record inserted, even when multiple records are inserted in a single transaction.</div><div class=""> - ``required`` tells the DAL that no insert should be allowed on this table if a value for this field is not explicitly specified.</div><div class=""> - ``requires`` is a validator or a list of validators. This is not used by the DAL, but it is used by SQLFORM. The default validators for the given types are shown in the following table:</div><div class=""> </div><div class=""> ----------</div><div class=""> **field type** | **default field validators**</div><div class=""> ``string`` | ``IS_LENGTH(length)`` default length is 512</div><div class=""> ``text`` | ``IS_LENGTH(65536)``</div><div class=""> ``blob`` | ``None``</div><div class=""> ``boolean`` | ``None``</div><div class=""> ``integer`` | ``IS_INT_IN_RANGE(-1e100, 1e100)``</div><div class=""> ``double`` | ``IS_FLOAT_IN_RANGE(-1e100, 1e100)``</div><div class=""> ``decimal(n,m)`` | ``IS_DECIMAL_IN_RANGE(-1e100, 1e100)``</div><div class=""> ``date`` | ``IS_DATE()``</div><div class=""> ``time`` | ``IS_TIME()``</div><div class=""> ``datetime`` | ``IS_DATETIME()``</div><div class=""> ``password`` | ``None``</div><div class=""> ``upload`` | ``None``</div><div class=""> ``reference &lt;table&gt;``  | ``IS_IN_DB(db,table.field,format)``</div><div class=""> ``list:string`` | ``None``</div><div class=""> ``list:integer`` | ``None``</div><div class=""> ``list:reference &lt;table&gt;`` | ``IS_IN_DB(db,table.field,format,multiple=True)``</div><div class="insert">+``bigint`` | ``None``</div><div class="insert">+``big-id`` | ``None``</div><div class="insert">+``big-reference`` | ``None``</div><div class=""> ---------</div><div class=""> </div><div class=""> Decimal requires and returns values as ``Decimal`` objects, as defined in the Python ``decimal`` module. SQLite does not handle the ``decimal`` type so internally we treat it as a ``double``. The (n,m) are the number of digits in total and the number of digits after the decimal point respectively.</div><div class=""> </div><div class="insert">+The ``big-id`` and, ``big-reference`` are only supported by some of the database engines and are experimental. They are not normally used as field types unless for legacy tables, however, the DAL constructor has a ``bigint_id`` argument that when set to ``True`` makes the ``id`` fields and ``reference`` fields ``big-id`` and ``big-referece`` respectively.</div><div class="insert">+</div><div class=""> The ``list:`` fields are special because they are designed to take advantage of certain denormalization features on NoSQL (in the case of Google App Engine NoSQL, the field types ``ListProperty`` and ``StringListProperty``) and back-port them all the other supported relational databases. On relational databases lists are stored as a ``text`` field. The items are separated by a ``|`` and each ``|`` in string item is escaped as a ``||``. They are discussed in their own section.</div><div class=""> </div><div class=""> -------</div><div class=""> Notice that ``requires=...`` is enforced at the level of forms, ``required=True`` is enforced at the level of the DAL (insert), while ``notnull``, ``unique`` and ``ondelete`` are enforced at the level of the database. While they sometimes may seem redundant, it is important to maintain the distinction when programming with the DAL.</div><div class=""> -------</div><div class=""> </div><div class=""> ``ondelete``:inxx</div><div class=""> </div><div class=""> - ``ondelete`` translates into the &quot;ON DELETE&quot; SQL statement. By default it is set to &quot;CASCADE&quot;. This tells the database that when it deletes a record, it should also delete all records that refer to it. To disable this feature, set ``ondelete`` to &quot;NO ACTION&quot; or &quot;SET NULL&quot;.</div><div class=""> - ``notnull=True`` translates into the &quot;NOT NULL&quot; SQL statement. It prevents the database from inserting null values for the field.</div><div class=""> - ``unique=True`` translates into the &quot;UNIQUE&quot; SQL statement and it makes sure that values of this field are unique within the table. It is enforced at the database level.</div><div class=""> - ``uploadfield`` applies only to fields of type &quot;upload&quot;. A field of type &quot;upload&quot; stores the name of a file saved somewhere else, by default on the filesystem under the application &quot;uploads/&quot; folder. If ``uploadfield`` is set, then the file is stored in a blob field within the same table and the value of ``uploadfield`` is the name of the blob field. This will be discussed in more detail later in the context of SQLFORM.</div><div class=""> - ``uploadfolder`` defaults to the application&#x27;s &quot;uploads/&quot; folder. If set to a different path, files will uploaded to a different folder. For example, uploadfolder=os.path.join(request.folder,&#x27;static/temp&#x27;) will upload files to the web2py/applications/myapp/static/temp folder.</div><div class=""> - ``uploadseparate`` if set to True will upload files under different subfolders of the &#x27;&#x27;uploadfolder&#x27;&#x27; folder. This is optimized to avoid too many files under the same folder/subfolder. ATTENTION: You cannot change the value of ``uploadseparate`` from True to False without breaking the system. web2py either uses the separate subfolders or it does not. Changing the behavior after files have been uploaded will prevent web2py from being able to retrieve those files. If this happens it is possible to move files and fix the problem but this is not described here.</div><div class="insert">+- ``uploadfs`` allows you specify a different filessystem where to upload files, including an Amazon S3 storage or a remote FTP storage. This option requires PyFileSystem installed. ``uploadfs`` must point to ``PyFileSystem``. ``PyFileSystem``:inxx ``uploadfs``:idxx</div><div class=""> - ``widget`` must be one of the available widget objects, including custom widgets, for example: ``SQLFORM.widgets.string.widget``. A list of available widgets will be discussed later. Each field type has a default widget.</div><div class=""> - ``label`` is a string (or something that can be serialized to a string) that contains the label to be used for this field in autogenerated forms.</div><div class=""> - ``comment``  is a string (or something that can be serialized to a string) that contains a comment associated with this field, and will be displayed to the right of the input field in the autogenerated forms.</div><div class=""> - ``writable`` if a field is writable, it can be edited in autogenerated create and update forms.</div><div class=""> - ``readable`` if a field is readable, it will be visible in readonly forms. If a field is neither readable nor writable, it will not be displayed in create and update forms.</div><div class=""> - ``update`` contains the default value for this field when the record is updated.</div><div class=""> - ``compute`` is an optional function. If a record is inserted or updated, the compute function will be executed and the field will be populated with the function result. The record is passed to the compute function as a ``dict``, and the dict will not include the current value of that, or any other compute field.</div><div class=""> - ``authorize`` can be used to require access control on the corresponding field, for &quot;upload&quot; fields only. It will be discussed more in detail in the context of Authentication and Authorization.</div><div class=""> - ``autodelete`` determines if the corresponding uploaded file should be deleted when the record referencing the file is deleted. For &quot;upload&quot; fields only.</div><div class=""> - ``represent`` can be None or can point to a function that takes a field value and returns an alternate representation for the field value. Examples:</div><div class=""> ``</div><div class=""> db.mytable.name.represent = lambda name,row: name.capitalize()</div><div class=""> db.mytable.other_id.represent = lambda id,row: row.myfield</div><div class=""> db.mytable.some_uploadfield.represent = lambda value,row: \</div><div class="">     A(&#x27;get it&#x27;, _href=URL(&#x27;download&#x27;, args=value))</div><div class=""> ``:code</div><div class=""> </div><div class=""> ``blob``:inxx</div><div class=""> &quot;blob&quot; fields are also special. By default, binary data is encoded in base64 before being stored into the actual database field, and it is decoded when extracted. This has the negative effect of using 25% more storage space than necessary in blob fields, but has two advantages. On average it reduces the amount of data communicated between web2py and the database server, and it makes the communication independent of back-end-specific escaping conventions.</div><div class=""> </div><div class=""> The DAL allows you to explicitly issue SQL statements.</div><div class=""> &gt;&gt;&gt; print db.executesql(&#x27;SELECT * FROM person;&#x27;)</div><div class=""> [(1, u&#x27;Massimo&#x27;), (2, u&#x27;Massimo&#x27;)]</div><div class=""> ``:code</div><div class=""> </div><div class=""> In this case, the return values are not parsed or transformed by the DAL, and the format depends on the specific database driver. This usage with selects is normally not needed, but it is more common with indexes.</div><div class=""> ``executesql`` takes two optional arguments: ``placeholders`` and ``as_dict``</div><div class=""> ``placeholders`` is an optional</div><div class=""> sequence of values to be substituted in</div><div class=""> or, if supported by the DB driver, a dictionary with keys</div><div class=""> matching named placeholders in your SQL.</div><div class=""> </div><div class=""> If ``as_dict`` is set to True,</div><div class=""> and the results cursor returned by the DB driver will be</div><div class=""> converted to a sequence of dictionaries keyed with the db</div><div class=""> field names.  Results returned with ``as_dict = True ``are</div><div class=""> the same as those returned when applying **.as_list()** to a normal select.</div><div class=""> ``</div><div class=""> [{field1: value1, field2: value2}, {field1: value1b, field2: value2b}]</div><div class=""> ``:code</div><div class=""> </div><div class="insert">+executesql have an optional ``fields`` argument.</div><div class="insert">+If not None, the   </div><div class="insert">+results cursor returned by the DB driver will be converted to a            </div><div class="insert">+DAL Rows object using the ``db._adapter.parse()`` method. This requires        </div><div class="insert">+specifying the &quot;fields&quot; argument as a list of DAL Field objects            </div><div class="insert">+that match the fields returned from the DB. The Field objects should       </div><div class="insert">+be part of one or more Table objects defined on the DAL object.            </div><div class="insert">+        </div><div class="insert">+The ``fields`` list can include one or more DAL Table objects in addition    </div><div class="insert">+to or instead of including Field objects, or it can be just a single       </div><div class="insert">+table (not in a list). In that case, the Field objects will be             </div><div class="insert">+extracted from the table(s).</div><div class="insert">+</div><div class="insert">+The field names will be extracted from the Field objects, or optionally,</div><div class="insert">+a list of field names can be provided (in tablename.fieldname format)      </div><div class="insert">+via the ``colnames`` argument. Note, the fields and colnames must be in      </div><div class="insert">+the same order as the fields in the results cursor returned from the DB.</div><div class="insert">+</div><div class=""> #### ``_lastsql``</div><div class=""> </div><div class=""> Whether SQL was executed manually using executesql or was SQL generated by the DAL, you can always find the SQL code in ``db._lastsql``. This is useful for debugging purposes:</div><div class=""> </div><div class=""> ``_lastdb``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows = db().select(db.person.ALL)</div><div class=""> &gt;&gt;&gt; print db._lastsql</div><div class=""> SELECT person.id, person.name FROM person;</div><div class=""> ``:code</div><div class=""> </div><div class=""> -------</div><div class=""> web2py never generates queries using the &quot;*&quot; operator. web2py is always explicit when selecting fields.</div><div class=""> -------</div><div class=""> </div><div class=""> ### ``drop``</div><div class=""> </div><div class=""> Finally, you can drop tables and all data will be lost:</div><div class=""> </div><div class=""> ``drop``:inxx</div><div class=""> db.define_table(&#x27;account&#x27;,</div><div class="">     Field(&#x27;accnum&#x27;,&#x27;integer&#x27;),</div><div class="">     Field(&#x27;acctype&#x27;),</div><div class="">     Field(&#x27;accdesc&#x27;),</div><div class="">     primarykey=[&#x27;accnum&#x27;,&#x27;acctype&#x27;],</div><div class="">     migrate=False)</div><div class=""> ``:code</div><div class=""> </div><div class=""> - ``primarykey`` is a list of the field names that make up the primary key. </div><div class=""> - All primarykey fields have a ``NOT NULL`` set even if not specified.</div><div class=""> - Keyed table can only refer are to other keyed tables.</div><div class=""> - Referenceing fields must use the ``reference tablename.fieldname`` format.</div><div class=""> - The ``update_record`` function is not available for Rows of keyed tables.</div><div class=""> </div><div class=""> -------</div><div class=""> Note that currently this is only available for DB2, MS-SQL, Ingres and Informix, but others can be easily added.</div><div class=""> -------</div><div class=""> </div><div class=""> At the time of writing, we cannot guarantee that the ``primarykey`` attribute works with every existing legacy table and every supported database backend.</div><div class=""> For simplicity, we recommend, if possible, creating a database view that has an auto-increment id field.</div><div class=""> </div><div class="insert">+</div><div class=""> ### Distributed transaction</div><div class=""> ``distributed transactions``:inxx</div><div class=""> </div><div class=""> ------</div><div class=""> At the time of writing this feature is only supported</div><div class=""> by PostgreSQL, MySQL and Firebird, since they expose API for two-phase commits.</div><div class=""> ------</div><div class=""> </div><div class=""> Assuming you have two (or more) connections to distinct PostgreSQL databases, for example:</div><div class=""> ``</div><div class=""> db_a = DAL(&#x27;postgres://...&#x27;)</div><div class=""> db_b = DAL(&#x27;postgres://...&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> In your models or controllers, you can commit them concurrently with:</div><div class=""> ``</div><div class=""> DAL.distributed_transaction_commit(db_a, db_b)</div><div class=""> ``:code</div><div class=""> </div><div class=""> On failure, this function rolls back and raises an ``Exception``.</div><div class=""> </div><div class=""> In controllers, when one action returns, if you have two distinct connections and you do not call the above function, web2py commits them separately. This means there is a possibility that one of the commits succeeds and one fails. The distributed transaction prevents this from happening.</div><div class=""> </div><div class="insert">### M<span class="highlight">ore o</span>n<span class="highlight"></span> uploads</div><div class=""> </div><div class=""> Consider the following model:</div><div class=""> ``</div><div class="insert">+&gt;&gt;&gt; db.define_table(&#x27;myfile&#x27;,</div><div class="insert">+    Field(&#x27;image&#x27;, &#x27;upload&#x27;, default=&#x27;path/&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class="insert">+In the case of an &#x27;upload&#x27; field, the default value can optionally be set to a path (an absolute path or a path relative to the current app folder) and the default image will be set to a copy of the file at the path. A new copy is made for each new record that does not specify an image.</div><div class="insert">+</div><div class=""> Normally an insert is handled automatically via a SQLFORM or a crud form (which is a SQLFORM) but occasionally you already have the file on the filesystem and want to upload it programmatically. This can be done in this way:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; stream = open(filename, &#x27;rb&#x27;)</div><div class=""> &gt;&gt;&gt; db.myfile.insert(image=db.myfile.image.store(stream, filename))</div><div class=""> ``:code</div><div class=""> </div><div class="insert">+It is also possible to insert a file in a simpler way and have the insert method call store automatically:</div><div class="insert">+</div><div class="insert">+``</div><div class="insert">+&gt;&gt;&gt; stream = open(filename, &#x27;rb&#x27;)</div><div class="insert">+&gt;&gt;&gt; db.myfile.insert(image=stream)</div><div class="insert">+``:code</div><div class="insert">+</div><div class="insert">+In this case the filename is obtained from the stream object if available.</div><div class="insert">+</div><div class=""> The ``store`` method of the upload field object takes a file stream and a filename. It uses the filename to determine the extension (type) of the file, creates a new temp name for the file (according to web2py upload mechanism) and loads the file content in this new temp file (under the uploads folder unless specified otherwise). It returns the new temp name, which is then stored in the ``image`` field of the ``db.myfile`` table.</div><div class=""> </div><div class=""> Note, if the file is to be stored in an associated blob field rather than the file system, the ``store()`` method will not insert the file in the blob field (because ``store()`` is called before the insert), so the file must be explicitly inserted into the blob field:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;myfile&#x27;,</div><div class="">         Field(&#x27;image&#x27;, &#x27;upload&#x27;, uploadfield=&#x27;image_file&#x27;),</div><div class="">         Field(&#x27;image_file&#x27;, &#x27;blob&#x27;))</div><div class=""> &gt;&gt;&gt; stream = open(filename, &#x27;rb&#x27;)</div><div class=""> &gt;&gt;&gt; db.myfile.insert(image=db.myfile.image.store(stream, filename),</div><div class="">         image_file=stream.read())</div><div class=""> ``:code</div><div class=""> </div><div class="insert">+</div><div class=""> The opposite of ``.store`` is ``.retrieve``:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; row = db(db.myfile).select().first()</div><div class=""> &gt;&gt;&gt; (filename, stream) = db.myfile.image.retrieve(row.image)</div><div class=""> &gt;&gt;&gt; import shutil</div><div class=""> &gt;&gt;&gt; shutil.copyfileobj(stream,open(filename,&#x27;wb&#x27;))</div><div class=""> ``</div><div class=""> </div><div class=""> ### ``Query``, ``Set``, ``Rows``</div><div class=""> </div><div class=""> Let&#x27;s consider again the table defined (and dropped) previously and insert three records:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;))</div><div class=""> &gt;&gt;&gt; db.person.insert(name=&quot;Alex&quot;)</div><div class=""> 1</div><div class=""> &gt;&gt;&gt; db.person.insert(name=&quot;Bob&quot;)</div><div class=""> 2</div><div class=""> &gt;&gt;&gt; db.person.insert(name=&quot;Carl&quot;)</div><div class=""> 3</div><div class=""> which is equivalent to</div><div class=""> db(db.mytable.id==id).update(myfield=&#x27;somevalue&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> and it updates an existing record with field values specified by the dictionary on the right hand side.</div><div class=""> </div><div class=""> #### Fetching a ``Row``</div><div class=""> </div><div class=""> Yet another convenient syntax is the following:</div><div class=""> </div><div class=""> ``</div><div class=""> record = db.mytable(id)</div><div class=""> record = db.mytable(db.mytable.id==id)</div><div class=""> record = db.mytable(id,myfield=&#x27;somevalue&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> Apparently similar to ``db.mytable[id]`` the above syntax is more flexible and safer. First of all it checks whether ``id`` is an int (or ``str(id)`` is an int) and returns ``None`` if not (it never raises an exception). It also allows to specify multiple conditions that the record must meet. If they are not met, it also returns ``None``.</div><div class=""> </div><div class=""> #### Recursive ``select``s</div><div class=""> ``recursive selects``:inxx</div><div class=""> </div><div class="insert">Consider the previous table person and a new table &quot;<span class="highlight">thin</span>g&quot; referencing a &quot;person&quot;:</div><div class=""> ``</div><div class="insert">&gt;&gt;&gt; db.define_table(&#x27;<span class="highlight">thin</span>g&#x27;, Field(&#x27;name&#x27;), Field(&#x27;owner&#x27;,&#x27;reference person&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class=""> and a simple select from this table:</div><div class=""> ``</div><div class="insert">&gt;&gt;&gt; <span class="highlight">thin</span>gs = db(db.<span class="highlight">thin</span>g).select()</div><div class=""> ``:code</div><div class=""> </div><div class=""> which is equivalent to</div><div class=""> </div><div class=""> ``</div><div class="insert">&gt;&gt;&gt; <span class="highlight">thin</span>gs = db(db.<span class="highlight">thin</span>g._id&gt;0).select()</div><div class=""> ``:code</div><div class=""> </div><div class="insert">where ``._id`` is a reference to the primary key of the table. Normally ``db.<span class="highlight">thin</span>g._id`` is the same as ``db.<span class="highlight">thin</span>g.id`` and we will assume that in most of this book. ``_id``:inxx</div><div class=""> </div><div class=""> </div><div class="insert">For each Row of <span class="highlight">thin</span>gs it is possible to fetch not just fields from the selected table (<span class="highlight">thin</span>g) but also from linked tables (recursively):</div><div class=""> ``</div><div class="insert">&gt;&gt;&gt; for <span class="highlight">thin</span>g in <span class="highlight">thin</span>gs: print <span class="highlight">thin</span>g.name, <span class="highlight">thin</span>g.owner.name</div><div class=""> ``:code</div><div class=""> </div><div class="insert">Here ``<span class="highlight">thin</span>g.owner.name`` requires one database select for each <span class="highlight">thing in thin</span>gs and it is therefore inefficient. We suggest using joins whenever possible instead of recursive selects, nevertheless this is convenient and practical when accessing individual records.</div><div class=""> </div><div class="insert">You can also do it backwards, by selecting the <span class="highlight">thin</span>gs referenced by a person:</div><div class=""> </div><div class=""> ``</div><div class=""> person =  db.person(id)</div><div class="insert">+for thing in person.thing.select(orderby=db.thing.name):</div><div class="insert">+    print person.name, &#x27;owns&#x27;, thing.name</div><div class=""> ``:code</div><div class=""> </div><div class="insert">In this last expressions ``person.<span class="highlight">thin</span>g`` is a shortcut for</div><div class=""> </div><div class=""> ``</div><div class="insert">db(db.<span class="highlight">thin</span>g.owner==person.id)</div><div class=""> ``:code</div><div class=""> </div><div class="insert">i.e. the Set of ``<span class="highlight">thin</span>g``s referenced by the current ``person``. This syntax breaks down if the referencing table has multiple references to the referenced table. In this case one needs to be more explicit and use a full Query.</div><div class=""> </div><div class=""> </div><div class=""> #### Serializing ``Rows`` in views</div><div class=""> </div><div class=""> Given the following action containing a query</div><div class=""> ``SQLTABLE``:inxx</div><div class=""> </div><div class=""> ``</div><div class=""> def index()</div><div class="">     return dict(rows = db(query).select())</div><div class=""> ``:code</div><div class=""> </div><div class=""> The result of a select can be displayed in a view with the following syntax:</div><div class=""> ``</div><div class=""> {{extend &#x27;layout.html&#x27;}}</div><div class=""> &lt;h1&gt;Records&lt;/h1&gt;</div><div class=""> {{=rows}}</div><div class=""> ``:code</div><div class=""> </div><div class=""> Which is equivalent to:</div><div class=""> Due to Python restrictions in overloading &quot;``and``&quot; and &quot;``or``&quot; operators, thes</div><div class=""> </div><div class=""> It is also possible to build queries using in-place logical operators:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; query = db.person.name!=&#x27;Alex&#x27;</div><div class=""> &gt;&gt;&gt; query &amp;= db.person.id&gt;3</div><div class=""> &gt;&gt;&gt; query |= db.person.name==&#x27;John&#x27;</div><div class=""> ``</div><div class=""> </div><div class=""> #### ``count``, ``isempty``, ``delete``, ``update``</div><div class=""> </div><div class=""> You can count records in a set:</div><div class=""> </div><div class=""> ``count``:inxx ``isempty``:inxx</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; print db(db.person.id &gt; 0).count()</div><div class=""> 3</div><div class=""> ``:code</div><div class=""> </div><div class="insert">Notice that ``count`` takes an optional ``distinct`` argument which defaults to False, and it works very much like the same argument for ``select``.<span class="highlight"> ``count`` has also a ``cache`` argument that works very much like the equivalent argument of the ``select`` method.</span></div><div class=""> </div><div class=""> Sometimes you may need to check is a table is empty. A more efficient way than counting is using the ``isempty`` method:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; print db(db.person.id &gt; 0).isempty()</div><div class=""> False</div><div class=""> ``:code</div><div class=""> </div><div class=""> or equivalently:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; print db(db.person).isempty()</div><div class=""> False</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can delete records in a set:</div><div class=""> </div><div class=""> ``delete``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db(db.person.id &gt; 3).delete()</div><div class=""> In this case ``row.total_price`` is not a value but a function. The function tak</div><div class=""> </div><div class=""> The lazy field in the example above allows one to compute the total price for each ``item``:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db(db.item).select(): print row.total_price()</div><div class=""> ``</div><div class=""> </div><div class=""> And it also allows to pass an optional ``discount`` percentage (15%):</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db(db.item).select(): print row.total_price(15)</div><div class=""> ``</div><div class=""> </div><div class=""> ------</div><div class=""> Mind that virtual fields do not have the same attributes as the other fields (default, readable, requires, etc) and they do not appear in the list of ``db.table.fields`` and are not visualized by default in tables (TABLE) and grids (SQLFORM.grid, SQLFORM.smartgrid).</div><div class=""> ------</div><div class=""> </div><div class=""> ### One to many relation</div><div class=""> ``one to many``:inxx</div><div class=""> </div><div class="insert">To illustrate how to implement one to many relations with the web2py DAL, define another table &quot;<span class="highlight">thin</span>g&quot; that refers to the table &quot;person&quot; which we redefine here:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;,</div><div class="">                     Field(&#x27;name&#x27;),</div><div class="">                     format=&#x27;%(name)s&#x27;)</div><div class="insert">&gt;&gt;&gt; db.define_table(&#x27;<span class="highlight">thin</span>g&#x27;,</div><div class="">                     Field(&#x27;name&#x27;),</div><div class="">                     Field(&#x27;owner&#x27;, &#x27;reference person&#x27;),</div><div class="">                     format=&#x27;%(name)s&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class="insert">Table &quot;<span class="highlight">thin</span>g&quot; has two fields, the name of the <span class="highlight">thin</span>g and the owner of the <span class="highlight">thin</span>g. When a field type is another table, it is intended that the field reference the other table by its id. In fact, you can print the actual type value and get:</div><div class=""> ``</div><div class="insert">&gt;&gt;&gt; print db.<span class="highlight">thin</span>g.owner.type</div><div class=""> reference person</div><div class=""> ``:code</div><div class=""> </div><div class="insert">Now, insert three <span class="highlight">thin</span>gs, two owned by Alex and one by Bob:</div><div class=""> ``</div><div class="insert">&gt;&gt;&gt; db.<span class="highlight">thin</span>g.insert(name=&#x27;<span class="highlight">Boat</span>&#x27;, owner=1)</div><div class=""> 1</div><div class="insert">&gt;&gt;&gt; db.<span class="highlight">thin</span>g.insert(name=&#x27;<span class="highlight">Chair</span>&#x27;, owner=1)</div><div class=""> 2</div><div class="insert">&gt;&gt;&gt; db.<span class="highlight">thin</span>g.insert(name=&#x27;<span class="highlight">Shoes</span>&#x27;, owner=2)</div><div class=""> 3</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can select as you did for any other table:</div><div class=""> ``</div><div class="insert">&gt;&gt;&gt; for row in db(db.<span class="highlight">thin</span>g.owner==1).select():</div><div class="">         print row.name</div><div class="insert">+Boat</div><div class="insert">+Chair</div><div class=""> ``:code</div><div class=""> </div><div class="insert">Because a <span class="highlight">thin</span>g has a reference to a person, a person can have many <span class="highlight">thin</span>gs, so a record of table person now acquires a new attribute <span class="highlight">thing, which is a Set, that </span>d<span class="highlight">efines the things of that person. This allows looping over all persons an</span>d<span class="highlight"> fetching their thin</span>gs easily:</div><div class=""> </div><div class=""> ``referencing``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for person in db().select(db.person.ALL):</div><div class="">         print person.name</div><div class="insert">+        for thing in person.thing.select():</div><div class="insert">+            print &#x27;    &#x27;, thing.name</div><div class=""> Alex</div><div class="insert">+     Boat</div><div class="insert">+     Chair</div><div class=""> Bob</div><div class="insert">     <span class="highlight">Shoes</span></div><div class=""> Carl</div><div class=""> ``:code</div><div class=""> </div><div class=""> #### Inner joins</div><div class=""> </div><div class=""> Another way to achieve a similar result is by using a join, specifically an INNER JOIN. web2py performs joins automatically and transparently when the query links two or more tables as in the following example:</div><div class=""> </div><div class=""> ``Rows``:inxx ``inner join``:inxx ``join``:inxx</div><div class=""> ``</div><div class="insert">&gt;&gt;&gt; rows = db(db.person.id==db.<span class="highlight">thin</span>g.owner).select()</div><div class=""> &gt;&gt;&gt; for row in rows:</div><div class="insert">+        print row.person.name, &#x27;has&#x27;, row.thing.name</div><div class="insert">+Alex has Boat</div><div class="insert">+Alex has Chair</div><div class="insert">+Bob has Shoes</div><div class=""> ``:code</div><div class=""> </div><div class=""> Observe that web2py did a join, so the rows now contain two records, one from each table, linked together. Because the two records may have fields with conflicting names, you need to specify the table when extracting a field value from a row. This means that while before you could do:</div><div class=""> ``</div><div class=""> row.name</div><div class=""> ``:code</div><div class=""> </div><div class="insert">and it was obvious whether this was the name of a person or a <span class="highlight">thin</span>g, in the result of a join you have to be more explicit and say:</div><div class=""> ``</div><div class=""> row.person.name</div><div class=""> ``:code</div><div class=""> </div><div class=""> or:</div><div class=""> ``</div><div class="insert">row.<span class="highlight">thin</span>g.name</div><div class=""> ``:code</div><div class=""> </div><div class=""> There is an alterantive syntax for INNER JOINS:</div><div class=""> ``</div><div class="insert">&gt;&gt;&gt; rows = db(db.person).select(join=db.<span class="highlight">thin</span>g.on(db.person.id==db.<span class="highlight">thin</span>g.owner))</div><div class=""> &gt;&gt;&gt; for row in rows:</div><div class="insert">+    print row.person.name, &#x27;has&#x27;, row.thing.name</div><div class="insert">+Alex has Boat</div><div class="insert">+Alex has Chair</div><div class="insert">+Bob has Shoes</div><div class=""> ``:code</div><div class=""> </div><div class=""> While the output is the same, the generated SQL in the two cases can be different. The latter syntax removes possible ambiguities when the same table is joined twice and aliased:</div><div class=""> </div><div class=""> ``</div><div class="insert">&gt;&gt;&gt; db.define_table(&#x27;<span class="highlight">thin</span>g&#x27;,</div><div class="">         Field(&#x27;name&#x27;),</div><div class="">         Field(&#x27;owner1&#x27;,&#x27;reference person&#x27;),</div><div class="">         Field(&#x27;owner2&#x27;,&#x27;reference person&#x27;))</div><div class=""> &gt;&gt;&gt; rows = db(db.person).select(</div><div class="insert">+    join=[db.person.with_alias(&#x27;owner1&#x27;).on(db.person.id==db.thing.owner1).</div><div class="insert">+          db.person.with_alias(&#x27;owner2&#x27;).on(db.person.id==db.thing.owner2)])</div><div class=""> ``</div><div class=""> </div><div class=""> The value of ``join`` can be list of ``db.table.on(...)`` to join.</div><div class=""> </div><div class=""> #### Left outer join</div><div class=""> </div><div class="insert">Notice that Carl did not appear in the list above because he has no <span class="highlight">thin</span>gs. If you intend to select on persons (whether they have <span class="highlight">thin</span>gs or not) and their <span class="highlight">thin</span>gs (if they have any), then you need to perform a LEFT OUTER JOIN. This is done using the argument &quot;left&quot; of the select command. Here is an example:</div><div class=""> </div><div class=""> ``Rows``:inxx ``left outer join``:inxx ``outer join``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows=db().select(</div><div class="insert">+        db.person.ALL, db.thing.ALL,</div><div class="insert">+        left=db.thing.on(db.person.id==db.thing.owner))</div><div class=""> &gt;&gt;&gt; for row in rows:</div><div class="insert">+        print row.person.name, &#x27;has&#x27;, row.thing.name</div><div class="insert">+Alex has Boat</div><div class="insert">+Alex has Chair</div><div class="insert">+Bob has Shoes</div><div class=""> Carl has None</div><div class=""> ``:code</div><div class=""> </div><div class=""> where:</div><div class=""> ``</div><div class="insert">left = db.<span class="highlight">thin</span>g.on(...)</div><div class=""> ``:code</div><div class=""> </div><div class="insert">does the left join query. Here the argument of ``db.<span class="highlight">thin</span>g.on`` is the condition required for the join (the same used above for the inner join). In the case of a left join, it is necessary to be explicit about which fields to select.</div><div class=""> </div><div class=""> Multiple left joins can be combined by passing a list or tuple of ``db.mytable.on(...)`` to the  ``left`` attribute.</div><div class=""> </div><div class=""> #### Grouping and counting</div><div class=""> </div><div class="insert">When doing joins, sometimes you want to group rows according to certain criteria and count them. For example, count the number of <span class="highlight">thin</span>gs owned by every person. web2py allows this as well. First, you need a count operator. Second, you want to join the person table with the <span class="highlight">thin</span>g table by owner. Third, you want to select all rows (person + <span class="highlight">thin</span>g), group them by person, and count them while grouping:</div><div class=""> </div><div class=""> ``grouping``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; count = db.person.id.count()</div><div class="insert">&gt;&gt;&gt; for row in db(db.person.id==db.<span class="highlight">thin</span>g.owner).select(</div><div class="">         db.person.name, count, groupby=db.person.name):</div><div class="">         print row.person.name, row[count]</div><div class=""> Alex 2</div><div class=""> Bob 1</div><div class=""> ``:code</div><div class=""> </div><div class="insert">Notice the count operator (which is built-in) is used as a field. The only issue here is in how to retrieve the information. Each row clearly contains a person and the count, but the count is not a field of a person nor is it a table. So where does it go? It goes into the storage object representing the record with a key equal to the query expression itself.<span class="highlight"> The count method of the Field object has an optional ``distinct`` argument. When set to ``True`` it specifies that only distinct values of the field in question are to be counted.</span></div><div class=""> </div><div class=""> ### Many to many</div><div class=""> ``many-to-many``:inxx</div><div class="insert">In the previous examples, we allowed a <span class="highlight">thin</span>g to have one owner but one person could have many <span class="highlight">thin</span>gs. What if <span class="highlight">Boat was owned by Alex and Curt? This requires a many-to-many relation, and it is realized via an intermediate table that lin</span>k<span class="highlight">s a person to a thin</span>g via an ownership relation.</div><div class=""> </div><div class=""> Here is how to do it:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;,</div><div class="">                     Field(&#x27;name&#x27;))</div><div class="insert">&gt;&gt;&gt; db.define_table(&#x27;<span class="highlight">thin</span>g&#x27;,</div><div class="">                     Field(&#x27;name&#x27;))</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;ownership&#x27;,</div><div class="">                     Field(&#x27;person&#x27;, &#x27;reference person&#x27;),</div><div class="insert">                    Field(&#x27;<span class="highlight">thin</span>g&#x27;, &#x27;reference <span class="highlight">thin</span>g&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class=""> the existing ownership relationship can now be rewritten as:</div><div class=""> ``</div><div class="insert">+&gt;&gt;&gt; db.ownership.insert(person=1, thing=1) # Alex owns Boat</div><div class="insert">+&gt;&gt;&gt; db.ownership.insert(person=1, thing=2) # Alex owns Chair</div><div class="insert">+&gt;&gt;&gt; db.ownership.insert(person=2, thing=3) # Bob owns Shoes</div><div class=""> </div><div class=""> ``:code</div><div class=""> </div><div class="insert">Now you can add the new relation that Curt co-owns <span class="highlight">Boat</span>:</div><div class=""> ``</div><div class="insert">&gt;&gt;&gt; db.ownership.insert(person=3, <span class="highlight">thin</span>g=1) # Curt owns <span class="highlight">Boat</span> too</div><div class=""> </div><div class=""> ``:code</div><div class=""> </div><div class=""> Because you now have a three-way relation between tables, it may be convenient to define a new set on which to perform operations:</div><div class=""> ``</div><div class="insert">&gt;&gt;&gt; persons_and_<span class="highlight">thin</span>gs = db(</div><div class="">         (db.person.id==db.ownership.person) \</div><div class="insert">        &amp; (db.<span class="highlight">thin</span>g.id==db.ownership.<span class="highlight">thin</span>g))</div><div class=""> ``:code</div><div class=""> </div><div class="insert">Now it is easy to select all persons and their <span class="highlight">thin</span>gs from the new Set:</div><div class=""> ``</div><div class="insert">+&gt;&gt;&gt; for row in persons_and_things.select():</div><div class="insert">+        print row.person.name, row.thing.name</div><div class="insert">+Alex Boat</div><div class="insert">+Alex Chair</div><div class="insert">+Bob Shoes</div><div class="insert">+Curt Boat</div><div class=""> ``:code</div><div class=""> </div><div class="insert">Similarly, you can search for all <span class="highlight">thin</span>gs owned by Alex:</div><div class=""> ``</div><div class="insert">+&gt;&gt;&gt; for row in persons_and_things(db.person.name==&#x27;Alex&#x27;).select():</div><div class="insert">+        print row.thing.name</div><div class="insert">+Boat</div><div class="insert">+Chair</div><div class=""> ``:code</div><div class=""> </div><div class="insert">and all owners of <span class="highlight">Boat</span>:</div><div class=""> ``</div><div class="insert">&gt;&gt;&gt; for row in persons_and_<span class="highlight">thin</span>gs(db.<span class="highlight">thin</span>g.name==&#x27;<span class="highlight">Boat</span>&#x27;).select():</div><div class="">         print row.person.name</div><div class=""> Alex</div><div class=""> Curt</div><div class=""> ``:code</div><div class=""> </div><div class=""> A lighter alternative to Many 2 Many relations is tagging. Tagging is discussed in the context of the ``IS_IN_DB`` validator. Tagging works even on database backends that do not support JOINs like the Google App Engine NoSQL.</div><div class=""> </div><div class=""> ### Many to many, ``list:&lt;type&gt;``, and ``contains``</div><div class=""> ``list:string``:inxx</div><div class=""> ``list:integer``:inxx</div><div class=""> ``list:reference``:inxx</div><div class=""> ``contains``:inxx</div><div class=""> ``multiple``:inxx</div><div class=""> ``tags``:inxx</div><div class=""> </div><div class=""> web2py provides the following special field types:</div><div class=""> </div><div class=""> ``</div><div class=""> list:string</div><div class=""> list:integer</div><div class=""> Let&#x27;s define another table &quot;log&quot; to store security events, their event_time and</div><div class="">                            Field(&#x27;event_time&#x27;, &#x27;datetime&#x27;),</div><div class="">                            Field(&#x27;severity&#x27;, &#x27;integer&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class=""> As before, insert a few events, a &quot;port scan&quot;, an &quot;xss injection&quot; and an &quot;unauthorized login&quot;.</div><div class=""> For the sake of the example, you can log events with the same event_time but with different severities (1, 2, 3 respectively).</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; import datetime</div><div class=""> &gt;&gt;&gt; now = datetime.datetime.now()</div><div class=""> &gt;&gt;&gt; print db.log.insert(</div><div class="">         event=&#x27;port scan&#x27;, event_time=now, severity=1)</div><div class=""> 1</div><div class=""> &gt;&gt;&gt; print db.log.insert(</div><div class="">         event=&#x27;xss injection&#x27;, event_time=now, severity=2)</div><div class=""> 2</div><div class=""> &gt;&gt;&gt; print db.log.insert(</div><div class="">         event=&#x27;unauthorized login&#x27;, event_time=now, severity=3)</div><div class=""> 3</div><div class=""> ``:code</div><div class=""> </div><div class="insert">+#### ``like``, ``regexp``, ``startswith``, ``contains``, ``upper``, ``lower``</div><div class="insert">+</div><div class="insert">+``like``:inxx ``startswith``:inxx ``regexp``:inxx</div><div class=""> ``contains``:inxx ``upper``:inxx ``lower``:inxx</div><div class=""> </div><div class=""> Fields have a like operator that you can use to match strings:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db(db.log.event.like(&#x27;port%&#x27;)).select():</div><div class="">         print row.event</div><div class=""> port scan</div><div class=""> ``:code</div><div class=""> </div><div class=""> Here &quot;port%&quot; indicates a string starting with &quot;port&quot;. The percent sign character, &quot;%&quot;, is a wild-card character that means &quot;any sequence of characters&quot;.</div><div class=""> </div><div class="insert">+The like operator is case insisite but it can be made case sensitive with</div><div class="insert">+</div><div class="insert">+``</div><div class="insert">+db.mytable.myfield.like(&#x27;value&#x27;,case_sensitive=True)</div><div class="insert">+``:code</div><div class="insert">+</div><div class="insert">+</div><div class=""> web2py also provides some shortcuts:</div><div class=""> </div><div class=""> ``</div><div class=""> db.mytable.myfield.startswith(&#x27;value&#x27;)</div><div class=""> db.mytable.myfield.contains(&#x27;value&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> which are equivalent respectively to</div><div class=""> </div><div class=""> ``</div><div class=""> db.mytable.myfield.like(&#x27;value%&#x27;)</div><div class=""> db.mytable.myfield.like(&#x27;%value%&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> Notice that ``contains`` has a special meaning for ``list:&lt;type&gt;`` fields and it was discussed in a previous section.</div><div class=""> </div><div class=""> The ``contains`` method can also be passed a list of values and an optional boolean argument ``all`` to search for records that contain all values:</div><div class=""> </div><div class=""> ``</div><div class=""> db.mytable.myfield.contains([&#x27;value1&#x27;,&#x27;value2&#x27;], all=True)</div><div class=""> ``</div><div class=""> or any value from the list</div><div class=""> ``</div><div class=""> db.mytable.myfield.contains([&#x27;value1&#x27;,&#x27;value2&#x27;], all=false)</div><div class=""> ``</div><div class=""> </div><div class="insert">+There is a also a ``regexp`` method that works like the ``like`` method but allows regular expression syntax for the look-up expression. It is only supported by PostgreSQL and SQLite.</div><div class=""> </div><div class=""> The ``upper`` and ``lower`` methods allow you to convert the value of the field to upper or lower case, and you can also combine them with the like operator:</div><div class=""> </div><div class=""> ``upper``:inxx ``lower``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db(db.log.event.upper().like(&#x27;PORT%&#x27;)).select():</div><div class="">         print row.event</div><div class=""> port scan</div><div class=""> ``:code</div><div class=""> </div><div class=""> #### ``year``, ``month``, ``day``, ``hour``, ``minutes``, ``seconds``</div><div class=""> ``hour``:inxx ``minutes``:inxx ``seconds``:inxx ``day``:inxx ``month``:inxx ``year``:inxx</div><div class=""> </div><div class=""> The date and datetime fields have day, month and year methods. The datetime and time fields have hour, minutes and seconds methods. Here is an example:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db(db.log.event_time.year()==2009).select():</div><div class="">         print row.event</div><div class=""> port scan</div><div class=""> xss injection</div><div class=""> The SQL IN operator is realized via the belongs method which returns true when t</div><div class=""> ``belongs``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db(db.log.severity.belongs((1, 2))).select():</div><div class="">         print row.event</div><div class=""> port scan</div><div class=""> xss injection</div><div class=""> ``:code</div><div class=""> </div><div class=""> The DAL also allows a nested select as the argument of the belongs operator. The only caveat is that the nested select has to be a ``_select``, not a ``select``, and only one field has to be selected explicitly, the one that defines the set.</div><div class=""> </div><div class=""> ``nested select``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; bad_days = db(db.log.severity==3)._select(db.log.event_time)</div><div class=""> &gt;&gt;&gt; for row in db(db.log.event_time.belongs(bad_days)).select():</div><div class="">         print row.event</div><div class=""> port scan</div><div class=""> xss injection</div><div class=""> unauthorized login</div><div class=""> ``:code</div><div class=""> </div><div class="insert">+In those cases where a nested select is required and the loop-up field is a reference we can also use a query as argument. For example:</div><div class="insert">+</div><div class="insert">+``</div><div class="insert">+db.define_table(&#x27;person&#x27;,Field(&#x27;name&#x27;))</div><div class="insert">+db.define_table(&#x27;thing&#x27;,Field(&#x27;owner&#x27;),Field(&#x27;owner&#x27;,&#x27;reference thing&#x27;))</div><div class="insert">+db(db.thing.owner.belongs(db.person.name==&#x27;Johnathan&#x27;)).select()</div><div class="insert">+``:cite</div><div class="insert">+</div><div class="insert">+In this case it is obvious that the next select only needs the field referenced by the ``db.thing.owner` field so we do not need the more verbose ``_select`` notation.</div><div class="insert">+</div><div class="insert">+#### ``sum``, ``avg``, ``min``, ``max`` and ``len``</div><div class=""> </div><div class="insert">``sum<span class="highlight">``:inxx ``avg</span>``:inxx ``min``:inxx ``max``:inxx</div><div class=""> Previously, you have used the count operator to count records. Similarly, you can use the sum operator to add (sum) the values of a specific field from a group of records. As in the case of count, the result of a sum is retrieved via the store object:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; sum = db.log.severity.sum()</div><div class=""> &gt;&gt;&gt; print db().select(sum).first()[sum]</div><div class=""> 6</div><div class=""> ``:code</div><div class=""> </div><div class="insert">You can also use ``<span class="highlight">avg``, ``</span>min``<span class="highlight">,</span> and ``max`` to the <span class="highlight">average, </span>mininum<span class="highlight">,</span> and maximum value<span class="highlight"> respectively</span> for the selected records<span class="highlight">. For example:</span></div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; max = db.log.severity.max()</div><div class=""> &gt;&gt;&gt; print db().select(max).first()[max]</div><div class=""> 3</div><div class=""> ``:code</div><div class=""> </div><div class=""> ``.len()`` computes the length of a string, text or boolean fields.</div><div class=""> </div><div class=""> Expressions can be combined to form more complex expressions. For example here we are computing the sum of the length of all the severity strings in the logs, increased of one:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; sum = (db.log.severity.len()+1).sum()</div><div class=""> &gt;&gt;&gt; print db().select(sum).first()[sum]</div><div class=""> ``:code</div><div class=""> </div><div class=""> #### Substrings</div><div class=""> </div><div class="insert">One can build an expression to refer to a substring. For example, we can group <span class="highlight">thin</span>gs whose name starts with the same three characters and select only one from each group:</div><div class=""> </div><div class=""> ``</div><div class="insert">db(db.<span class="highlight">thin</span>g).select(dictinct = db.<span class="highlight">thin</span>g.name[:3])</div><div class=""> ``:code</div><div class=""> </div><div class=""> </div><div class=""> #### Default values with ``coalesce`` and ``coalesce_zero``</div><div class=""> </div><div class=""> There are times when you need to pull a value from database but also need a default values if the value for a record is set to NULL. In SQL there is a keyword, ``COALESCE``, for this. web2py has an equivalent ``coalesce`` method:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;sysuser&#x27;,Field(&#x27;username&#x27;),Field(&#x27;fullname&#x27;))</div><div class=""> &gt;&gt;&gt; db.sysuser.insert(username=&#x27;max&#x27;,fullname=&#x27;Max Power&#x27;)</div><div class=""> &gt;&gt;&gt; db.sysuser.insert(username=&#x27;tim&#x27;,fullname=None)</div><div class=""> print db(db.sysuser).select(db.sysuser.fullname.coalesce(db.sysuser.username))</div><div class=""> &quot;COALESCE(sysuser.fullname,sysuser.username)&quot;</div><div class=""> Max Power</div><div class=""> tim</div><div class=""> ``</div><div class=""> </div><div class=""> Other times you need to compute a mathematical expression but some fields have a value set to None while it should be zero.</div><div class=""> ``coalesce_zero`` comes to the rescue by defaulting None to zero in the query:</div><div class=""> </div><div class=""> And finally, here is ``_update`` ``_update``:inxx</div><div class=""> &gt;&gt;&gt; print db(db.person.name==&#x27;Alex&#x27;)._update()</div><div class=""> UPDATE person SET  WHERE person.name=&#x27;Alex&#x27;;</div><div class=""> ``:code</div><div class=""> </div><div class=""> -----</div><div class=""> Moreover you can always use ``db._lastsql`` to return the most recent</div><div class=""> SQL code, whether it was executed manually using executesql or was SQL</div><div class=""> generated by the DAL.</div><div class=""> -----</div><div class=""> </div><div class=""> ### Exporting and importing data</div><div class=""> ``export``:inxx ``import``:inxx</div><div class=""> </div><div class=""> #### CSV (one Table at a time)</div><div class=""> </div><div class=""> When a DALRows object is converted to a string it is automatically</div><div class=""> serialized in CSV:</div><div class=""> </div><div class=""> ``csv``:inxx</div><div class=""> ``</div><div class="insert">&gt;&gt;&gt; rows = db(db.person.id==db.<span class="highlight">thin</span>g.owner).select()</div><div class=""> &gt;&gt;&gt; print rows</div><div class="insert">+person.id,person.name,thing.id,thing.name,thing.owner</div><div class="insert">+1,Alex,1,Boat,1</div><div class="insert">+1,Alex,2,Chair,1</div><div class="insert">+2,Bob,3,Shoes,2</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can serialize a single table in CSV and store it in a file &quot;test.csv&quot;:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; open(&#x27;test.csv&#x27;, &#x27;w&#x27;).write(str(db(db.person.id).select()))</div><div class=""> ``:code</div><div class=""> </div><div class=""> and you can easily read it back with:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.person.import_from_csv_file(open(&#x27;test.csv&#x27;, &#x27;r&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class=""> When importing, web2py looks for the field names in the CSV header. In this example, it finds two columns: &quot;person.id&quot; and &quot;person.name&quot;. It ignores the &quot;person.&quot; prefix, and it ignores the &quot;id&quot; fields. Then all records are appended and assigned new ids. Both of these operations can be performed via the appadmin web interface.</div><div class=""> </div><div class=""> #### CSV (all tables at once)</div><div class=""> </div><div class=""> In web2py, you can backup/restore an entire database with two commands:</div><div class=""> </div><div class=""> To export:</div><div class=""> ``</div><div class=""> Two tables are separated ``\r\n\r\n``. The file ends with the line</div><div class=""> END</div><div class=""> ``:code</div><div class=""> </div><div class=""> The file does not include uploaded files if these are not stored in the database. In any case it is easy enough to zip the &quot;uploads&quot; folder separately.</div><div class=""> </div><div class=""> When importing, the new records will be appended to the database if it is not empty. In general the new imported records will not have the same record id as the original (saved) records but web2py will restore references so they are not broken, even if the id values may change.</div><div class=""> </div><div class=""> If a table contains a field called</div><div class=""> &quot;uuid&quot;, this field will be used to identify duplicates.  Also, if an</div><div class=""> imported record has the same &quot;uuid&quot; as an existing record, the</div><div class=""> previous record will be updated.</div><div class=""> </div><div class=""> #### CSV and remote database synchronization</div><div class=""> </div><div class=""> Consider the following model:</div><div class=""> ``</div><div class=""> db = DAL(&#x27;sqlite:memory:&#x27;)</div><div class=""> db.define_table(&#x27;person&#x27;,</div><div class="">     Field(&#x27;name&#x27;),</div><div class="">     format=&#x27;%(name)s&#x27;)</div><div class="insert">db.define_table(&#x27;<span class="highlight">thin</span>g&#x27;,</div><div class="">     Field(&#x27;owner&#x27;, &#x27;reference person&#x27;),</div><div class="">     Field(&#x27;name&#x27;),</div><div class="">     format=&#x27;%(name)s&#x27;)</div><div class=""> </div><div class=""> if not db(db.person).count():</div><div class="">     id = db.person.insert(name=&quot;Massimo&quot;)</div><div class="insert">    db.<span class="highlight">thin</span>g.insert(owner=id, name=&quot;<span class="highlight">Chair</span>&quot;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> Each record is identified by an ID and referenced by that ID. If you</div><div class=""> have two copies of the database used by distinct web2py installations,</div><div class=""> the ID is unique only within each database and not across the databases.</div><div class=""> This is a problem when merging records from different databases.</div><div class=""> </div><div class=""> In order to make a record uniquely identifiable across databases, they</div><div class=""> must:</div><div class=""> - have a unique id (UUID),</div><div class=""> - have an event_time (to figure out which one is more recent if multiple copies),</div><div class=""> - reference the UUID instead of the id.</div><div class=""> </div><div class=""> This can be achieved without modifying web2py. Here is what to do:</div><div class=""> </div><div class=""> **1.** Change the above model into:</div><div class=""> </div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;,</div><div class="">     Field(&#x27;uuid&#x27;, length=64, default=lambda:str(uuid.uuid4())),</div><div class="">     Field(&#x27;modified_on&#x27;, &#x27;datetime&#x27;, default=now),</div><div class="">     Field(&#x27;name&#x27;),</div><div class="">     format=&#x27;%(name)s&#x27;)</div><div class=""> </div><div class="insert">db.define_table(&#x27;<span class="highlight">thin</span>g&#x27;,</div><div class="">     Field(&#x27;uuid&#x27;, length=64, default=lambda:str(uuid.uuid4())),</div><div class="">     Field(&#x27;modified_on&#x27;, &#x27;datetime&#x27;, default=now),</div><div class="">     Field(&#x27;owner&#x27;, length=64),</div><div class="">     Field(&#x27;name&#x27;),</div><div class="">     format=&#x27;%(name)s&#x27;)</div><div class=""> </div><div class="insert">db.<span class="highlight">thin</span>g.owner.requires = IS_IN_DB(db,&#x27;person.uuid&#x27;,&#x27;%(name)s&#x27;)</div><div class=""> </div><div class=""> if not db(db.person.id).count():</div><div class="">     id = uuid.uuid4()</div><div class="">     db.person.insert(name=&quot;Massimo&quot;, uuid=id)</div><div class="insert">    db.<span class="highlight">thin</span>g.insert(owner=id, name=&quot;<span class="highlight">Chair</span>&quot;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> -------</div><div class=""> Note, in the above table definitions, the default value for the two &#x27;uuid&#x27; fields is set to a lambda function, which returns a UUID (converted to a string). The lambda function is called once for each record inserted, ensuring that each record gets a unique UUID, even if multiple records are inserted in a single transaction.</div><div class=""> -------</div><div class=""> </div><div class=""> **2.** Create a controller action to export the database:</div><div class=""> </div><div class=""> ``</div><div class=""> def export():</div><div class="">     s = StringIO.StringIO()</div><div class="">     db.export_to_csv_file(s)</div><div class="">     response.headers[&#x27;Content-Type&#x27;] = &#x27;text/csv&#x27;</div><div class="">     return s.getvalue()</div><div class=""> ``:code</div><div class=""> </div><div class=""> **3.** Create a controller action to import a saved copy of the other database and sync records:</div><div class=""> </div><div class=""> ``</div><div class=""> def import_and_sync():</div><div class=""> specific for this example.</div><div class=""> ``XML-RPC``:inxx</div><div class=""> Alternatively, you can use XML-RPC to export/import the file.</div><div class=""> </div><div class=""> If the records reference uploaded files, you also need to export/import the content of the uploads folder. Notice that files therein are already labeled by UUIDs so you do not need to worry about naming conflicts and references.</div><div class=""> </div><div class=""> #### HTML and XML (one Table at a time)</div><div class=""> </div><div class=""> ``DALRows objects``:inxx</div><div class=""> DALRows objects also have an ``xml`` method (like helpers) that serializes it to XML/HTML:</div><div class=""> </div><div class=""> ``HTML``:inxx</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows = db(db.person.id &gt; 0).select()</div><div class=""> &gt;&gt;&gt; print rows.xml()</div><div class=""> &lt;table&gt;</div><div class="">   &lt;thead&gt;</div><div class="">     &lt;tr&gt;</div><div class="">       &lt;th&gt;person.id&lt;/th&gt;</div><div class="">       &lt;th&gt;person.name&lt;/th&gt;</div><div class="insert">+      &lt;th&gt;thing.id&lt;/th&gt;</div><div class="insert">+      &lt;th&gt;thing.name&lt;/th&gt;</div><div class="insert">+      &lt;th&gt;thing.owner&lt;/th&gt;</div><div class="">     &lt;/tr&gt;</div><div class="">   &lt;/thead&gt;</div><div class="">   &lt;tbody&gt;</div><div class="">     &lt;tr class=&quot;even&quot;&gt;</div><div class="">       &lt;td&gt;1&lt;/td&gt;</div><div class="">       &lt;td&gt;Alex&lt;/td&gt;</div><div class="">       &lt;td&gt;1&lt;/td&gt;</div><div class="insert">      &lt;td&gt;<span class="highlight">Boat</span>&lt;/td&gt;</div><div class="">       &lt;td&gt;1&lt;/td&gt;</div><div class="">     &lt;/tr&gt;</div><div class="">     ...</div><div class="">   &lt;/tbody&gt;</div><div class=""> &lt;/table&gt;</div><div class=""> ``:code</div></div></div>
    <div class="span6"><div class="diff"><div class="delete">web2py comes with a Database Abstraction Layer (DAL), an API that maps Python objects into database objects such as queries, tables, and records. The DAL dynamically generates the SQL in real time using the specified dialect for the database back end, so that you do not have to write SQL code or learn different SQL dialects (the term SQL is used generically), and the application will be portable among different types of databases. At the time of this writing, the supported databases are SQLite (which comes with Python and thus web2py), PostgreSQL, MySQL, Oracle, MSSQL, FireBird, DB2, Informix, <span class="highlight">and </span>Ingres<span class="highlight"> and</span> (<span class="highlight">partially</span>) <span class="highlight">the Google App Engine (SQL and NoSQL)</span>. Experimentally we support more databases. Please check on the web2py web site and mailing list for more recent adapters. Google NoSQL is treated as a particular case in Chapter 13.</div><div class=""> </div><div class=""> The Windows binary distribution works out of the box with SQLite and MySQL. The Mac binary distribution works out of the box with SQLite.</div><div class=""> To use any other database back-end, run from the source distribution and install the appropriate driver for the required back end.</div><div class=""> ``database drivers``:inxx</div><div class=""> </div><div class=""> Once the proper driver is installed, start web2py from source, and it will find the driver. Here is a list of drivers:</div><div class=""> </div><div class=""> ----------</div><div class="delete">database | driver<span class="highlight"></span> (source)</div><div class=""> SQLite | sqlite3 or pysqlite2 or zxJDBC ``zxjdbc``:cite  (on Jython)</div><div class="delete">PostgreSQL | psycopg2 ``psycopg2``:cite  or <span class="highlight"></span>zxJDBC ``zxjdbc``:cite  (on Jython)</div><div class=""> MySQL | pymysql ``pymysql``:cite or MySQLdb ``mysqldb``:cite</div><div class=""> Oracle | cx_Oracle ``cxoracle``:cite</div><div class=""> MSSQL | pyodbc ``pyodbc``:cite</div><div class="delete">FireBird | kinterbasdb ``kinterbasdb``:cite<span class="highlight"></span></div><div class=""> DB2 | pyodbc ``pyodbc``:cite</div><div class=""> Informix | informixdb ``informixdb``:cite</div><div class=""> Ingres | ingresdbi ``ingresdbi``:cite</div><div class=""> ---------</div><div class=""> </div><div class="delete"><span class="highlight">(</span>``pymysql``<span class="highlight"></span> ship<span class="highlight">s</span> with web2py<span class="highlight">)</span></div><div class=""> </div><div class=""> web2py defines the following classes that make up the DAL:</div><div class=""> </div><div class=""> **DAL** represents a database connection. For example:</div><div class=""> ``sqlite``:inxx</div><div class=""> ``</div><div class=""> db = DAL(&#x27;sqlite://storage.db&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> ``define_table``:inxx</div><div class=""> **Table** represents a database table.  You do not directly instantiate Table; instead, ``DAL.define_table`` instantiates it.</div><div class=""> ``</div><div class=""> db.define_table(&#x27;mytable&#x27;, Field(&#x27;myfield&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class=""> The most important methods of a Table are:</div><div class=""> ``insert``:inxx</div><div class=""> ``truncate``:inxx</div><div class=""> ``drop``:inxx</div><div class=""> ``import_from_csv_file``:inxx</div><div class=""> db().select(db.table.ALL, orderby=myorder)</div><div class=""> ``:code</div><div class=""> </div><div class=""> ### Connection strings</div><div class=""> ``connection strings``:inxx</div><div class=""> </div><div class=""> A connection with the database is established by creating an instance of the DAL object:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db = DAL(&#x27;sqlite://storage.db&#x27;, pool_size=0)</div><div class=""> ``:code</div><div class=""> ``db`` is not a keyword; it is a local variable that stores the connection object ``DAL``. You are free to give it a different name. The constructor of ``DAL`` requires a single argument, the connection string. The connection string is the only web2py code that depends on a specific back-end database. Here are examples of connection strings for specific types of supported back-end databases (in all cases, we assume the database is running from localhost on its default port and is named &quot;test&quot;):</div><div class=""> </div><div class=""> -------------</div><div class=""> **SQLite**     | ``sqlite://storage.db``</div><div class=""> **MySQL**      | ``mysql://username:password@localhost/test``</div><div class=""> **PostgreSQL** | ``postgres://username:password@localhost/test``</div><div class=""> **MSSQL**      | ``mssql://username:password@localhost/test``</div><div class=""> **FireBird**   | ``firebird://username:password@localhost/test``</div><div class=""> **Oracle**     | ``oracle://username/password@test``</div><div class=""> **DB2**        | ``db2://username:password@test``</div><div class=""> **Ingres**     | ``ingres://username:password@localhost/test``</div><div class=""> **Informix**   | ``informix://username:password@test``</div><div class=""> **Google App Engine/SQL** | ``google:sql``</div><div class=""> **Google App Engine/NoSQL** | ``google:datastore``</div><div class=""> -------------</div><div class=""> </div><div class=""> Notice that in SQLite the database consists of a single file. If it does not exist, it is created. This file is locked every time it is accessed. In the case of MySQL, PostgreSQL, MSSQL, FireBird, Oracle, DB2, Ingres and Informix the database &quot;test&quot; must be created outside web2py. Once the connection is established, web2py will create, alter, and drop tables appropriately.</div><div class=""> </div><div class=""> It is also possible to set the connection string to ``None``. In this case DAL will not connect to any back-end database, but the API can still be accessed for testing. Examples of this will be discussed in Chapter 7.</div><div class=""> </div><div class=""> #### Connection pooling</div><div class=""> ``connection pooling``:inxx</div><div class=""> </div><div class=""> The second argument of the DAL constructor is the ``pool_size``; it defaults to 0.</div><div class=""> </div><div class=""> As it is rather slow to establish a new database connection for each request, web2py implements a mechanism for connection pooling. Once a connection is established and the page has been served and the transaction completed, the connection is not closed but goes into a pool. When the next http request arrives, web2py tries to obtain a connection from the pool and use that for the new transaction. If there are no available connections in the pool, a new connection is established.</div><div class=""> </div><div class=""> The ``pool_size`` parameter is ignored by SQLite and Google App Engine.</div><div class=""> </div><div class=""> Connections in the pools are shared sequentially among threads, in the sense that they may be used by two different but not simultaneous threads. There is only one pool for each web2py process.</div><div class=""> </div><div class=""> When web2py starts, the pool is always empty. The pool grows up to the minimum between the value of ``pool_size`` and the max number of concurrent requests. This means that if ``pool_size=10`` but our server never receives more than 5 concurrent requests, then the actual pool size will only grow to 5. If ``pool_size=0`` then connection pooling is not used.</div><div class=""> For supported back-ends you may also specify if you would like to check against</div><div class=""> ``</div><div class=""> check_reserved=[&#x27;postgres&#x27;, &#x27;postgres_nonreserved&#x27;]</div><div class=""> ``:code</div><div class=""> </div><div class=""> The following database backends support reserved words checking.</div><div class=""> </div><div class=""> -----</div><div class=""> **PostgreSQL** | ``postgres(_nonreserved)``</div><div class=""> **MySQL** | ``mysql``</div><div class=""> **FireBird** | ``firebird(_nonreserved)``</div><div class=""> **MSSQL** | ``mssql``</div><div class=""> **Oracle** | ``oracle``</div><div class=""> -----</div><div class=""> </div><div class=""> ### ``DAL``, ``Table``, ``Field``</div><div class=""> </div><div class=""> The best way to understand the DAL API is to try each function yourself. This can be done interactively via the web2py shell, although ultimately, DAL code goes in the models and controllers.</div><div class=""> </div><div class=""> Start by creating a connection. For the sake of example, you can use SQLite. Nothing in this discussion changes when you change the back-end engine.</div><div class=""> </div><div class="delete">-``DAL``:inxx ``SQLite``:inxx ``MySQL``:inxx ``PostgresSQL``:inxx ``Oracle``:inxx ``MSSQL``:inxx ``FireBird``:inxx ``DB2``:inxx ``Informix``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db = DAL(&#x27;sqlite://storage.db&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> The database is now connected and the connection is stored in the global variable ``db``.</div><div class=""> </div><div class=""> At any time you can retrieve the connection string.</div><div class=""> ``_uri``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; print db._uri</div><div class=""> sqlite://storage.db</div><div class=""> ``:code</div><div class=""> </div><div class=""> and the database name</div><div class=""> ``_dbname``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; print db._dbname</div><div class=""> sqlite</div><div class=""> ``:code</div><div class=""> </div><div class=""> or even more complex ones using a function:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;),</div><div class="">        format=lambda r: r.name or &#x27;anonymous&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> The format attribute will be used for two purposes:</div><div class=""> - To represent referenced records in select/option drop-downs.</div><div class=""> - To set the ``db.othertable.person.represent`` attribute for all fields referencing this table. This means that SQLTABLE will not show references by id but will use the format preferred representation instead.</div><div class=""> </div><div class=""> </div><div class=""> ``Field constructor``:inxx</div><div class=""> These are the default values of a Field constructor:</div><div class=""> ``</div><div class=""> Field(name, &#x27;string&#x27;, length=None, default=None,</div><div class="">       required=False, requires=&#x27;&lt;default&gt;&#x27;,</div><div class="">       ondelete=&#x27;CASCADE&#x27;, notnull=False, unique=False,</div><div class="">       uploadfield=True, widget=None, label=None, comment=None,</div><div class="">       writable=True, readable=True, update=None, authorize=None,</div><div class="">       autodelete=False, represent=None, compute=None,</div><div class="">       uploadfolder=os.path.join(request.folder,&#x27;uploads&#x27;),</div><div class="delete">      uploadseparate=None<span class="highlight"></span>)</div><div class=""> ``:code</div><div class=""> </div><div class=""> Not all of them are relevant for every field. &quot;length&quot; is relevant only for fields of type &quot;string&quot;. &quot;uploadfield&quot; and &quot;authorize&quot; are relevant only for fields of type &quot;upload&quot;. &quot;ondelete&quot; is relevant only for fields of type &quot;reference&quot; and &quot;upload&quot;.</div><div class=""> - ``length`` sets the maximum length of a &quot;string&quot;, &quot;password&quot; or &quot;upload&quot; field.  If ``length`` is not specified a default value is used but the default value is not guaranteed to be backward compatible. &#x27;&#x27;To avoid unwanted migrations on upgrades, we recommend that you always specify the length for string, password and upload fields.&#x27;&#x27;</div><div class=""> - ``default`` sets the default value for the field. The default value is used when performing an insert if a value is not explicitly specified. It is also used to pre-populate forms built from the table using SQLFORM. Note, rather than being a fixed value, the default can instead be a function (including a lambda function) that returns a value of the appropriate type for the field. In that case, the function is called once for each record inserted, even when multiple records are inserted in a single transaction.</div><div class=""> - ``required`` tells the DAL that no insert should be allowed on this table if a value for this field is not explicitly specified.</div><div class=""> - ``requires`` is a validator or a list of validators. This is not used by the DAL, but it is used by SQLFORM. The default validators for the given types are shown in the following table:</div><div class=""> </div><div class=""> ----------</div><div class=""> **field type** | **default field validators**</div><div class=""> ``string`` | ``IS_LENGTH(length)`` default length is 512</div><div class=""> ``text`` | ``IS_LENGTH(65536)``</div><div class=""> ``blob`` | ``None``</div><div class=""> ``boolean`` | ``None``</div><div class=""> ``integer`` | ``IS_INT_IN_RANGE(-1e100, 1e100)``</div><div class=""> ``double`` | ``IS_FLOAT_IN_RANGE(-1e100, 1e100)``</div><div class=""> ``decimal(n,m)`` | ``IS_DECIMAL_IN_RANGE(-1e100, 1e100)``</div><div class=""> ``date`` | ``IS_DATE()``</div><div class=""> ``time`` | ``IS_TIME()``</div><div class=""> ``datetime`` | ``IS_DATETIME()``</div><div class=""> ``password`` | ``None``</div><div class=""> ``upload`` | ``None``</div><div class=""> ``reference &lt;table&gt;``  | ``IS_IN_DB(db,table.field,format)``</div><div class=""> ``list:string`` | ``None``</div><div class=""> ``list:integer`` | ``None``</div><div class=""> ``list:reference &lt;table&gt;`` | ``IS_IN_DB(db,table.field,format,multiple=True)``</div><div class=""> ---------</div><div class=""> </div><div class=""> Decimal requires and returns values as ``Decimal`` objects, as defined in the Python ``decimal`` module. SQLite does not handle the ``decimal`` type so internally we treat it as a ``double``. The (n,m) are the number of digits in total and the number of digits after the decimal point respectively.</div><div class=""> </div><div class=""> The ``list:`` fields are special because they are designed to take advantage of certain denormalization features on NoSQL (in the case of Google App Engine NoSQL, the field types ``ListProperty`` and ``StringListProperty``) and back-port them all the other supported relational databases. On relational databases lists are stored as a ``text`` field. The items are separated by a ``|`` and each ``|`` in string item is escaped as a ``||``. They are discussed in their own section.</div><div class=""> </div><div class=""> -------</div><div class=""> Notice that ``requires=...`` is enforced at the level of forms, ``required=True`` is enforced at the level of the DAL (insert), while ``notnull``, ``unique`` and ``ondelete`` are enforced at the level of the database. While they sometimes may seem redundant, it is important to maintain the distinction when programming with the DAL.</div><div class=""> -------</div><div class=""> </div><div class=""> ``ondelete``:inxx</div><div class=""> </div><div class=""> - ``ondelete`` translates into the &quot;ON DELETE&quot; SQL statement. By default it is set to &quot;CASCADE&quot;. This tells the database that when it deletes a record, it should also delete all records that refer to it. To disable this feature, set ``ondelete`` to &quot;NO ACTION&quot; or &quot;SET NULL&quot;.</div><div class=""> - ``notnull=True`` translates into the &quot;NOT NULL&quot; SQL statement. It prevents the database from inserting null values for the field.</div><div class=""> - ``unique=True`` translates into the &quot;UNIQUE&quot; SQL statement and it makes sure that values of this field are unique within the table. It is enforced at the database level.</div><div class=""> - ``uploadfield`` applies only to fields of type &quot;upload&quot;. A field of type &quot;upload&quot; stores the name of a file saved somewhere else, by default on the filesystem under the application &quot;uploads/&quot; folder. If ``uploadfield`` is set, then the file is stored in a blob field within the same table and the value of ``uploadfield`` is the name of the blob field. This will be discussed in more detail later in the context of SQLFORM.</div><div class=""> - ``uploadfolder`` defaults to the application&#x27;s &quot;uploads/&quot; folder. If set to a different path, files will uploaded to a different folder. For example, uploadfolder=os.path.join(request.folder,&#x27;static/temp&#x27;) will upload files to the web2py/applications/myapp/static/temp folder.</div><div class=""> - ``uploadseparate`` if set to True will upload files under different subfolders of the &#x27;&#x27;uploadfolder&#x27;&#x27; folder. This is optimized to avoid too many files under the same folder/subfolder. ATTENTION: You cannot change the value of ``uploadseparate`` from True to False without breaking the system. web2py either uses the separate subfolders or it does not. Changing the behavior after files have been uploaded will prevent web2py from being able to retrieve those files. If this happens it is possible to move files and fix the problem but this is not described here.</div><div class=""> - ``widget`` must be one of the available widget objects, including custom widgets, for example: ``SQLFORM.widgets.string.widget``. A list of available widgets will be discussed later. Each field type has a default widget.</div><div class=""> - ``label`` is a string (or something that can be serialized to a string) that contains the label to be used for this field in autogenerated forms.</div><div class=""> - ``comment``  is a string (or something that can be serialized to a string) that contains a comment associated with this field, and will be displayed to the right of the input field in the autogenerated forms.</div><div class=""> - ``writable`` if a field is writable, it can be edited in autogenerated create and update forms.</div><div class=""> - ``readable`` if a field is readable, it will be visible in readonly forms. If a field is neither readable nor writable, it will not be displayed in create and update forms.</div><div class=""> - ``update`` contains the default value for this field when the record is updated.</div><div class=""> - ``compute`` is an optional function. If a record is inserted or updated, the compute function will be executed and the field will be populated with the function result. The record is passed to the compute function as a ``dict``, and the dict will not include the current value of that, or any other compute field.</div><div class=""> - ``authorize`` can be used to require access control on the corresponding field, for &quot;upload&quot; fields only. It will be discussed more in detail in the context of Authentication and Authorization.</div><div class=""> - ``autodelete`` determines if the corresponding uploaded file should be deleted when the record referencing the file is deleted. For &quot;upload&quot; fields only.</div><div class=""> - ``represent`` can be None or can point to a function that takes a field value and returns an alternate representation for the field value. Examples:</div><div class=""> ``</div><div class=""> db.mytable.name.represent = lambda name,row: name.capitalize()</div><div class=""> db.mytable.other_id.represent = lambda id,row: row.myfield</div><div class=""> db.mytable.some_uploadfield.represent = lambda value,row: \</div><div class="">     A(&#x27;get it&#x27;, _href=URL(&#x27;download&#x27;, args=value))</div><div class=""> ``:code</div><div class=""> </div><div class=""> ``blob``:inxx</div><div class=""> &quot;blob&quot; fields are also special. By default, binary data is encoded in base64 before being stored into the actual database field, and it is decoded when extracted. This has the negative effect of using 25% more storage space than necessary in blob fields, but has two advantages. On average it reduces the amount of data communicated between web2py and the database server, and it makes the communication independent of back-end-specific escaping conventions.</div><div class=""> </div><div class=""> The DAL allows you to explicitly issue SQL statements.</div><div class=""> &gt;&gt;&gt; print db.executesql(&#x27;SELECT * FROM person;&#x27;)</div><div class=""> [(1, u&#x27;Massimo&#x27;), (2, u&#x27;Massimo&#x27;)]</div><div class=""> ``:code</div><div class=""> </div><div class=""> In this case, the return values are not parsed or transformed by the DAL, and the format depends on the specific database driver. This usage with selects is normally not needed, but it is more common with indexes.</div><div class=""> ``executesql`` takes two optional arguments: ``placeholders`` and ``as_dict``</div><div class=""> ``placeholders`` is an optional</div><div class=""> sequence of values to be substituted in</div><div class=""> or, if supported by the DB driver, a dictionary with keys</div><div class=""> matching named placeholders in your SQL.</div><div class=""> </div><div class=""> If ``as_dict`` is set to True,</div><div class=""> and the results cursor returned by the DB driver will be</div><div class=""> converted to a sequence of dictionaries keyed with the db</div><div class=""> field names.  Results returned with ``as_dict = True ``are</div><div class=""> the same as those returned when applying **.as_list()** to a normal select.</div><div class=""> ``</div><div class=""> [{field1: value1, field2: value2}, {field1: value1b, field2: value2b}]</div><div class=""> ``:code</div><div class=""> </div><div class=""> #### ``_lastsql``</div><div class=""> </div><div class=""> Whether SQL was executed manually using executesql or was SQL generated by the DAL, you can always find the SQL code in ``db._lastsql``. This is useful for debugging purposes:</div><div class=""> </div><div class=""> ``_lastdb``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows = db().select(db.person.ALL)</div><div class=""> &gt;&gt;&gt; print db._lastsql</div><div class=""> SELECT person.id, person.name FROM person;</div><div class=""> ``:code</div><div class=""> </div><div class=""> -------</div><div class=""> web2py never generates queries using the &quot;*&quot; operator. web2py is always explicit when selecting fields.</div><div class=""> -------</div><div class=""> </div><div class=""> ### ``drop``</div><div class=""> </div><div class=""> Finally, you can drop tables and all data will be lost:</div><div class=""> </div><div class=""> ``drop``:inxx</div><div class=""> db.define_table(&#x27;account&#x27;,</div><div class="">     Field(&#x27;accnum&#x27;,&#x27;integer&#x27;),</div><div class="">     Field(&#x27;acctype&#x27;),</div><div class="">     Field(&#x27;accdesc&#x27;),</div><div class="">     primarykey=[&#x27;accnum&#x27;,&#x27;acctype&#x27;],</div><div class="">     migrate=False)</div><div class=""> ``:code</div><div class=""> </div><div class=""> - ``primarykey`` is a list of the field names that make up the primary key. </div><div class=""> - All primarykey fields have a ``NOT NULL`` set even if not specified.</div><div class=""> - Keyed table can only refer are to other keyed tables.</div><div class=""> - Referenceing fields must use the ``reference tablename.fieldname`` format.</div><div class=""> - The ``update_record`` function is not available for Rows of keyed tables.</div><div class=""> </div><div class=""> -------</div><div class=""> Note that currently this is only available for DB2, MS-SQL, Ingres and Informix, but others can be easily added.</div><div class=""> -------</div><div class=""> </div><div class=""> At the time of writing, we cannot guarantee that the ``primarykey`` attribute works with every existing legacy table and every supported database backend.</div><div class=""> For simplicity, we recommend, if possible, creating a database view that has an auto-increment id field.</div><div class=""> </div><div class=""> ### Distributed transaction</div><div class=""> ``distributed transactions``:inxx</div><div class=""> </div><div class=""> ------</div><div class=""> At the time of writing this feature is only supported</div><div class=""> by PostgreSQL, MySQL and Firebird, since they expose API for two-phase commits.</div><div class=""> ------</div><div class=""> </div><div class=""> Assuming you have two (or more) connections to distinct PostgreSQL databases, for example:</div><div class=""> ``</div><div class=""> db_a = DAL(&#x27;postgres://...&#x27;)</div><div class=""> db_b = DAL(&#x27;postgres://...&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> In your models or controllers, you can commit them concurrently with:</div><div class=""> ``</div><div class=""> DAL.distributed_transaction_commit(db_a, db_b)</div><div class=""> ``:code</div><div class=""> </div><div class=""> On failure, this function rolls back and raises an ``Exception``.</div><div class=""> </div><div class=""> In controllers, when one action returns, if you have two distinct connections and you do not call the above function, web2py commits them separately. This means there is a possibility that one of the commits succeeds and one fails. The distributed transaction prevents this from happening.</div><div class=""> </div><div class="delete">### M<span class="highlight">a</span>n<span class="highlight">ual</span> uploads</div><div class=""> </div><div class=""> Consider the following model:</div><div class=""> ``</div><div class="delete">-&gt;&gt;&gt; db.define_table(&#x27;myfile&#x27;, Field(&#x27;image&#x27;, &#x27;upload&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class=""> Normally an insert is handled automatically via a SQLFORM or a crud form (which is a SQLFORM) but occasionally you already have the file on the filesystem and want to upload it programmatically. This can be done in this way:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; stream = open(filename, &#x27;rb&#x27;)</div><div class=""> &gt;&gt;&gt; db.myfile.insert(image=db.myfile.image.store(stream, filename))</div><div class=""> ``:code</div><div class=""> </div><div class=""> The ``store`` method of the upload field object takes a file stream and a filename. It uses the filename to determine the extension (type) of the file, creates a new temp name for the file (according to web2py upload mechanism) and loads the file content in this new temp file (under the uploads folder unless specified otherwise). It returns the new temp name, which is then stored in the ``image`` field of the ``db.myfile`` table.</div><div class=""> </div><div class=""> Note, if the file is to be stored in an associated blob field rather than the file system, the ``store()`` method will not insert the file in the blob field (because ``store()`` is called before the insert), so the file must be explicitly inserted into the blob field:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;myfile&#x27;,</div><div class="">         Field(&#x27;image&#x27;, &#x27;upload&#x27;, uploadfield=&#x27;image_file&#x27;),</div><div class="">         Field(&#x27;image_file&#x27;, &#x27;blob&#x27;))</div><div class=""> &gt;&gt;&gt; stream = open(filename, &#x27;rb&#x27;)</div><div class=""> &gt;&gt;&gt; db.myfile.insert(image=db.myfile.image.store(stream, filename),</div><div class="">         image_file=stream.read())</div><div class=""> ``:code</div><div class=""> </div><div class=""> The opposite of ``.store`` is ``.retrieve``:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; row = db(db.myfile).select().first()</div><div class=""> &gt;&gt;&gt; (filename, stream) = db.myfile.image.retrieve(row.image)</div><div class=""> &gt;&gt;&gt; import shutil</div><div class=""> &gt;&gt;&gt; shutil.copyfileobj(stream,open(filename,&#x27;wb&#x27;))</div><div class=""> ``</div><div class=""> </div><div class=""> ### ``Query``, ``Set``, ``Rows``</div><div class=""> </div><div class=""> Let&#x27;s consider again the table defined (and dropped) previously and insert three records:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;))</div><div class=""> &gt;&gt;&gt; db.person.insert(name=&quot;Alex&quot;)</div><div class=""> 1</div><div class=""> &gt;&gt;&gt; db.person.insert(name=&quot;Bob&quot;)</div><div class=""> 2</div><div class=""> &gt;&gt;&gt; db.person.insert(name=&quot;Carl&quot;)</div><div class=""> 3</div><div class=""> which is equivalent to</div><div class=""> db(db.mytable.id==id).update(myfield=&#x27;somevalue&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> and it updates an existing record with field values specified by the dictionary on the right hand side.</div><div class=""> </div><div class=""> #### Fetching a ``Row``</div><div class=""> </div><div class=""> Yet another convenient syntax is the following:</div><div class=""> </div><div class=""> ``</div><div class=""> record = db.mytable(id)</div><div class=""> record = db.mytable(db.mytable.id==id)</div><div class=""> record = db.mytable(id,myfield=&#x27;somevalue&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> Apparently similar to ``db.mytable[id]`` the above syntax is more flexible and safer. First of all it checks whether ``id`` is an int (or ``str(id)`` is an int) and returns ``None`` if not (it never raises an exception). It also allows to specify multiple conditions that the record must meet. If they are not met, it also returns ``None``.</div><div class=""> </div><div class=""> #### Recursive ``select``s</div><div class=""> ``recursive selects``:inxx</div><div class=""> </div><div class="delete">Consider the previous table person and a new table &quot;<span class="highlight">do</span>g&quot; referencing a &quot;person&quot;:</div><div class=""> ``</div><div class="delete">&gt;&gt;&gt; db.define_table(&#x27;<span class="highlight">do</span>g&#x27;, Field(&#x27;name&#x27;), Field(&#x27;owner&#x27;,&#x27;reference person&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class=""> and a simple select from this table:</div><div class=""> ``</div><div class="delete">&gt;&gt;&gt; <span class="highlight">do</span>gs = db(db.<span class="highlight">do</span>g).select()</div><div class=""> ``:code</div><div class=""> </div><div class=""> which is equivalent to</div><div class=""> </div><div class=""> ``</div><div class="delete">&gt;&gt;&gt; <span class="highlight">do</span>gs = db(db.<span class="highlight">do</span>g._id&gt;0).select()</div><div class=""> ``:code</div><div class=""> </div><div class="delete">where ``._id`` is a reference to the primary key of the table. Normally ``db.<span class="highlight">do</span>g._id`` is the same as ``db.<span class="highlight">do</span>g.id`` and we will assume that in most of this book. ``_id``:inxx</div><div class=""> </div><div class=""> </div><div class="delete">For each Row of <span class="highlight">do</span>gs it is possible to fetch not just fields from the selected table (<span class="highlight">do</span>g) but also from linked tables (recursively):</div><div class=""> ``</div><div class="delete">&gt;&gt;&gt; for <span class="highlight">do</span>g in <span class="highlight">do</span>gs: print <span class="highlight">do</span>g.name, <span class="highlight">do</span>g.owner.name</div><div class=""> ``:code</div><div class=""> </div><div class="delete">Here ``<span class="highlight">do</span>g.owner.name`` requires one database select for each <span class="highlight">dog in do</span>gs and it is therefore inefficient. We suggest using joins whenever possible instead of recursive selects, nevertheless this is convenient and practical when accessing individual records.</div><div class=""> </div><div class="delete">You can also do it backwards, by selecting the <span class="highlight">do</span>gs referenced by a person:</div><div class=""> </div><div class=""> ``</div><div class=""> person =  db.person(id)</div><div class="delete">-for dog in person.dog.select(orderby=db.dog.name):</div><div class="delete">-    print person.name, &#x27;owns&#x27;, dog.name</div><div class=""> ``:code</div><div class=""> </div><div class="delete">In this last expressions ``person.<span class="highlight">do</span>g`` is a shortcut for</div><div class=""> </div><div class=""> ``</div><div class="delete">db(db.<span class="highlight">do</span>g.owner==person.id)</div><div class=""> ``:code</div><div class=""> </div><div class="delete">i.e. the Set of ``<span class="highlight">do</span>g``s referenced by the current ``person``. This syntax breaks down if the referencing table has multiple references to the referenced table. In this case one needs to be more explicit and use a full Query.</div><div class=""> </div><div class=""> </div><div class=""> #### Serializing ``Rows`` in views</div><div class=""> </div><div class=""> Given the following action containing a query</div><div class=""> ``SQLTABLE``:inxx</div><div class=""> </div><div class=""> ``</div><div class=""> def index()</div><div class="">     return dict(rows = db(query).select())</div><div class=""> ``:code</div><div class=""> </div><div class=""> The result of a select can be displayed in a view with the following syntax:</div><div class=""> ``</div><div class=""> {{extend &#x27;layout.html&#x27;}}</div><div class=""> &lt;h1&gt;Records&lt;/h1&gt;</div><div class=""> {{=rows}}</div><div class=""> ``:code</div><div class=""> </div><div class=""> Which is equivalent to:</div><div class=""> Due to Python restrictions in overloading &quot;``and``&quot; and &quot;``or``&quot; operators, thes</div><div class=""> </div><div class=""> It is also possible to build queries using in-place logical operators:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; query = db.person.name!=&#x27;Alex&#x27;</div><div class=""> &gt;&gt;&gt; query &amp;= db.person.id&gt;3</div><div class=""> &gt;&gt;&gt; query |= db.person.name==&#x27;John&#x27;</div><div class=""> ``</div><div class=""> </div><div class=""> #### ``count``, ``isempty``, ``delete``, ``update``</div><div class=""> </div><div class=""> You can count records in a set:</div><div class=""> </div><div class=""> ``count``:inxx ``isempty``:inxx</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; print db(db.person.id &gt; 0).count()</div><div class=""> 3</div><div class=""> ``:code</div><div class=""> </div><div class="delete">Notice that ``count`` takes an optional ``distinct`` argument which defaults to False, and it works very much like the same argument for ``select``.<span class="highlight"></span></div><div class=""> </div><div class=""> Sometimes you may need to check is a table is empty. A more efficient way than counting is using the ``isempty`` method:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; print db(db.person.id &gt; 0).isempty()</div><div class=""> False</div><div class=""> ``:code</div><div class=""> </div><div class=""> or equivalently:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; print db(db.person).isempty()</div><div class=""> False</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can delete records in a set:</div><div class=""> </div><div class=""> ``delete``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db(db.person.id &gt; 3).delete()</div><div class=""> In this case ``row.total_price`` is not a value but a function. The function tak</div><div class=""> </div><div class=""> The lazy field in the example above allows one to compute the total price for each ``item``:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db(db.item).select(): print row.total_price()</div><div class=""> ``</div><div class=""> </div><div class=""> And it also allows to pass an optional ``discount`` percentage (15%):</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db(db.item).select(): print row.total_price(15)</div><div class=""> ``</div><div class=""> </div><div class=""> ------</div><div class=""> Mind that virtual fields do not have the same attributes as the other fields (default, readable, requires, etc) and they do not appear in the list of ``db.table.fields`` and are not visualized by default in tables (TABLE) and grids (SQLFORM.grid, SQLFORM.smartgrid).</div><div class=""> ------</div><div class=""> </div><div class=""> ### One to many relation</div><div class=""> ``one to many``:inxx</div><div class=""> </div><div class="delete">To illustrate how to implement one to many relations with the web2py DAL, define another table &quot;<span class="highlight">do</span>g&quot; that refers to the table &quot;person&quot; which we redefine here:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;,</div><div class="">                     Field(&#x27;name&#x27;),</div><div class="">                     format=&#x27;%(name)s&#x27;)</div><div class="delete">&gt;&gt;&gt; db.define_table(&#x27;<span class="highlight">do</span>g&#x27;,</div><div class="">                     Field(&#x27;name&#x27;),</div><div class="">                     Field(&#x27;owner&#x27;, &#x27;reference person&#x27;),</div><div class="">                     format=&#x27;%(name)s&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class="delete">Table &quot;<span class="highlight">do</span>g&quot; has two fields, the name of the <span class="highlight">do</span>g and the owner of the <span class="highlight">do</span>g. When a field type is another table, it is intended that the field reference the other table by its id. In fact, you can print the actual type value and get:</div><div class=""> ``</div><div class="delete">&gt;&gt;&gt; print db.<span class="highlight">do</span>g.owner.type</div><div class=""> reference person</div><div class=""> ``:code</div><div class=""> </div><div class="delete">Now, insert three <span class="highlight">do</span>gs, two owned by Alex and one by Bob:</div><div class=""> ``</div><div class="delete">&gt;&gt;&gt; db.<span class="highlight">do</span>g.insert(name=&#x27;<span class="highlight">Skipper</span>&#x27;, owner=1)</div><div class=""> 1</div><div class="delete">&gt;&gt;&gt; db.<span class="highlight">do</span>g.insert(name=&#x27;<span class="highlight">Snoopy</span>&#x27;, owner=1)</div><div class=""> 2</div><div class="delete">&gt;&gt;&gt; db.<span class="highlight">do</span>g.insert(name=&#x27;<span class="highlight">Puppy</span>&#x27;, owner=2)</div><div class=""> 3</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can select as you did for any other table:</div><div class=""> ``</div><div class="delete">&gt;&gt;&gt; for row in db(db.<span class="highlight">do</span>g.owner==1).select():</div><div class="">         print row.name</div><div class="delete">-Skipper</div><div class="delete">-Snoopy</div><div class=""> ``:code</div><div class=""> </div><div class="delete">Because a <span class="highlight">do</span>g has a reference to a person, a person can have many <span class="highlight">do</span>gs, so a record of table person now acquires a new attribute <span class="highlight"></span>d<span class="highlight">og, which is a Set, that </span>d<span class="highlight">efines the dogs of that person. This allows looping over all persons and fetching their do</span>gs easily:</div><div class=""> </div><div class=""> ``referencing``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for person in db().select(db.person.ALL):</div><div class="">         print person.name</div><div class="delete">-        for dog in person.dog.select():</div><div class="delete">-            print &#x27;    &#x27;, dog.name</div><div class=""> Alex</div><div class="delete">-     Skipper</div><div class="delete">-     Snoopy</div><div class=""> Bob</div><div class="delete">     <span class="highlight">Puppy</span></div><div class=""> Carl</div><div class=""> ``:code</div><div class=""> </div><div class=""> #### Inner joins</div><div class=""> </div><div class=""> Another way to achieve a similar result is by using a join, specifically an INNER JOIN. web2py performs joins automatically and transparently when the query links two or more tables as in the following example:</div><div class=""> </div><div class=""> ``Rows``:inxx ``inner join``:inxx ``join``:inxx</div><div class=""> ``</div><div class="delete">&gt;&gt;&gt; rows = db(db.person.id==db.<span class="highlight">do</span>g.owner).select()</div><div class=""> &gt;&gt;&gt; for row in rows:</div><div class="delete">-        print row.person.name, &#x27;has&#x27;, row.dog.name</div><div class="delete">-Alex has Skipper</div><div class="delete">-Alex has Snoopy</div><div class="delete">-Bob has Puppy</div><div class=""> ``:code</div><div class=""> </div><div class=""> Observe that web2py did a join, so the rows now contain two records, one from each table, linked together. Because the two records may have fields with conflicting names, you need to specify the table when extracting a field value from a row. This means that while before you could do:</div><div class=""> ``</div><div class=""> row.name</div><div class=""> ``:code</div><div class=""> </div><div class="delete">and it was obvious whether this was the name of a person or a <span class="highlight">do</span>g, in the result of a join you have to be more explicit and say:</div><div class=""> ``</div><div class=""> row.person.name</div><div class=""> ``:code</div><div class=""> </div><div class=""> or:</div><div class=""> ``</div><div class="delete">row.<span class="highlight">do</span>g.name</div><div class=""> ``:code</div><div class=""> </div><div class=""> There is an alterantive syntax for INNER JOINS:</div><div class=""> ``</div><div class="delete">&gt;&gt;&gt; rows = db(db.person).select(join=db.<span class="highlight">do</span>g.on(db.person.id==db.<span class="highlight">do</span>g.owner))</div><div class=""> &gt;&gt;&gt; for row in rows:</div><div class="delete">-    print row.person.name, &#x27;has&#x27;, row.dog.name</div><div class="delete">-Alex has Skipper</div><div class="delete">-Alex has Snoopy</div><div class="delete">-Bob has Puppy</div><div class=""> ``:code</div><div class=""> </div><div class=""> While the output is the same, the generated SQL in the two cases can be different. The latter syntax removes possible ambiguities when the same table is joined twice and aliased:</div><div class=""> </div><div class=""> ``</div><div class="delete">&gt;&gt;&gt; db.define_table(&#x27;<span class="highlight">do</span>g&#x27;,</div><div class="">         Field(&#x27;name&#x27;),</div><div class="">         Field(&#x27;owner1&#x27;,&#x27;reference person&#x27;),</div><div class="">         Field(&#x27;owner2&#x27;,&#x27;reference person&#x27;))</div><div class=""> &gt;&gt;&gt; rows = db(db.person).select(</div><div class="delete">-    join=[db.person.with_alias(&#x27;owner1&#x27;).on(db.person.id==db.dog.owner1).</div><div class="delete">-          db.person.with_alias(&#x27;owner2&#x27;).on(db.person.id==db.dog.owner2)])</div><div class=""> ``</div><div class=""> </div><div class=""> The value of ``join`` can be list of ``db.table.on(...)`` to join.</div><div class=""> </div><div class=""> #### Left outer join</div><div class=""> </div><div class="delete">Notice that Carl did not appear in the list above because he has no <span class="highlight">do</span>gs. If you intend to select on persons (whether they have <span class="highlight">do</span>gs or not) and their <span class="highlight">do</span>gs (if they have any), then you need to perform a LEFT OUTER JOIN. This is done using the argument &quot;left&quot; of the select command. Here is an example:</div><div class=""> </div><div class=""> ``Rows``:inxx ``left outer join``:inxx ``outer join``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows=db().select(</div><div class="delete">-        db.person.ALL, db.dog.ALL,</div><div class="delete">-        left=db.dog.on(db.person.id==db.dog.owner))</div><div class=""> &gt;&gt;&gt; for row in rows:</div><div class="delete">-        print row.person.name, &#x27;has&#x27;, row.dog.name</div><div class="delete">-Alex has Skipper</div><div class="delete">-Alex has Snoopy</div><div class="delete">-Bob has Puppy</div><div class=""> Carl has None</div><div class=""> ``:code</div><div class=""> </div><div class=""> where:</div><div class=""> ``</div><div class="delete">left = db.<span class="highlight">do</span>g.on(...)</div><div class=""> ``:code</div><div class=""> </div><div class="delete">does the left join query. Here the argument of ``db.<span class="highlight">do</span>g.on`` is the condition required for the join (the same used above for the inner join). In the case of a left join, it is necessary to be explicit about which fields to select.</div><div class=""> </div><div class=""> Multiple left joins can be combined by passing a list or tuple of ``db.mytable.on(...)`` to the  ``left`` attribute.</div><div class=""> </div><div class=""> #### Grouping and counting</div><div class=""> </div><div class="delete">When doing joins, sometimes you want to group rows according to certain criteria and count them. For example, count the number of <span class="highlight">do</span>gs owned by every person. web2py allows this as well. First, you need a count operator. Second, you want to join the person table with the <span class="highlight">do</span>g table by owner. Third, you want to select all rows (person + <span class="highlight">do</span>g), group them by person, and count them while grouping:</div><div class=""> </div><div class=""> ``grouping``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; count = db.person.id.count()</div><div class="delete">&gt;&gt;&gt; for row in db(db.person.id==db.<span class="highlight">do</span>g.owner).select(</div><div class="">         db.person.name, count, groupby=db.person.name):</div><div class="">         print row.person.name, row[count]</div><div class=""> Alex 2</div><div class=""> Bob 1</div><div class=""> ``:code</div><div class=""> </div><div class="delete">Notice the count operator (which is built-in) is used as a field. The only issue here is in how to retrieve the information. Each row clearly contains a person and the count, but the count is not a field of a person nor is it a table. So where does it go? It goes into the storage object representing the record with a key equal to the query expression itself.<span class="highlight"></span></div><div class=""> </div><div class=""> ### Many to many</div><div class=""> ``many-to-many``:inxx</div><div class="delete">In the previous examples, we allowed a <span class="highlight">do</span>g to have one owner but one person could have many <span class="highlight">do</span>gs. What if <span class="highlight">S</span>k<span class="highlight">ipper was owned by Alex and Curt? This requires a many-to-many relation, and it is realized via an intermediate table that links a person to a do</span>g via an ownership relation.</div><div class=""> </div><div class=""> Here is how to do it:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;,</div><div class="">                     Field(&#x27;name&#x27;))</div><div class="delete">&gt;&gt;&gt; db.define_table(&#x27;<span class="highlight">do</span>g&#x27;,</div><div class="">                     Field(&#x27;name&#x27;))</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;ownership&#x27;,</div><div class="">                     Field(&#x27;person&#x27;, &#x27;reference person&#x27;),</div><div class="delete">                    Field(&#x27;<span class="highlight">do</span>g&#x27;, &#x27;reference <span class="highlight">do</span>g&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class=""> the existing ownership relationship can now be rewritten as:</div><div class=""> ``</div><div class="delete">-&gt;&gt;&gt; db.ownership.insert(person=1, dog=1) # Alex owns Skipper</div><div class="delete">-&gt;&gt;&gt; db.ownership.insert(person=1, dog=2) # Alex owns Snoopy</div><div class="delete">-&gt;&gt;&gt; db.ownership.insert(person=2, dog=3) # Bob owns Puppy</div><div class=""> </div><div class=""> ``:code</div><div class=""> </div><div class="delete">Now you can add the new relation that Curt co-owns <span class="highlight">Skipper</span>:</div><div class=""> ``</div><div class="delete">&gt;&gt;&gt; db.ownership.insert(person=3, <span class="highlight">do</span>g=1) # Curt owns <span class="highlight">Skipper</span> too</div><div class=""> </div><div class=""> ``:code</div><div class=""> </div><div class=""> Because you now have a three-way relation between tables, it may be convenient to define a new set on which to perform operations:</div><div class=""> ``</div><div class="delete">&gt;&gt;&gt; persons_and_<span class="highlight">do</span>gs = db(</div><div class="">         (db.person.id==db.ownership.person) \</div><div class="delete">        &amp; (db.<span class="highlight">do</span>g.id==db.ownership.<span class="highlight">do</span>g))</div><div class=""> ``:code</div><div class=""> </div><div class="delete">Now it is easy to select all persons and their <span class="highlight">do</span>gs from the new Set:</div><div class=""> ``</div><div class="delete">-&gt;&gt;&gt; for row in persons_and_dogs.select():</div><div class="delete">-        print row.person.name, row.dog.name</div><div class="delete">-Alex Skipper</div><div class="delete">-Alex Snoopy</div><div class="delete">-Bob Puppy</div><div class="delete">-Curt Skipper</div><div class=""> ``:code</div><div class=""> </div><div class="delete">Similarly, you can search for all <span class="highlight">do</span>gs owned by Alex:</div><div class=""> ``</div><div class="delete">-&gt;&gt;&gt; for row in persons_and_dogs(db.person.name==&#x27;Alex&#x27;).select():</div><div class="delete">-        print row.dog.name</div><div class="delete">-Skipper</div><div class="delete">-Snoopy</div><div class=""> ``:code</div><div class=""> </div><div class="delete">and all owners of <span class="highlight">Skipper</span>:</div><div class=""> ``</div><div class="delete">&gt;&gt;&gt; for row in persons_and_<span class="highlight">do</span>gs(db.<span class="highlight">do</span>g.name==&#x27;<span class="highlight">Skipper</span>&#x27;).select():</div><div class="">         print row.person.name</div><div class=""> Alex</div><div class=""> Curt</div><div class=""> ``:code</div><div class=""> </div><div class=""> A lighter alternative to Many 2 Many relations is tagging. Tagging is discussed in the context of the ``IS_IN_DB`` validator. Tagging works even on database backends that do not support JOINs like the Google App Engine NoSQL.</div><div class=""> </div><div class=""> ### Many to many, ``list:&lt;type&gt;``, and ``contains``</div><div class=""> ``list:string``:inxx</div><div class=""> ``list:integer``:inxx</div><div class=""> ``list:reference``:inxx</div><div class=""> ``contains``:inxx</div><div class=""> ``multiple``:inxx</div><div class=""> ``tags``:inxx</div><div class=""> </div><div class=""> web2py provides the following special field types:</div><div class=""> </div><div class=""> ``</div><div class=""> list:string</div><div class=""> list:integer</div><div class=""> Let&#x27;s define another table &quot;log&quot; to store security events, their event_time and</div><div class="">                            Field(&#x27;event_time&#x27;, &#x27;datetime&#x27;),</div><div class="">                            Field(&#x27;severity&#x27;, &#x27;integer&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class=""> As before, insert a few events, a &quot;port scan&quot;, an &quot;xss injection&quot; and an &quot;unauthorized login&quot;.</div><div class=""> For the sake of the example, you can log events with the same event_time but with different severities (1, 2, 3 respectively).</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; import datetime</div><div class=""> &gt;&gt;&gt; now = datetime.datetime.now()</div><div class=""> &gt;&gt;&gt; print db.log.insert(</div><div class="">         event=&#x27;port scan&#x27;, event_time=now, severity=1)</div><div class=""> 1</div><div class=""> &gt;&gt;&gt; print db.log.insert(</div><div class="">         event=&#x27;xss injection&#x27;, event_time=now, severity=2)</div><div class=""> 2</div><div class=""> &gt;&gt;&gt; print db.log.insert(</div><div class="">         event=&#x27;unauthorized login&#x27;, event_time=now, severity=3)</div><div class=""> 3</div><div class=""> ``:code</div><div class=""> </div><div class="delete">-#### ``like``, ``startswith``, ``contains``, ``upper``, ``lower``</div><div class="delete">-``like``:inxx ``startswith``:inxx</div><div class=""> ``contains``:inxx ``upper``:inxx ``lower``:inxx</div><div class=""> </div><div class=""> Fields have a like operator that you can use to match strings:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db(db.log.event.like(&#x27;port%&#x27;)).select():</div><div class="">         print row.event</div><div class=""> port scan</div><div class=""> ``:code</div><div class=""> </div><div class=""> Here &quot;port%&quot; indicates a string starting with &quot;port&quot;. The percent sign character, &quot;%&quot;, is a wild-card character that means &quot;any sequence of characters&quot;.</div><div class=""> </div><div class=""> web2py also provides some shortcuts:</div><div class=""> </div><div class=""> ``</div><div class=""> db.mytable.myfield.startswith(&#x27;value&#x27;)</div><div class=""> db.mytable.myfield.contains(&#x27;value&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> which are equivalent respectively to</div><div class=""> </div><div class=""> ``</div><div class=""> db.mytable.myfield.like(&#x27;value%&#x27;)</div><div class=""> db.mytable.myfield.like(&#x27;%value%&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> Notice that ``contains`` has a special meaning for ``list:&lt;type&gt;`` fields and it was discussed in a previous section.</div><div class=""> </div><div class=""> The ``contains`` method can also be passed a list of values and an optional boolean argument ``all`` to search for records that contain all values:</div><div class=""> </div><div class=""> ``</div><div class=""> db.mytable.myfield.contains([&#x27;value1&#x27;,&#x27;value2&#x27;], all=True)</div><div class=""> ``</div><div class=""> or any value from the list</div><div class=""> ``</div><div class=""> db.mytable.myfield.contains([&#x27;value1&#x27;,&#x27;value2&#x27;], all=false)</div><div class=""> ``</div><div class=""> </div><div class=""> </div><div class=""> The ``upper`` and ``lower`` methods allow you to convert the value of the field to upper or lower case, and you can also combine them with the like operator:</div><div class=""> </div><div class=""> ``upper``:inxx ``lower``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db(db.log.event.upper().like(&#x27;PORT%&#x27;)).select():</div><div class="">         print row.event</div><div class=""> port scan</div><div class=""> ``:code</div><div class=""> </div><div class=""> #### ``year``, ``month``, ``day``, ``hour``, ``minutes``, ``seconds``</div><div class=""> ``hour``:inxx ``minutes``:inxx ``seconds``:inxx ``day``:inxx ``month``:inxx ``year``:inxx</div><div class=""> </div><div class=""> The date and datetime fields have day, month and year methods. The datetime and time fields have hour, minutes and seconds methods. Here is an example:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db(db.log.event_time.year()==2009).select():</div><div class="">         print row.event</div><div class=""> port scan</div><div class=""> xss injection</div><div class=""> The SQL IN operator is realized via the belongs method which returns true when t</div><div class=""> ``belongs``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db(db.log.severity.belongs((1, 2))).select():</div><div class="">         print row.event</div><div class=""> port scan</div><div class=""> xss injection</div><div class=""> ``:code</div><div class=""> </div><div class=""> The DAL also allows a nested select as the argument of the belongs operator. The only caveat is that the nested select has to be a ``_select``, not a ``select``, and only one field has to be selected explicitly, the one that defines the set.</div><div class=""> </div><div class=""> ``nested select``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; bad_days = db(db.log.severity==3)._select(db.log.event_time)</div><div class=""> &gt;&gt;&gt; for row in db(db.log.event_time.belongs(bad_days)).select():</div><div class="">         print row.event</div><div class=""> port scan</div><div class=""> xss injection</div><div class=""> unauthorized login</div><div class=""> ``:code</div><div class=""> </div><div class="delete">-#### ``sum``, ``min``, ``max`` and ``len``</div><div class=""> </div><div class="delete">``sum<span class="highlight"></span>``:inxx ``min``:inxx ``max``:inxx</div><div class=""> Previously, you have used the count operator to count records. Similarly, you can use the sum operator to add (sum) the values of a specific field from a group of records. As in the case of count, the result of a sum is retrieved via the store object:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; sum = db.log.severity.sum()</div><div class=""> &gt;&gt;&gt; print db().select(sum).first()[sum]</div><div class=""> 6</div><div class=""> ``:code</div><div class=""> </div><div class="delete">You can also use ``<span class="highlight"></span>min``<span class="highlight"></span> and ``max`` to the <span class="highlight"></span>mininum<span class="highlight"></span> and maximum value<span class="highlight"></span> for the selected records<span class="highlight"></span></div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; max = db.log.severity.max()</div><div class=""> &gt;&gt;&gt; print db().select(max).first()[max]</div><div class=""> 3</div><div class=""> ``:code</div><div class=""> </div><div class=""> ``.len()`` computes the length of a string, text or boolean fields.</div><div class=""> </div><div class=""> Expressions can be combined to form more complex expressions. For example here we are computing the sum of the length of all the severity strings in the logs, increased of one:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; sum = (db.log.severity.len()+1).sum()</div><div class=""> &gt;&gt;&gt; print db().select(sum).first()[sum]</div><div class=""> ``:code</div><div class=""> </div><div class=""> #### Substrings</div><div class=""> </div><div class="delete">One can build an expression to refer to a substring. For example, we can group <span class="highlight">do</span>gs whose name starts with the same three characters and select only one from each group:</div><div class=""> </div><div class=""> ``</div><div class="delete">db(db.<span class="highlight">do</span>g).select(dictinct = db.<span class="highlight">do</span>g.name[:3])</div><div class=""> ``:code</div><div class=""> </div><div class=""> </div><div class=""> #### Default values with ``coalesce`` and ``coalesce_zero``</div><div class=""> </div><div class=""> There are times when you need to pull a value from database but also need a default values if the value for a record is set to NULL. In SQL there is a keyword, ``COALESCE``, for this. web2py has an equivalent ``coalesce`` method:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;sysuser&#x27;,Field(&#x27;username&#x27;),Field(&#x27;fullname&#x27;))</div><div class=""> &gt;&gt;&gt; db.sysuser.insert(username=&#x27;max&#x27;,fullname=&#x27;Max Power&#x27;)</div><div class=""> &gt;&gt;&gt; db.sysuser.insert(username=&#x27;tim&#x27;,fullname=None)</div><div class=""> print db(db.sysuser).select(db.sysuser.fullname.coalesce(db.sysuser.username))</div><div class=""> &quot;COALESCE(sysuser.fullname,sysuser.username)&quot;</div><div class=""> Max Power</div><div class=""> tim</div><div class=""> ``</div><div class=""> </div><div class=""> Other times you need to compute a mathematical expression but some fields have a value set to None while it should be zero.</div><div class=""> ``coalesce_zero`` comes to the rescue by defaulting None to zero in the query:</div><div class=""> </div><div class=""> And finally, here is ``_update`` ``_update``:inxx</div><div class=""> &gt;&gt;&gt; print db(db.person.name==&#x27;Alex&#x27;)._update()</div><div class=""> UPDATE person SET  WHERE person.name=&#x27;Alex&#x27;;</div><div class=""> ``:code</div><div class=""> </div><div class=""> -----</div><div class=""> Moreover you can always use ``db._lastsql`` to return the most recent</div><div class=""> SQL code, whether it was executed manually using executesql or was SQL</div><div class=""> generated by the DAL.</div><div class=""> -----</div><div class=""> </div><div class=""> ### Exporting and importing data</div><div class=""> ``export``:inxx ``import``:inxx</div><div class=""> </div><div class=""> #### CSV (one Table at a time)</div><div class=""> </div><div class=""> When a DALRows object is converted to a string it is automatically</div><div class=""> serialized in CSV:</div><div class=""> </div><div class=""> ``csv``:inxx</div><div class=""> ``</div><div class="delete">&gt;&gt;&gt; rows = db(db.person.id==db.<span class="highlight">do</span>g.owner).select()</div><div class=""> &gt;&gt;&gt; print rows</div><div class="delete">-person.id,person.name,dog.id,dog.name,dog.owner</div><div class="delete">-1,Alex,1,Skipper,1</div><div class="delete">-1,Alex,2,Snoopy,1</div><div class="delete">-2,Bob,3,Puppy,2</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can serialize a single table in CSV and store it in a file &quot;test.csv&quot;:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; open(&#x27;test.csv&#x27;, &#x27;w&#x27;).write(str(db(db.person.id).select()))</div><div class=""> ``:code</div><div class=""> </div><div class=""> and you can easily read it back with:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.person.import_from_csv_file(open(&#x27;test.csv&#x27;, &#x27;r&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class=""> When importing, web2py looks for the field names in the CSV header. In this example, it finds two columns: &quot;person.id&quot; and &quot;person.name&quot;. It ignores the &quot;person.&quot; prefix, and it ignores the &quot;id&quot; fields. Then all records are appended and assigned new ids. Both of these operations can be performed via the appadmin web interface.</div><div class=""> </div><div class=""> #### CSV (all tables at once)</div><div class=""> </div><div class=""> In web2py, you can backup/restore an entire database with two commands:</div><div class=""> </div><div class=""> To export:</div><div class=""> ``</div><div class=""> Two tables are separated ``\r\n\r\n``. The file ends with the line</div><div class=""> END</div><div class=""> ``:code</div><div class=""> </div><div class=""> The file does not include uploaded files if these are not stored in the database. In any case it is easy enough to zip the &quot;uploads&quot; folder separately.</div><div class=""> </div><div class=""> When importing, the new records will be appended to the database if it is not empty. In general the new imported records will not have the same record id as the original (saved) records but web2py will restore references so they are not broken, even if the id values may change.</div><div class=""> </div><div class=""> If a table contains a field called</div><div class=""> &quot;uuid&quot;, this field will be used to identify duplicates.  Also, if an</div><div class=""> imported record has the same &quot;uuid&quot; as an existing record, the</div><div class=""> previous record will be updated.</div><div class=""> </div><div class=""> #### CSV and remote database synchronization</div><div class=""> </div><div class=""> Consider the following model:</div><div class=""> ``</div><div class=""> db = DAL(&#x27;sqlite:memory:&#x27;)</div><div class=""> db.define_table(&#x27;person&#x27;,</div><div class="">     Field(&#x27;name&#x27;),</div><div class="">     format=&#x27;%(name)s&#x27;)</div><div class="delete">db.define_table(&#x27;<span class="highlight">do</span>g&#x27;,</div><div class="">     Field(&#x27;owner&#x27;, &#x27;reference person&#x27;),</div><div class="">     Field(&#x27;name&#x27;),</div><div class="">     format=&#x27;%(name)s&#x27;)</div><div class=""> </div><div class=""> if not db(db.person).count():</div><div class="">     id = db.person.insert(name=&quot;Massimo&quot;)</div><div class="delete">    db.<span class="highlight">do</span>g.insert(owner=id, name=&quot;<span class="highlight">Snoopy</span>&quot;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> Each record is identified by an ID and referenced by that ID. If you</div><div class=""> have two copies of the database used by distinct web2py installations,</div><div class=""> the ID is unique only within each database and not across the databases.</div><div class=""> This is a problem when merging records from different databases.</div><div class=""> </div><div class=""> In order to make a record uniquely identifiable across databases, they</div><div class=""> must:</div><div class=""> - have a unique id (UUID),</div><div class=""> - have an event_time (to figure out which one is more recent if multiple copies),</div><div class=""> - reference the UUID instead of the id.</div><div class=""> </div><div class=""> This can be achieved without modifying web2py. Here is what to do:</div><div class=""> </div><div class=""> **1.** Change the above model into:</div><div class=""> </div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;,</div><div class="">     Field(&#x27;uuid&#x27;, length=64, default=lambda:str(uuid.uuid4())),</div><div class="">     Field(&#x27;modified_on&#x27;, &#x27;datetime&#x27;, default=now),</div><div class="">     Field(&#x27;name&#x27;),</div><div class="">     format=&#x27;%(name)s&#x27;)</div><div class=""> </div><div class="delete">db.define_table(&#x27;<span class="highlight">do</span>g&#x27;,</div><div class="">     Field(&#x27;uuid&#x27;, length=64, default=lambda:str(uuid.uuid4())),</div><div class="">     Field(&#x27;modified_on&#x27;, &#x27;datetime&#x27;, default=now),</div><div class="">     Field(&#x27;owner&#x27;, length=64),</div><div class="">     Field(&#x27;name&#x27;),</div><div class="">     format=&#x27;%(name)s&#x27;)</div><div class=""> </div><div class="delete">db.<span class="highlight">do</span>g.owner.requires = IS_IN_DB(db,&#x27;person.uuid&#x27;,&#x27;%(name)s&#x27;)</div><div class=""> </div><div class=""> if not db(db.person.id).count():</div><div class="">     id = uuid.uuid4()</div><div class="">     db.person.insert(name=&quot;Massimo&quot;, uuid=id)</div><div class="delete">    db.<span class="highlight">do</span>g.insert(owner=id, name=&quot;<span class="highlight">Snoopy</span>&quot;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> -------</div><div class=""> Note, in the above table definitions, the default value for the two &#x27;uuid&#x27; fields is set to a lambda function, which returns a UUID (converted to a string). The lambda function is called once for each record inserted, ensuring that each record gets a unique UUID, even if multiple records are inserted in a single transaction.</div><div class=""> -------</div><div class=""> </div><div class=""> **2.** Create a controller action to export the database:</div><div class=""> </div><div class=""> ``</div><div class=""> def export():</div><div class="">     s = StringIO.StringIO()</div><div class="">     db.export_to_csv_file(s)</div><div class="">     response.headers[&#x27;Content-Type&#x27;] = &#x27;text/csv&#x27;</div><div class="">     return s.getvalue()</div><div class=""> ``:code</div><div class=""> </div><div class=""> **3.** Create a controller action to import a saved copy of the other database and sync records:</div><div class=""> </div><div class=""> ``</div><div class=""> def import_and_sync():</div><div class=""> specific for this example.</div><div class=""> ``XML-RPC``:inxx</div><div class=""> Alternatively, you can use XML-RPC to export/import the file.</div><div class=""> </div><div class=""> If the records reference uploaded files, you also need to export/import the content of the uploads folder. Notice that files therein are already labeled by UUIDs so you do not need to worry about naming conflicts and references.</div><div class=""> </div><div class=""> #### HTML and XML (one Table at a time)</div><div class=""> </div><div class=""> ``DALRows objects``:inxx</div><div class=""> DALRows objects also have an ``xml`` method (like helpers) that serializes it to XML/HTML:</div><div class=""> </div><div class=""> ``HTML``:inxx</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows = db(db.person.id &gt; 0).select()</div><div class=""> &gt;&gt;&gt; print rows.xml()</div><div class=""> &lt;table&gt;</div><div class="">   &lt;thead&gt;</div><div class="">     &lt;tr&gt;</div><div class="">       &lt;th&gt;person.id&lt;/th&gt;</div><div class="">       &lt;th&gt;person.name&lt;/th&gt;</div><div class="delete">-      &lt;th&gt;dog.id&lt;/th&gt;</div><div class="delete">-      &lt;th&gt;dog.name&lt;/th&gt;</div><div class="delete">-      &lt;th&gt;dog.owner&lt;/th&gt;</div><div class="">     &lt;/tr&gt;</div><div class="">   &lt;/thead&gt;</div><div class="">   &lt;tbody&gt;</div><div class="">     &lt;tr class=&quot;even&quot;&gt;</div><div class="">       &lt;td&gt;1&lt;/td&gt;</div><div class="">       &lt;td&gt;Alex&lt;/td&gt;</div><div class="">       &lt;td&gt;1&lt;/td&gt;</div><div class="delete">      &lt;td&gt;<span class="highlight">Skipper</span>&lt;/td&gt;</div><div class="">       &lt;td&gt;1&lt;/td&gt;</div><div class="">     &lt;/tr&gt;</div><div class="">     ...</div><div class="">   &lt;/tbody&gt;</div><div class=""> &lt;/table&gt;</div><div class=""> ``:code</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/93539678ed5ee942c5bd09736516134b7abd95fd">9353967</a><ul><li>Date : 2012-09-01</li><li>new style references</li></ul></li></ul>
<div class="row-fluid" id="com_93539678ed5ee942c5bd09736516134b7abd95fd">
    <div class="span6"><div class="diff"><div class="insert">+----------</div><div class="insert">+Because usually in web2py models are executed before controllers, it is possible that some table are defined even if not needed. It is therefore necessary to speed up the code by making table definitions lazy. This is done by setting the ``DAL(...,lazy_tables=True)`` attributes. Tables will be actually created only when accessed.</div><div class="insert">+----------</div><div class=""> </div><div class=""> ### Record representation</div><div class=""> </div><div class=""> It is optional but recommended to specify a format representation for records:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;), format=&#x27;%(name)s&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> or</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;), format=&#x27;%(name)s %(id)s&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> or even more complex ones using a function:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;),</div><div class="">        format=lambda r: r.name or &#x27;anonymous&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> The format attribute will be used for two purposes:</div><div class=""> db(db.mytable.id==id).update(myfield=&#x27;somevalue&#x27;)</div><div class=""> </div><div class=""> and it updates an existing record with field values specified by the dictionary on the right hand side.</div><div class=""> </div><div class=""> #### Fetching a ``Row``</div><div class=""> </div><div class=""> Yet another convenient syntax is the following:</div><div class=""> </div><div class=""> ``</div><div class=""> record = db.mytable(id)</div><div class=""> record = db.mytable(db.mytable.id==id)</div><div class=""> record = db.mytable(id,myfield=&#x27;somevalue&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> Apparently similar to ``db.mytable[id]`` the above syntax is more flexible and safer. First of all it checks whether ``id`` is an int (or ``str(id)`` is an int) and returns ``None`` if not (it never raises an exception). It also allows to specify multiple conditions that the record must meet. If they are not met, it also returns ``None``.</div><div class=""> </div><div class=""> #### Recursive ``select``s</div><div class=""> ``recursive selects``:inxx</div><div class=""> </div><div class=""> Consider the previous table person and a new table &quot;dog&quot; referencing a &quot;person&quot;:</div><div class=""> ``</div><div class="insert">&gt;&gt;&gt; db.define_table(&#x27;dog&#x27;, Field(&#x27;name&#x27;), Field(&#x27;owner&#x27;,<span class="highlight">&#x27;reference </span>person<span class="highlight">&#x27;</span>))</div><div class=""> ``:code</div><div class=""> </div><div class=""> and a simple select from this table:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; dogs = db(db.dog).select()</div><div class=""> ``:code</div><div class=""> </div><div class=""> which is equivalent to</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; dogs = db(db.dog._id&gt;0).select()</div><div class=""> ``:code</div><div class=""> </div><div class=""> where ``._id`` is a reference to the primary key of the table. Normally ``db.dog._id`` is the same as ``db.dog.id`` and we will assume that in most of this book. ``_id``:inxx</div><div class=""> </div><div class=""> </div><div class=""> For each Row of dogs it is possible to fetch not just fields from the selected table (dog) but also from linked tables (recursively):</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for dog in dogs: print dog.name, dog.owner.name</div><div class=""> ``:code</div><div class=""> In order to define one or more virtual fields, you have to define a container cl</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;item&#x27;,</div><div class="">         Field(&#x27;unit_price&#x27;,&#x27;double&#x27;),</div><div class="">         Field(&#x27;quantity&#x27;,&#x27;integer&#x27;),</div><div class=""> ``:code</div><div class=""> </div><div class=""> One can define a ``total_price`` virtual field as</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; class MyVirtualFields(object):</div><div class="">         def total_price(self):</div><div class="">             return self.item.unit_price*self.item.quantity</div><div class=""> &gt;&gt;&gt; db.item.virtualfields.append(MyVirtualFields())</div><div class=""> ``:code</div><div class=""> </div><div class=""> Notice that each method of the class that takes a single argument (self) is a new virtual field. ``self`` refers to each one row of the select. Field values are referred by full path as in ``self.item.unit_price``. The table is linked to the virtual fields by appending an instance of the class to the table&#x27;s ``virtualfields`` attribute.</div><div class=""> </div><div class=""> Virtual fields can also access recursive fields as in</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;item&#x27;,</div><div class="">         Field(&#x27;unit_price&#x27;,&#x27;double&#x27;))</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;order_item&#x27;,</div><div class="insert">        Field(&#x27;item&#x27;,<span class="highlight">&#x27;reference </span>item<span class="highlight">&#x27;</span>),</div><div class="">         Field(&#x27;quantity&#x27;,&#x27;integer&#x27;))</div><div class=""> &gt;&gt;&gt; class MyVirtualFields(object):</div><div class="">         def total_price(self):</div><div class="">             return self.order_item.item.unit_price \</div><div class="">                 * self.order_item.quantity</div><div class=""> &gt;&gt;&gt; db.order_item.virtualfields.append(MyVirtualFields())</div><div class=""> ``:code</div><div class=""> </div><div class=""> Notice the recursive field access ``self.order_item.item.unit_price`` where ``self`` is the looping record.</div><div class=""> </div><div class=""> They can also act on the result of a JOIN</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;item&#x27;,</div><div class="">         Field(&#x27;unit_price&#x27;,&#x27;double&#x27;))</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;order_item&#x27;,</div><div class="insert">        Field(&#x27;item&#x27;,<span class="highlight">&#x27;reference </span>item<span class="highlight">&#x27;</span>),</div><div class="">         Field(&#x27;quantity&#x27;,&#x27;integer&#x27;))</div><div class=""> &gt;&gt;&gt; rows = db(db.order_item.item==db.item.id).select()</div><div class=""> &gt;&gt;&gt; class MyVirtualFields(object):</div><div class="">         def total_price(self):</div><div class="">             return self.item.unit_price \</div><div class="">                 * self.order_item.quantity</div><div class=""> &gt;&gt;&gt; rows.setvirtualfields(order_item=MyVirtualFields())</div><div class=""> &gt;&gt;&gt; for row in rows: print row.order_item.total_price</div><div class=""> ``:code</div><div class=""> </div><div class=""> Notice how in this case the syntax is different. The virtual field accesses both ``self.item.unit_price`` and ``self.order_item.quantity`` which belong to the join select. The virtual field is attached to the rows of the table using the ``setvirtualfields`` method of the rows object. This method takes an arbitrary number of named arguments and can be used to set multiple virtual fields, defined in multiple classes, and attach them to multiple tables:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; class MyVirtualFields1(object):</div><div class="">         def discounted_unit_price(self):</div><div class="">             return self.item.unit_price*0.90</div><div class=""> &gt;&gt;&gt; class MyVirtualFields2(object):</div><div class="">         def total_price(self):</div><div class="">             return self.item.unit_price \</div><div class="">                 * self.order_item.quantity</div><div class="">         def discounted_total_price(self):</div><div class=""> The lazy field in the example above allows one to compute the total price for ea</div><div class=""> And it also allows to pass an optional ``discount`` percentage (15%):</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db(db.item).select(): print row.total_price(15)</div><div class=""> ``</div><div class=""> </div><div class=""> ------</div><div class=""> Mind that virtual fields do not have the same attributes as the other fields (default, readable, requires, etc) and they do not appear in the list of ``db.table.fields`` and are not visualized by default in tables (TABLE) and grids (SQLFORM.grid, SQLFORM.smartgrid).</div><div class=""> ------</div><div class=""> </div><div class=""> ### One to many relation</div><div class=""> ``one to many``:inxx</div><div class=""> </div><div class=""> To illustrate how to implement one to many relations with the web2py DAL, define another table &quot;dog&quot; that refers to the table &quot;person&quot; which we redefine here:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;,</div><div class="">                     Field(&#x27;name&#x27;),</div><div class="">                     format=&#x27;%(name)s&#x27;)</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;dog&#x27;,</div><div class="">                     Field(&#x27;name&#x27;),</div><div class="insert">                    Field(&#x27;owner&#x27;, <span class="highlight">&#x27;reference </span>person<span class="highlight">&#x27;</span>),</div><div class="">                     format=&#x27;%(name)s&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> Table &quot;dog&quot; has two fields, the name of the dog and the owner of the dog. When a field type is another table, it is intended that the field reference the other table by its id. In fact, you can print the actual type value and get:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; print db.dog.owner.type</div><div class=""> reference person</div><div class=""> ``:code</div><div class=""> </div><div class=""> Now, insert three dogs, two owned by Alex and one by Bob:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.dog.insert(name=&#x27;Skipper&#x27;, owner=1)</div><div class=""> 1</div><div class=""> &gt;&gt;&gt; db.dog.insert(name=&#x27;Snoopy&#x27;, owner=1)</div><div class=""> 2</div><div class=""> &gt;&gt;&gt; db.dog.insert(name=&#x27;Puppy&#x27;, owner=2)</div><div class=""> 3</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can select as you did for any other table:</div><div class=""> row.person.name</div><div class=""> or:</div><div class=""> ``</div><div class=""> row.dog.name</div><div class=""> ``:code</div><div class=""> </div><div class=""> There is an alterantive syntax for INNER JOINS:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows = db(db.person).select(join=db.dog.on(db.person.id==db.dog.owner))</div><div class=""> &gt;&gt;&gt; for row in rows:</div><div class="">     print row.person.name, &#x27;has&#x27;, row.dog.name</div><div class=""> Alex has Skipper</div><div class=""> Alex has Snoopy</div><div class=""> Bob has Puppy</div><div class=""> ``:code</div><div class=""> </div><div class=""> While the output is the same, the generated SQL in the two cases can be different. The latter syntax removes possible ambiguities when the same table is joined twice and aliased:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;dog&#x27;,</div><div class="">         Field(&#x27;name&#x27;),</div><div class="insert">+        Field(&#x27;owner1&#x27;,&#x27;reference person&#x27;),</div><div class="insert">+        Field(&#x27;owner2&#x27;,&#x27;reference person&#x27;))</div><div class=""> &gt;&gt;&gt; rows = db(db.person).select(</div><div class="">     join=[db.person.with_alias(&#x27;owner1&#x27;).on(db.person.id==db.dog.owner1).</div><div class="">           db.person.with_alias(&#x27;owner2&#x27;).on(db.person.id==db.dog.owner2)])</div><div class=""> ``</div><div class=""> </div><div class=""> The value of ``join`` can be list of ``db.table.on(...)`` to join.</div><div class=""> </div><div class=""> #### Left outer join</div><div class=""> </div><div class=""> Notice that Carl did not appear in the list above because he has no dogs. If you intend to select on persons (whether they have dogs or not) and their dogs (if they have any), then you need to perform a LEFT OUTER JOIN. This is done using the argument &quot;left&quot; of the select command. Here is an example:</div><div class=""> </div><div class=""> ``Rows``:inxx ``left outer join``:inxx ``outer join``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows=db().select(</div><div class="">         db.person.ALL, db.dog.ALL,</div><div class="">         left=db.dog.on(db.person.id==db.dog.owner))</div><div class=""> &gt;&gt;&gt; for row in rows:</div><div class="">         print row.person.name, &#x27;has&#x27;, row.dog.name</div><div class=""> Alex has Skipper</div><div class=""> Alex has Snoopy</div><div class=""> When doing joins, sometimes you want to group rows according to certain criteria</div><div class=""> &gt;&gt;&gt; for row in db(db.person.id==db.dog.owner).select(</div><div class="">         db.person.name, count, groupby=db.person.name):</div><div class="">         print row.person.name, row[count]</div><div class=""> Alex 2</div><div class=""> Bob 1</div><div class=""> ``:code</div><div class=""> </div><div class=""> Notice the count operator (which is built-in) is used as a field. The only issue here is in how to retrieve the information. Each row clearly contains a person and the count, but the count is not a field of a person nor is it a table. So where does it go? It goes into the storage object representing the record with a key equal to the query expression itself.</div><div class=""> </div><div class=""> ### Many to many</div><div class=""> ``many-to-many``:inxx</div><div class=""> In the previous examples, we allowed a dog to have one owner but one person could have many dogs. What if Skipper was owned by Alex and Curt? This requires a many-to-many relation, and it is realized via an intermediate table that links a person to a dog via an ownership relation.</div><div class=""> </div><div class=""> Here is how to do it:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;,</div><div class="">                     Field(&#x27;name&#x27;))</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;dog&#x27;,</div><div class="">                     Field(&#x27;name&#x27;))</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;ownership&#x27;,</div><div class="insert">+                    Field(&#x27;person&#x27;, &#x27;reference person&#x27;),</div><div class="insert">+                    Field(&#x27;dog&#x27;, &#x27;reference dog&#x27;))</div><div class=""> ``:code</div><div class=""> </div><div class=""> the existing ownership relationship can now be rewritten as:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.ownership.insert(person=1, dog=1) # Alex owns Skipper</div><div class=""> &gt;&gt;&gt; db.ownership.insert(person=1, dog=2) # Alex owns Snoopy</div><div class=""> &gt;&gt;&gt; db.ownership.insert(person=2, dog=3) # Bob owns Puppy</div><div class=""> </div><div class=""> ``:code</div><div class=""> </div><div class=""> Now you can add the new relation that Curt co-owns Skipper:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.ownership.insert(person=3, dog=1) # Curt owns Skipper too</div><div class=""> </div><div class=""> ``:code</div><div class=""> </div><div class=""> Because you now have a three-way relation between tables, it may be convenient to define a new set on which to perform operations:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; persons_and_dogs = db(</div><div class="">         (db.person.id==db.ownership.person) \</div><div class=""> END</div><div class=""> ``:code</div><div class=""> </div><div class=""> The file does not include uploaded files if these are not stored in the database. In any case it is easy enough to zip the &quot;uploads&quot; folder separately.</div><div class=""> </div><div class=""> When importing, the new records will be appended to the database if it is not empty. In general the new imported records will not have the same record id as the original (saved) records but web2py will restore references so they are not broken, even if the id values may change.</div><div class=""> </div><div class=""> If a table contains a field called</div><div class=""> &quot;uuid&quot;, this field will be used to identify duplicates.  Also, if an</div><div class=""> imported record has the same &quot;uuid&quot; as an existing record, the</div><div class=""> previous record will be updated.</div><div class=""> </div><div class=""> #### CSV and remote database synchronization</div><div class=""> </div><div class=""> Consider the following model:</div><div class=""> ``</div><div class=""> db = DAL(&#x27;sqlite:memory:&#x27;)</div><div class=""> db.define_table(&#x27;person&#x27;,</div><div class="">     Field(&#x27;name&#x27;),</div><div class="">     format=&#x27;%(name)s&#x27;)</div><div class=""> db.define_table(&#x27;dog&#x27;,</div><div class="insert">    Field(&#x27;owner&#x27;, <span class="highlight">&#x27;reference </span>person<span class="highlight">&#x27;</span>),</div><div class="">     Field(&#x27;name&#x27;),</div><div class="">     format=&#x27;%(name)s&#x27;)</div><div class=""> </div><div class=""> if not db(db.person).count():</div><div class="">     id = db.person.insert(name=&quot;Massimo&quot;)</div><div class="">     db.dog.insert(owner=id, name=&quot;Snoopy&quot;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> Each record is identified by an ID and referenced by that ID. If you</div><div class=""> have two copies of the database used by distinct web2py installations,</div><div class=""> the ID is unique only within each database and not across the databases.</div><div class=""> This is a problem when merging records from different databases.</div><div class=""> </div><div class=""> In order to make a record uniquely identifiable across databases, they</div><div class=""> must:</div><div class=""> - have a unique id (UUID),</div><div class=""> - have an event_time (to figure out which one is more recent if multiple copies),</div><div class=""> - reference the UUID instead of the id.</div><div class=""> </div><div class=""> This can be achieved without modifying web2py. Here is what to do:</div><div class=""> Here is some example usage:</div><div class=""> Which would render something similar to</div><div class=""> ``</div><div class=""> &quot;hello&quot;|35|&quot;this is the text description&quot;|&quot;2009-03-03&quot;</div><div class=""> ``:code</div><div class=""> </div><div class=""> For more information consult the official Python documentation ``quoteall``:cite</div><div class=""> </div><div class=""> ### Caching selects</div><div class=""> </div><div class=""> The select method also takes a cache argument, which defaults to None. For caching purposes, it should be set to a tuple where the first element is the cache model (cache.ram, cache.disk, etc.), and the second element is the expiration time in seconds.</div><div class=""> </div><div class=""> In the following example, you see a controller that caches a select on the previously defined db.log table. The actual select fetches data from the back-end database no more frequently than once every 60 seconds and stores the result in cache.ram. If the next call to this controller occurs in less than 60 seconds since the last database IO, it simply fetches the previous data from cache.ram.</div><div class=""> </div><div class=""> ``cache select``:inxx </div><div class=""> ``</div><div class=""> def cache_db_select():</div><div class="">     logs = db().select(db.log.ALL, cache=(cache.ram, 60))</div><div class="">     return dict(logs=logs)</div><div class=""> ``:code</div><div class=""> </div><div class="insert">+``cacheable``:inxx</div><div class="insert">+</div><div class="insert">+The ``select`` method has an optional ``cacheable`` argument, normally set to ``False``. When a select is cached, ``cacheable`` is set to ``True``. This makes a simple ``Rows`` result which is serializable but The ``Row``s lack ``update_record`` and ``delete_record`` methods.</div><div class="insert">+</div><div class="insert">+If you do not need these methods you can speed up selects even if you do not plan to cache then by setting the cacheable attribute:</div><div class="insert">+</div><div class="insert">+``</div><div class="insert">+rows = db(query).select(cacheable=True)</div><div class="insert">+``:code</div><div class="insert">+</div><div class=""> -------</div><div class="insert">The results of a ``select`` are<span class="highlight"> normally</span> complex, un-pickleable objects; they cannot be stored in a session and cannot be cached in any other way than the one explained here<span class="highlight"> unless the ``cache`` attribute is set or ``cacheable=True``</span>.</div><div class=""> -------</div><div class=""> </div><div class=""> ### Self-Reference and aliases</div><div class=""> </div><div class=""> ``self reference``:inxx</div><div class=""> ``alias``:inxx</div><div class=""> It is possible to define tables with fields that refer to themselves although the usual notation may fail. The following code would be wrong because it uses a variable ``db.person`` before it is defined:</div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;,</div><div class="">     Field(&#x27;name&#x27;),</div><div class="insert">+    Field(&#x27;father_id&#x27;, &#x27;reference person&#x27;),</div><div class="insert">+    Field(&#x27;mother_id&#x27;, &#x27;reference person&#x27;))</div><div class=""> ``:code</div></div></div>
    <div class="span6"><div class="diff"><div class=""> </div><div class=""> ### Record representation</div><div class=""> </div><div class=""> It is optional but recommended to specify a format representation for records:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;), format=&#x27;%(name)s&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> or</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;), format=&#x27;%(name)s %(id)s&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> or even more complex ones using a function:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;),</div><div class="">        format=lambda r: r.name or &#x27;anonymous&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> The format attribute will be used for two purposes:</div><div class=""> db(db.mytable.id==id).update(myfield=&#x27;somevalue&#x27;)</div><div class=""> </div><div class=""> and it updates an existing record with field values specified by the dictionary on the right hand side.</div><div class=""> </div><div class=""> #### Fetching a ``Row``</div><div class=""> </div><div class=""> Yet another convenient syntax is the following:</div><div class=""> </div><div class=""> ``</div><div class=""> record = db.mytable(id)</div><div class=""> record = db.mytable(db.mytable.id==id)</div><div class=""> record = db.mytable(id,myfield=&#x27;somevalue&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> Apparently similar to ``db.mytable[id]`` the above syntax is more flexible and safer. First of all it checks whether ``id`` is an int (or ``str(id)`` is an int) and returns ``None`` if not (it never raises an exception). It also allows to specify multiple conditions that the record must meet. If they are not met, it also returns ``None``.</div><div class=""> </div><div class=""> #### Recursive ``select``s</div><div class=""> ``recursive selects``:inxx</div><div class=""> </div><div class=""> Consider the previous table person and a new table &quot;dog&quot; referencing a &quot;person&quot;:</div><div class=""> ``</div><div class="delete">&gt;&gt;&gt; db.define_table(&#x27;dog&#x27;, Field(&#x27;name&#x27;), Field(&#x27;owner&#x27;,<span class="highlight">db.</span>person<span class="highlight"></span>))</div><div class=""> ``:code</div><div class=""> </div><div class=""> and a simple select from this table:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; dogs = db(db.dog).select()</div><div class=""> ``:code</div><div class=""> </div><div class=""> which is equivalent to</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; dogs = db(db.dog._id&gt;0).select()</div><div class=""> ``:code</div><div class=""> </div><div class=""> where ``._id`` is a reference to the primary key of the table. Normally ``db.dog._id`` is the same as ``db.dog.id`` and we will assume that in most of this book. ``_id``:inxx</div><div class=""> </div><div class=""> </div><div class=""> For each Row of dogs it is possible to fetch not just fields from the selected table (dog) but also from linked tables (recursively):</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for dog in dogs: print dog.name, dog.owner.name</div><div class=""> ``:code</div><div class=""> In order to define one or more virtual fields, you have to define a container cl</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;item&#x27;,</div><div class="">         Field(&#x27;unit_price&#x27;,&#x27;double&#x27;),</div><div class="">         Field(&#x27;quantity&#x27;,&#x27;integer&#x27;),</div><div class=""> ``:code</div><div class=""> </div><div class=""> One can define a ``total_price`` virtual field as</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; class MyVirtualFields(object):</div><div class="">         def total_price(self):</div><div class="">             return self.item.unit_price*self.item.quantity</div><div class=""> &gt;&gt;&gt; db.item.virtualfields.append(MyVirtualFields())</div><div class=""> ``:code</div><div class=""> </div><div class=""> Notice that each method of the class that takes a single argument (self) is a new virtual field. ``self`` refers to each one row of the select. Field values are referred by full path as in ``self.item.unit_price``. The table is linked to the virtual fields by appending an instance of the class to the table&#x27;s ``virtualfields`` attribute.</div><div class=""> </div><div class=""> Virtual fields can also access recursive fields as in</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;item&#x27;,</div><div class="">         Field(&#x27;unit_price&#x27;,&#x27;double&#x27;))</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;order_item&#x27;,</div><div class="delete">        Field(&#x27;item&#x27;,<span class="highlight">db.</span>item<span class="highlight"></span>),</div><div class="">         Field(&#x27;quantity&#x27;,&#x27;integer&#x27;))</div><div class=""> &gt;&gt;&gt; class MyVirtualFields(object):</div><div class="">         def total_price(self):</div><div class="">             return self.order_item.item.unit_price \</div><div class="">                 * self.order_item.quantity</div><div class=""> &gt;&gt;&gt; db.order_item.virtualfields.append(MyVirtualFields())</div><div class=""> ``:code</div><div class=""> </div><div class=""> Notice the recursive field access ``self.order_item.item.unit_price`` where ``self`` is the looping record.</div><div class=""> </div><div class=""> They can also act on the result of a JOIN</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;item&#x27;,</div><div class="">         Field(&#x27;unit_price&#x27;,&#x27;double&#x27;))</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;order_item&#x27;,</div><div class="delete">        Field(&#x27;item&#x27;,<span class="highlight">db.</span>item<span class="highlight"></span>),</div><div class="">         Field(&#x27;quantity&#x27;,&#x27;integer&#x27;))</div><div class=""> &gt;&gt;&gt; rows = db(db.order_item.item==db.item.id).select()</div><div class=""> &gt;&gt;&gt; class MyVirtualFields(object):</div><div class="">         def total_price(self):</div><div class="">             return self.item.unit_price \</div><div class="">                 * self.order_item.quantity</div><div class=""> &gt;&gt;&gt; rows.setvirtualfields(order_item=MyVirtualFields())</div><div class=""> &gt;&gt;&gt; for row in rows: print row.order_item.total_price</div><div class=""> ``:code</div><div class=""> </div><div class=""> Notice how in this case the syntax is different. The virtual field accesses both ``self.item.unit_price`` and ``self.order_item.quantity`` which belong to the join select. The virtual field is attached to the rows of the table using the ``setvirtualfields`` method of the rows object. This method takes an arbitrary number of named arguments and can be used to set multiple virtual fields, defined in multiple classes, and attach them to multiple tables:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; class MyVirtualFields1(object):</div><div class="">         def discounted_unit_price(self):</div><div class="">             return self.item.unit_price*0.90</div><div class=""> &gt;&gt;&gt; class MyVirtualFields2(object):</div><div class="">         def total_price(self):</div><div class="">             return self.item.unit_price \</div><div class="">                 * self.order_item.quantity</div><div class="">         def discounted_total_price(self):</div><div class=""> The lazy field in the example above allows one to compute the total price for ea</div><div class=""> And it also allows to pass an optional ``discount`` percentage (15%):</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; for row in db(db.item).select(): print row.total_price(15)</div><div class=""> ``</div><div class=""> </div><div class=""> ------</div><div class=""> Mind that virtual fields do not have the same attributes as the other fields (default, readable, requires, etc) and they do not appear in the list of ``db.table.fields`` and are not visualized by default in tables (TABLE) and grids (SQLFORM.grid, SQLFORM.smartgrid).</div><div class=""> ------</div><div class=""> </div><div class=""> ### One to many relation</div><div class=""> ``one to many``:inxx</div><div class=""> </div><div class=""> To illustrate how to implement one to many relations with the web2py DAL, define another table &quot;dog&quot; that refers to the table &quot;person&quot; which we redefine here:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;,</div><div class="">                     Field(&#x27;name&#x27;),</div><div class="">                     format=&#x27;%(name)s&#x27;)</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;dog&#x27;,</div><div class="">                     Field(&#x27;name&#x27;),</div><div class="delete">                    Field(&#x27;owner&#x27;, <span class="highlight">db.</span>person<span class="highlight"></span>),</div><div class="">                     format=&#x27;%(name)s&#x27;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> Table &quot;dog&quot; has two fields, the name of the dog and the owner of the dog. When a field type is another table, it is intended that the field reference the other table by its id. In fact, you can print the actual type value and get:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; print db.dog.owner.type</div><div class=""> reference person</div><div class=""> ``:code</div><div class=""> </div><div class=""> Now, insert three dogs, two owned by Alex and one by Bob:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.dog.insert(name=&#x27;Skipper&#x27;, owner=1)</div><div class=""> 1</div><div class=""> &gt;&gt;&gt; db.dog.insert(name=&#x27;Snoopy&#x27;, owner=1)</div><div class=""> 2</div><div class=""> &gt;&gt;&gt; db.dog.insert(name=&#x27;Puppy&#x27;, owner=2)</div><div class=""> 3</div><div class=""> ``:code</div><div class=""> </div><div class=""> You can select as you did for any other table:</div><div class=""> row.person.name</div><div class=""> or:</div><div class=""> ``</div><div class=""> row.dog.name</div><div class=""> ``:code</div><div class=""> </div><div class=""> There is an alterantive syntax for INNER JOINS:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows = db(db.person).select(join=db.dog.on(db.person.id==db.dog.owner))</div><div class=""> &gt;&gt;&gt; for row in rows:</div><div class="">     print row.person.name, &#x27;has&#x27;, row.dog.name</div><div class=""> Alex has Skipper</div><div class=""> Alex has Snoopy</div><div class=""> Bob has Puppy</div><div class=""> ``:code</div><div class=""> </div><div class=""> While the output is the same, the generated SQL in the two cases can be different. The latter syntax removes possible ambiguities when the same table is joined twice and aliased:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;dog&#x27;,</div><div class="">         Field(&#x27;name&#x27;),</div><div class="delete">-        Field(&#x27;owner1&#x27;,db.person),</div><div class="delete">-        Field(&#x27;owner2&#x27;,db.person))</div><div class=""> &gt;&gt;&gt; rows = db(db.person).select(</div><div class="">     join=[db.person.with_alias(&#x27;owner1&#x27;).on(db.person.id==db.dog.owner1).</div><div class="">           db.person.with_alias(&#x27;owner2&#x27;).on(db.person.id==db.dog.owner2)])</div><div class=""> ``</div><div class=""> </div><div class=""> The value of ``join`` can be list of ``db.table.on(...)`` to join.</div><div class=""> </div><div class=""> #### Left outer join</div><div class=""> </div><div class=""> Notice that Carl did not appear in the list above because he has no dogs. If you intend to select on persons (whether they have dogs or not) and their dogs (if they have any), then you need to perform a LEFT OUTER JOIN. This is done using the argument &quot;left&quot; of the select command. Here is an example:</div><div class=""> </div><div class=""> ``Rows``:inxx ``left outer join``:inxx ``outer join``:inxx</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; rows=db().select(</div><div class="">         db.person.ALL, db.dog.ALL,</div><div class="">         left=db.dog.on(db.person.id==db.dog.owner))</div><div class=""> &gt;&gt;&gt; for row in rows:</div><div class="">         print row.person.name, &#x27;has&#x27;, row.dog.name</div><div class=""> Alex has Skipper</div><div class=""> Alex has Snoopy</div><div class=""> When doing joins, sometimes you want to group rows according to certain criteria</div><div class=""> &gt;&gt;&gt; for row in db(db.person.id==db.dog.owner).select(</div><div class="">         db.person.name, count, groupby=db.person.name):</div><div class="">         print row.person.name, row[count]</div><div class=""> Alex 2</div><div class=""> Bob 1</div><div class=""> ``:code</div><div class=""> </div><div class=""> Notice the count operator (which is built-in) is used as a field. The only issue here is in how to retrieve the information. Each row clearly contains a person and the count, but the count is not a field of a person nor is it a table. So where does it go? It goes into the storage object representing the record with a key equal to the query expression itself.</div><div class=""> </div><div class=""> ### Many to many</div><div class=""> ``many-to-many``:inxx</div><div class=""> In the previous examples, we allowed a dog to have one owner but one person could have many dogs. What if Skipper was owned by Alex and Curt? This requires a many-to-many relation, and it is realized via an intermediate table that links a person to a dog via an ownership relation.</div><div class=""> </div><div class=""> Here is how to do it:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;person&#x27;,</div><div class="">                     Field(&#x27;name&#x27;))</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;dog&#x27;,</div><div class="">                     Field(&#x27;name&#x27;))</div><div class=""> &gt;&gt;&gt; db.define_table(&#x27;ownership&#x27;,</div><div class="delete">-                    Field(&#x27;person&#x27;, db.person),</div><div class="delete">-                    Field(&#x27;dog&#x27;, db.dog))</div><div class=""> ``:code</div><div class=""> </div><div class=""> the existing ownership relationship can now be rewritten as:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.ownership.insert(person=1, dog=1) # Alex owns Skipper</div><div class=""> &gt;&gt;&gt; db.ownership.insert(person=1, dog=2) # Alex owns Snoopy</div><div class=""> &gt;&gt;&gt; db.ownership.insert(person=2, dog=3) # Bob owns Puppy</div><div class=""> </div><div class=""> ``:code</div><div class=""> </div><div class=""> Now you can add the new relation that Curt co-owns Skipper:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; db.ownership.insert(person=3, dog=1) # Curt owns Skipper too</div><div class=""> </div><div class=""> ``:code</div><div class=""> </div><div class=""> Because you now have a three-way relation between tables, it may be convenient to define a new set on which to perform operations:</div><div class=""> ``</div><div class=""> &gt;&gt;&gt; persons_and_dogs = db(</div><div class="">         (db.person.id==db.ownership.person) \</div><div class=""> END</div><div class=""> ``:code</div><div class=""> </div><div class=""> The file does not include uploaded files if these are not stored in the database. In any case it is easy enough to zip the &quot;uploads&quot; folder separately.</div><div class=""> </div><div class=""> When importing, the new records will be appended to the database if it is not empty. In general the new imported records will not have the same record id as the original (saved) records but web2py will restore references so they are not broken, even if the id values may change.</div><div class=""> </div><div class=""> If a table contains a field called</div><div class=""> &quot;uuid&quot;, this field will be used to identify duplicates.  Also, if an</div><div class=""> imported record has the same &quot;uuid&quot; as an existing record, the</div><div class=""> previous record will be updated.</div><div class=""> </div><div class=""> #### CSV and remote database synchronization</div><div class=""> </div><div class=""> Consider the following model:</div><div class=""> ``</div><div class=""> db = DAL(&#x27;sqlite:memory:&#x27;)</div><div class=""> db.define_table(&#x27;person&#x27;,</div><div class="">     Field(&#x27;name&#x27;),</div><div class="">     format=&#x27;%(name)s&#x27;)</div><div class=""> db.define_table(&#x27;dog&#x27;,</div><div class="delete">    Field(&#x27;owner&#x27;, <span class="highlight">db.</span>person<span class="highlight"></span>),</div><div class="">     Field(&#x27;name&#x27;),</div><div class="">     format=&#x27;%(name)s&#x27;)</div><div class=""> </div><div class=""> if not db(db.person).count():</div><div class="">     id = db.person.insert(name=&quot;Massimo&quot;)</div><div class="">     db.dog.insert(owner=id, name=&quot;Snoopy&quot;)</div><div class=""> ``:code</div><div class=""> </div><div class=""> Each record is identified by an ID and referenced by that ID. If you</div><div class=""> have two copies of the database used by distinct web2py installations,</div><div class=""> the ID is unique only within each database and not across the databases.</div><div class=""> This is a problem when merging records from different databases.</div><div class=""> </div><div class=""> In order to make a record uniquely identifiable across databases, they</div><div class=""> must:</div><div class=""> - have a unique id (UUID),</div><div class=""> - have an event_time (to figure out which one is more recent if multiple copies),</div><div class=""> - reference the UUID instead of the id.</div><div class=""> </div><div class=""> This can be achieved without modifying web2py. Here is what to do:</div><div class=""> Here is some example usage:</div><div class=""> Which would render something similar to</div><div class=""> ``</div><div class=""> &quot;hello&quot;|35|&quot;this is the text description&quot;|&quot;2009-03-03&quot;</div><div class=""> ``:code</div><div class=""> </div><div class=""> For more information consult the official Python documentation ``quoteall``:cite</div><div class=""> </div><div class=""> ### Caching selects</div><div class=""> </div><div class=""> The select method also takes a cache argument, which defaults to None. For caching purposes, it should be set to a tuple where the first element is the cache model (cache.ram, cache.disk, etc.), and the second element is the expiration time in seconds.</div><div class=""> </div><div class=""> In the following example, you see a controller that caches a select on the previously defined db.log table. The actual select fetches data from the back-end database no more frequently than once every 60 seconds and stores the result in cache.ram. If the next call to this controller occurs in less than 60 seconds since the last database IO, it simply fetches the previous data from cache.ram.</div><div class=""> </div><div class=""> ``cache select``:inxx </div><div class=""> ``</div><div class=""> def cache_db_select():</div><div class="">     logs = db().select(db.log.ALL, cache=(cache.ram, 60))</div><div class="">     return dict(logs=logs)</div><div class=""> ``:code</div><div class=""> </div><div class=""> -------</div><div class="delete">The results of a ``select`` are<span class="highlight"></span> complex, un-pickleable objects; they cannot be stored in a session and cannot be cached in any other way than the one explained here<span class="highlight"></span>.</div><div class=""> -------</div><div class=""> </div><div class=""> ### Self-Reference and aliases</div><div class=""> </div><div class=""> ``self reference``:inxx</div><div class=""> ``alias``:inxx</div><div class=""> It is possible to define tables with fields that refer to themselves although the usual notation may fail. The following code would be wrong because it uses a variable ``db.person`` before it is defined:</div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;,</div><div class="">     Field(&#x27;name&#x27;),</div><div class="delete">-    Field(&#x27;father_id&#x27;, db.person),</div><div class="delete">-    Field(&#x27;mother_id&#x27;, db.person))</div><div class=""> ``:code</div></div></div>
</div>
<hr />





        
      </div>

      <div id="push"></div>
    </div>

    <div id="footer">
      <div class="container-fluid">
          <div class="copyright pull-left">Copyright &#169; 2014</div>
          <div id="poweredBy" class="pull-right">
              Powered by
              <a href="http://www.web2py.com/">web2py</a>
          </div>
      </div>
    </div>
<script src="static/js/bootstrap.min.js"></script>
<script src="static/js/web2py_bootstrap.js"></script>
</body>
</html>
