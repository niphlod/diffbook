<!DOCTYPE html>
<!-- paulirish.com/2008/conditional-stylesheets-vs-css-hacks-answer-neither/ -->
<!--[if lt IE 7]><html class="ie ie6 ie-lte9 ie-lte8 ie-lte7 no-js" lang="en-us"> <![endif]-->
<!--[if IE 7]><html class="ie ie7 ie-lte9 ie-lte8 ie-lte7 no-js" lang="en-us"> <![endif]-->
<!--[if IE 8]><html class="ie ie8 ie-lte9 ie-lte8 no-js" lang="en-us"> <![endif]-->
<!--[if IE 9]><html class="ie9 ie-lte9 no-js" lang="en-us"> <![endif]-->
<!--[if (gt IE 9)|!(IE)]><!--> <html class="no-js" lang="en-us"> <!--<![endif]-->
<head>
  <meta charset="utf-8" />
  <!-- www.phpied.com/conditional-comments-block-downloads/ -->
  <!-- Always force latest IE rendering engine
       (even in intranet) & Chrome Frame
       Remove this if you use the .htaccess -->
  <!--[if IE]>
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <![endif]-->

  <title>Diffbook</title>

  <!-- http://dev.w3.org/html5/markup/meta.name.html -->
  <meta name="application-name" content="diffbook" />

  <!-- Speaking of Google, don't forget to set your site up:
       http://google.com/webmasters -->
  <meta name="google-site-verification" content="" />

  <!--  Mobile Viewport Fix
        j.mp/mobileviewport & davidbcalhoun.com/2010/viewport-metatag
        device-width: Occupy full width of the screen in its current orientation
        initial-scale = 1.0 retains dimensions instead of zooming out if page height > device height
        user-scalable = yes allows the user to zoom in -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <link rel="shortcut icon" href="static/images/favicon.ico" type="image/x-icon">
  <link rel="apple-touch-icon" href="static/images/favicon.png">

  <!-- All JavaScript at the bottom, except for Modernizr which enables
       HTML5 elements & feature detects -->
  <script src="static/js/modernizr.custom.js"></script>

  <!-- include stylesheets -->
  

  <script type="text/javascript"><!--
    // These variables are used by the web2py_ajax_init function in web2py_ajax.js (which is loaded below).
    var w2p_ajax_confirm_message = "Are you sure you want to delete this object?";
    var w2p_ajax_date_format = "%Y-%m-%d";
    var w2p_ajax_datetime_format = "%Y-%m-%d %H:%M:%S";
    //--></script>
<meta name="keywords" content="web2py, python, framework" />

<meta name="description" content="a cool new app" />

<meta name="generator" content="Web2py Web Framework" />

<meta name="author" content="Your Name &lt;you@example.com&gt;" />
<script src="static/js/jquery.js" type="text/javascript"></script><link href="static/css/calendar.css" rel="stylesheet" type="text/css" /><script src="static/js/calendar.js" type="text/javascript"></script><script src="static/js/web2py.js" type="text/javascript"></script><link href="static/css/web2py.css" rel="stylesheet" type="text/css" /><link href="static/css/bootstrap.min.css" rel="stylesheet" type="text/css" /><link href="static/css/bootstrap-responsive.min.css" rel="stylesheet" type="text/css" /><link href="static/css/web2py_bootstrap.css" rel="stylesheet" type="text/css" />


  

  <!-- uncomment here to load jquery-ui
       <link rel="stylesheet" href="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8.16/themes/base/jquery-ui.css" type="text/css" media="all" />
       <script src="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8.16/jquery-ui.min.js" type="text/javascript"></script>
       uncomment to load jquery-ui //-->
  <noscript><link href="static/css/web2py_bootstrap_nojs.css" rel="stylesheet" type="text/css" /></noscript>
  
  <style type="text/css">

      /* Sticky footer styles
      -------------------------------------------------- */

      html,
      body {
        height: 100%;
        /* The html and body elements cannot have any padding or margin. */
      }

      /* Wrapper for page content to push down footer */
      #wrap {
        min-height: 100%;
        height: auto !important;
        height: 100%;
        /* Negative indent footer by it's height */
        margin: 0 auto -60px;
      }

      /* Set the fixed height of the footer here */
      #push,
      #footer {
        height: 60px;
      }
      #footer {
        background-color: #f5f5f5;
      }

      /* Lastly, apply responsive CSS fixes as necessary */
      @media (max-width: 767px) {
        #footer {
          margin-left: -20px;
          margin-right: -20px;
          padding-left: 20px;
          padding-right: 20px;
        }
      }



      /* Custom page CSS
      -------------------------------------------------- */
      /* Not required for template or sticky footer method. */

      .container {
        width: auto;
        max-width: 680px;
      }
      .container .credit {
        margin: 20px 0;
      }

    </style>
</head>

<body>
  
  <body>


    <!-- Part 1: Wrap all page content here -->
    <div id="wrap">

      <!-- Begin page content -->
      <div class="container-fluid">
        <div class="page-header">
          	<h1>
              Diffbook
              <small>easy? diffbook</small>
            </h1>
        </div>
        
        

<div class="pagination">
  <ul>    

      <li><a href="/diffbook/0.html">Chapter 0</a></li>

      <li><a href="/diffbook/1.html">Chapter 1</a></li>

      <li><a href="/diffbook/2.html">Chapter 2</a></li>

      <li><a href="/diffbook/3.html">Chapter 3</a></li>

      <li><a href="/diffbook/4.html">Chapter 4</a></li>

      <li><a href="/diffbook/5.html">Chapter 5</a></li>

      <li><a href="/diffbook/6.html">Chapter 6</a></li>

      <li><a href="/diffbook/7.html">Chapter 7</a></li>

      <li><a href="/diffbook/8.html">Chapter 8</a></li>

      <li><a href="/diffbook/9.html">Chapter 9</a></li>

      <li><a href="/diffbook/10.html">Chapter 10</a></li>

      <li><a href="/diffbook/11.html">Chapter 11</a></li>

      <li><a href="/diffbook/12.html">Chapter 12</a></li>

  </ul>
</div>

<div class="pagination">
  <ul>    

      <li><a href="#com_c877880cf4b1b62260c1d2fc817ce0c02b6a29a1">c877880</a></li>

      <li><a href="#com_4554a3f1098bc968b8595d3b90640c9464a07135">4554a3f</a></li>

      <li><a href="#com_f74941a5a1e849459f1fbea6dc9a2861e40e419a">f74941a</a></li>

      <li><a href="#com_d9fb0f6b2ee04c7256f280df7821ef0f99adbc91">d9fb0f6</a></li>

      <li><a href="#com_7bce1473ce90f4e60f49d72bf1b61d32f430cb54">7bce147</a></li>

      <li><a href="#com_f2fd41dd2a0d4bf68f5cd4f0989fb32bdc35eac5">f2fd41d</a></li>

      <li><a href="#com_8ec972820c26ac5695a72b3b0d93e1422449853e">8ec9728</a></li>

      <li><a href="#com_e234f6edf67361b3ba718ea10184ba8e7c2f773d">e234f6e</a></li>

      <li><a href="#com_eaaa0e14bf17cdc4d0edd2ea9daa9af5f3484c09">eaaa0e1</a></li>

      <li><a href="#com_e8428580c4f1c39b457a9b9614f3ccd14f6b3fb5">e842858</a></li>

      <li><a href="#com_097d699dc16179206ccb7e4aee863d6523cd471c">097d699</a></li>

      <li><a href="#com_bb5fb21852c40f3b628510ef0be7a07d53cf4f9d">bb5fb21</a></li>

      <li><a href="#com_885e6c33d6165e8cccf89b33130de7a03534b119">885e6c3</a></li>

      <li><a href="#com_ec3132989d6a44efafb59155ad3a3f06df599ec7">ec31329</a></li>

      <li><a href="#com_716473666742d68f3ed66204eb0682e076e90b99">7164736</a></li>

      <li><a href="#com_49f38ab7ef56de1eb4ef48f68427ebf8a46b505d">49f38ab</a></li>

  </ul>
</div>



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/c877880cf4b1b62260c1d2fc817ce0c02b6a29a1">c877880</a><ul><li>Date : 2013-01-26</li><li>fixed pgp, thanks Martin</li></ul></li></ul>
<div class="row-fluid" id="com_c877880cf4b1b62260c1d2fc817ce0c02b6a29a1">
    <div class="span6"><pre style="background-color: #DFF0D8;">It is possible to send PGP encrypted emails. First of all you need to install the python-pyme package. Then you can use GnuPG (GPG) to create the key-files for the sender (take the email-address from mail.settings.sender) and put the files pubring.gpg and  secring.gpg in a directory (e.g. &quot;/home/www-data/.gnupg&quot;).

Use the following settings:

``
mail.settings.gpg_home = &#x27;/home/www-data/.gnupg/&#x27;
mail.settings.cipher_type = &#x27;gpg&#x27;
mail.settings.sign = True
mail.settings.sign_passphrase = &#x27;your passphrase&#x27;
mail.settings.encrypt = True
``:code

### Sending emails
``mail.send``:inxx ``email html``:inxx ``email attachments``:inxx
</pre></div>
    <div class="span6"><pre style="background-color: #F2DEDE;">It is possible to send PGP encrypted emails using the following settings:
``
from gpgme import pgp
mail.settings.cipher_type = &#x27;gpg&#x27;
mail.settings.sign = True
mail.settings.sign_passphrase = &#x27;your passphrase&#x27;
mail.settings.encrypt = True
``:code

The latter requires the python-pyme package.

### Sending emails
``mail.send``:inxx ``email html``:inxx ``email attachments``:inxx
</pre></div>
</div>
<hr />

<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/4554a3f1098bc968b8595d3b90640c9464a07135">4554a3f</a><ul><li>Date : 2012-09-16</li><li>pool_size option</li></ul></li></ul>
<div class="row-fluid" id="com_4554a3f1098bc968b8595d3b90640c9464a07135">
    <div class="span6"><pre style="background-color: #DFF0D8;">``
# Replace user, password, server and port in the connection string
# Set port as 993 for ssl support
imapdb = DAL(&quot;imap://user:password@server:port&quot;, pool_size=1)
imapdb.define_tables()
``:code
</pre></div>
    <div class="span6"><pre style="background-color: #F2DEDE;">``
# Replace user, password, server and port in the connection string
# Set port as 993 for ssl support
imapdb = DAL(&quot;imap://user:password@server:port&quot;)
imapdb.define_tables()
``:code
</pre></div>
</div>
<hr />

<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/f74941a5a1e849459f1fbea6dc9a2861e40e419a">f74941a</a><ul><li>Date : 2013-01-08</li><li>Added documentation on mail.settings.tls</li></ul></li></ul>
<div class="row-fluid" id="com_f74941a5a1e849459f1fbea6dc9a2861e40e419a">
    <div class="span6"><pre style="background-color: #DFF0D8;">You need to replace the mail.settings with the proper parameters for your SMTP server. Set ``mail.settings.login = None`` if the SMTP server does not require authentication.
If you don&#x27;t want to use TLS, set ``mail.settings.tls = False``
</pre></div>
    <div class="span6"><pre style="background-color: #F2DEDE;">You need to replace the mail.settings with the proper parameters for your SMTP server. Set ``mail.settings.login = None`` if the SMTP server does not require authentication.
</pre></div>
</div>
<hr />

<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/d9fb0f6b2ee04c7256f280df7821ef0f99adbc91">d9fb0f6</a><ul><li>Date : 2012-10-05</li><li>The first can be useful</li></ul></li></ul>
<div class="row-fluid" id="com_d9fb0f6b2ee04c7256f280df7821ef0f99adbc91">
    <div class="span6"><pre style="background-color: #DFF0D8;">The first can be useful to retrieve imap query sets by the native email service mailbox
``
# mailbox is a string containing the actual mailbox name
tablenames = dict([(v,k) for k,v in imapdb.mailboxes.items()])
myset = imapdb(imapdb[tablenames[mailbox]])
``:code
</pre></div>
    <div class="span6"><pre style="background-color: #F2DEDE;">
The second can be useful to retrieve imap query sets by the native email service mailbox
``
# mailbox is a string containing the actual mailbox name
tablenames = dict([(v,k) for k,v in imapdb.mailboxes.items()])
tablename = tablenames[mailbox]
myset = imapdb(imapdb[tablename])
``:code
</pre></div>
</div>
<hr />

<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/7bce1473ce90f4e60f49d72bf1b61d32f430cb54">7bce147</a><ul><li>Date : 2012-12-22</li><li>scheduler.queue_task</li></ul></li></ul>
<div class="row-fluid" id="com_7bce1473ce90f4e60f49d72bf1b61d32f430cb54">
    <div class="span6"><pre style="background-color: #DFF0D8;">## Emails and SMS

``Mail``:inxx

### Setting up email

Web2py provides the ``gluon.tools.Mail`` class to make it easy to send emails using web2py. One can define a mailer with
``
from gluon.tools import Mail
mail = Mail()
mail.settings.server = &#x27;smtp.example.com:25&#x27;
mail.settings.sender = &#x27;you@example.com&#x27;
mail.settings.login = &#x27;username:password&#x27;
``:code

Note, if your application uses ``Auth`` (discussed in the next chapter), the ``auth`` object will include its own mailer in ``auth.settings.mailer``, so you can use that instead as follows:
``
mail = auth.settings.mailer
mail.settings.server = &#x27;smtp.example.com:25&#x27;
mail.settings.sender = &#x27;you@example.com&#x27;
mail.settings.login = &#x27;username:password&#x27;
``:code

You need to replace the mail.settings with the proper parameters for your SMTP server. Set ``mail.settings.login = None`` if the SMTP server does not require authentication.

``email logging``:inxx

--------
For debugging purposes you can set
``
mail.settings.server = &#x27;logging&#x27;
``:code
and emails will not be sent but logged to the console instead.
-------

#### Configuring email for Google App Engine
``email from GAE``:inxx
For sending emails from Google App Engine account:

``
mail.settings.server = &#x27;gae&#x27;
``:code

At the time of writing web2py does not support attachments and encrypted emails on Google App Engine. Notice cron and scheduler do not work on GAE.
</pre></div>
    <div class="span6"><pre style="background-color: #F2DEDE;">## Email and SMS
``Mail``:inxx

### Setting up email

Web2py provides the ``gluon.tools.Mail`` class to make it easy to send emails using web2py. One can define a mailer with
``
from gluon.tools import Mail
mail = Mail()
mail.settings.server = &#x27;smtp.example.com:25&#x27;
mail.settings.sender = &#x27;you@example.com&#x27;
mail.settings.login = &#x27;username:password&#x27;
``:code

Note, if your application uses ``Auth`` (discussed in the next chapter), the ``auth`` object will include its own mailer in ``auth.settings.mailer``, so you can use that instead as follows:
``
mail = auth.settings.mailer
mail.settings.server = &#x27;smtp.example.com:25&#x27;
mail.settings.sender = &#x27;you@example.com&#x27;
mail.settings.login = &#x27;username:password&#x27;
``:code

You need to replace the mail.settings with the proper parameters for your SMTP server. Set ``mail.settings.login = None`` if the SMTP server does not require authentication.

``email logging``:inxx

--------
For debugging purposes you can set
``
mail.settings.server = &#x27;logging&#x27;
``:code
and emails will not be sent but logged to the console instead.
-------

#### Configuring email for Google App Engine
``email from GAE``:inxx
For sending emails from Google App Engine account:

``
mail.settings.server = &#x27;gae&#x27;
``:code

At the time of writing web2py does not support attachments and encrypted emails on Google App Engine.
</pre></div>
</div>
<hr />

<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/f2fd41dd2a0d4bf68f5cd4f0989fb32bdc35eac5">f2fd41d</a><ul><li>Date : 2012-12-31</li><li>spell check of diffs, thanks Joanthan</li></ul></li></ul>
<div class="row-fluid" id="com_f2fd41dd2a0d4bf68f5cd4f0989fb32bdc35eac5">
    <div class="span6"><pre style="background-color: #DFF0D8;">For a single mail account, this is the code recommended to start IMAP support at the app&#x27;s model

``
# Replace user, password, server and port in the connection string
# Set port as 993 for SSL support
imapdb = DAL(&quot;imap://user:password@server:port&quot;, pool_size=1)
imapdb.define_tables()
``:code

Note that ``&lt;imapdb&gt;.define_tables()`` returns a dictionary of strings mapping DAL tablenames to the server mailbox names with the structure ``{&lt;tablename&gt;: &lt;server mailbox name&gt;, ...}``, so you can get the actual mailbox name in the IMAP server.


To handle the different native mailbox names for the user interface,  the following attributes give access to the adapter auto mailbox mapped names (which native mailbox has what table name and vice versa):

-------------------------------------
**Attribute** | **Type** | **Format**
imapdb.mailboxes | dict | ``{&lt;tablename&gt;: &lt;server native name&gt;, ...}``
imapdb.&lt;table&gt;.mailbox | string | ``&quot;server native name&quot;``
-------------------------------------

The first can be useful to retrieve IMAP query sets by the native email service mailbox
``
# mailbox is a string containing the actual mailbox name
tablenames = dict([(v,k) for k,v in imapdb.mailboxes.items()])
myset = imapdb(imapdb[tablenames[mailbox]])
``:code

#### Fetching mail and updating flags

Here&#x27;s a list of IMAP commands you could use in the controller. For the examples, it&#x27;s assumed that your IMAP service has a mailbox named ``INBOX``, which is the case for Gmail(r) accounts.


To count today&#x27;s unseen messages smaller than 6000 octets from the inbox mailbox do
``
q = imapdb.INBOX.seen == False
q &amp;= imapdb.INBOX.created == datetime.date.today()
q &amp;= imapdb.INBOX.size &lt; 6000
unread = imapdb(q).count()
``:code


You can fetch the previous query messages with
``
rows = imapdb(q).select()
``:code


Usual query operators are implemented, including belongs

``
messages = imapdb(imapdb.INBOX.uid.belongs(&lt;uid sequence&gt;)).select()
``:code

**Note**: It&#x27;s strongly advised that you keep the query results below a given data size threshold to avoid jamming the server with large select commands. As of now, the messages are retrieved entirely by the adapter before any filter by field can be applied.

It is possible to filter query select results with limitby and sequences of mailbox fields
``
# Replace the arguments with actual values
myset.select(&lt;fields sequence&gt;, limitby=(&lt;int&gt;, &lt;int&gt;))
``:code

Say you want to have an app action show a mailbox message. First we retrieve the message (If your IMAP service supports it, fetch messages by ``uid`` field to avoid using old sequence references).

``
mymessage = imapdb(imapdb.INBOX.uid == &lt;uid&gt;).select().first()
``:code

Otherwise, you can use the message&#x27;s ``id``.

``
mymessage = imapdb.INBOX[&lt;id&gt;]
``:code

Note that using the message&#x27;s id as reference is not recommended, because sequence numbers can change with mailbox maintenance operations as message deletions. If you still want to record references to messages (i.e. in another database&#x27;s record field), the solution is to use the uid field as reference whenever supported, and retrieve each message with the recorded value.

Finally, add something like the following to show the message content in a view

``
{{=P(T(&quot;Message from&quot;), &quot; &quot;, mymessage.sender)}}
{{=P(T(&quot;Received on&quot;), &quot; &quot;, mymessage.created)}}
{{=H5(mymessage.subject)}}
{{for text in mymessage.content:}}
  {{=DIV(text)}}
  {{=TR()}}
{{pass}}
``:code

As expected, we can take advantage of the ``SQLTABLE`` helper to build message lists in views

``
{{=SQLTABLE(myset.select(), linkto=URL(...))}}
``:code

And of course, it&#x27;s possible to feed a form helper with the appropriate sequence id value

``
{{=SQLFORM(imapdb.INBOX, &lt;message id&gt;, fields=[...])}}
``:code

The current adapter supported fields available are the following:

---------------------------------------
**Field** | **Type** | **Description**
uid | string | ````
answered | boolean | Flag
created | date | ````
content | list:string | A list of text or html parts
to | string | ````
cc | string | ````
bcc | string | ````
size | integer | the amount of octets of the message*
deleted | boolean | Flag
draft | boolean | Flag
flagged | boolean | Flag
sender | string | ````
recent | boolean | Flag
seen | boolean  | Flag
subject | string| ````
mime | string | The mime header declaration
email | string | The complete RFC822 message**
attachments | list:string | Each non text decoded part as string
---------------------------------------------------

*At the application side it is measured as the length of the RFC822
message string

**WARNING**: As row id&#x27;s are mapped to email sequence numbers, make sure your IMAP client web2py app does not delete messages
during select or update actions, to prevent updating or deleting different messages.


Standard ``CRUD`` database operations are not supported. There&#x27;s no way of defining custom fields or tables and make inserts with different data types because updating mailboxes with IMAP services is usually reduced to posting flag updates to the server. Still, it&#x27;s possible to access those flag commands through the DAL IMAP interface

To mark last query messages as seen
``
seen = imapdb(q).update(seen=True)
``:code


Here we delete messages in the IMAP database that have mails from mr. Gumby
``
deleted = 0
for tablename in imapdb.tables():
    deleted += imapdb(imapdb[tablename].sender.contains(&quot;gumby&quot;)).delete()
``:code


It is possible also to mark messages for deletion instead of erasing them
directly with
``
myset.update(deleted=True)
``:code
</pre></div>
    <div class="span6"><pre style="background-color: #F2DEDE;">For a single mail account, this is the code recommended to start imap support at the app&#x27;s model

``
# Replace user, password, server and port in the connection string
# Set port as 993 for ssl support
imapdb = DAL(&quot;imap://user:password@server:port&quot;, pool_size=1)
imapdb.define_tables()
``:code

Note that ``&lt;imapdb&gt;.define_tables()`` returns a dictionary of strings mapping dal tablenames to the server mailbox names with the structure ``{&lt;tablename&gt;: &lt;server mailbox name&gt;, ...}``, so you can get the actual mailbox name in the IMAP server.


To handle the different native mailbox names for the user interface,  the following attributes give access to the adapter auto mailbox mapped names (which native mailbox has what table name and vice versa):

-------------------------------------
**Attribute** | **Type** | **Format**
imapdb.mailboxes | dict | ``{&lt;tablename&gt;: &lt;server native name&gt;, ...}``
imapdb.&lt;table&gt;.mailbox | string | ``&quot;server native name&quot;``
-------------------------------------

The first can be useful to retrieve imap query sets by the native email service mailbox
``
# mailbox is a string containing the actual mailbox name
tablenames = dict([(v,k) for k,v in imapdb.mailboxes.items()])
myset = imapdb(imapdb[tablenames[mailbox]])
``:code

#### Fetching mail and updating flags

Here&#x27;s a list of imap commands you could use in the controller. For the examples, it&#x27;s assumed that your imap service has a mailbox named ``INBOX``, which is the case for Gmail(r) accounts.


To count today&#x27;s unseen messages smaller than 6000 octets from the inbox mailbox do
``
q = imapdb.INBOX.seen == False
q &amp;= imapdb.INBOX.created == datetime.date.today()
q &amp;= imapdb.INBOX.size &lt; 6000
unread = imapdb(q).count()
``:code


You can fetch the previous query messages with
``
rows = imapdb(q).select()
``:code


Usual query operators are implemented, including belongs

``
messages = imapdb(imapdb.INBOX.uid.belongs(&lt;uid sequence&gt;)).select()
``:code

**Note**: It&#x27;s strongly adviced that you keep the query results below a given data size threshold to avoid jamming the server with large select commands. As of now, the messages are retrieved entirely by the adapter before any filter by field can be applied.

It is possible to filter query select results with limitby and sequences of mailbox fields
``
# Replace the arguments with actual values
myset.select(&lt;fields sequence&gt;, limitby=(&lt;int&gt;, &lt;int&gt;))
``:code

Say you want to have an app action show a mailbox message. First we retrieve the message (If your IMAP service supports it, fetch messages by ``uid`` field to avoid using old sequence references).

``
mymessage = imapdb(imapdb.INBOX.uid == &lt;uid&gt;).select().first()
``:code

Otherwise, you can use the message&#x27;s ``id``.

``
mymessage = imapdb.INBOX[&lt;id&gt;]
``:code

Note that using the message&#x27;s id as reference is not recommended, because sequence numbers can change with mailbox mantainance operations as message deletions. If you still want to record references to messages (i.e. in another database&#x27;s record field), the solution is to use the uid field as reference whenever supported, and retrieve each message with the recorded value.

Finally, add something like the following to show the message content in a view

``
{{=P(T(&quot;Message from&quot;), &quot; &quot;, mymessage.sender)}}
{{=P(T(&quot;Received on&quot;), &quot; &quot;, mymessage.created)}}
{{=H5(mymessage.subject)}}
{{for text in mymessage.content:}}
  {{=DIV(text)}}
  {{=TR()}}
{{pass}}
``:code

As expected, we can take advantage of the ``SQLTABLE`` helper to build message lists in views

``
{{=SQLTABLE(myset.select(), linkto=URL(...))}}
``:code

And of course, it&#x27;s possible to feed a form helper with the appropiate sequence id value

``
{{=SQLFORM(imapdb.INBOX, &lt;message id&gt;, fields=[...])}}
``:code

The current adapter supported fields available are the following:

---------------------------------------
**Field** | **Type** | **Description**
uid | string | ````
answered | boolean | Flag
created | date | ````
content | list:string | A list of text or html parts
to | string | ````
cc | string | ````
bcc | string | ````
size | integer | the amount of octets of the message*
deleted | boolean | Flag
draft | boolean | Flag
flagged | boolean | Flag
sender | string | ````
recent | boolean | Flag
seen | boolean  | Flag
subject | string| ````
mime | string | The mime header declaration
email | string | The complete RFC822 message**
attachments | list:string | Each non text decoded part as string
---------------------------------------------------

*At the application side it is measured as the length of the RFC822
message string

**WARNING**: As row id&#x27;s are mapped to email sequence numbers, make sure your imap client web2py app does not delete messages
during select or update actions, to prevent updating or deleting different messages.


Standard ``CRUD`` database operations are not supported. There&#x27;s no way of defining custom fields or tables and make inserts with different data types because updating mailboxes with IMAP services is usually reduced to posting flag updates to the server. Still, it&#x27;s possible to access those flag commands trough DAL IMAP inteface

To mark last query messages as seen
``
seen = imapdb(q).update(seen=True)
``:code


Here we delete messages in the imap database that have mails from mr. Gumby
``
deleted = 0
for tablename in imapdb.tables():
    deleted += imapdb(imapdb[tablename].sender.contains(&quot;gumby&quot;)).delete()
``:code


It is possible also to mark messages for deletion instead of ereasing them
directly with
``
myset.update(deleted=True)
``:code
</pre></div>
</div>
<hr />

<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/8ec972820c26ac5695a72b3b0d93e1422449853e">8ec9728</a><ul><li>Date : 2012-10-05</li><li>New usage of adapter attributes</li></ul></li></ul>
<div class="row-fluid" id="com_8ec972820c26ac5695a72b3b0d93e1422449853e">
    <div class="span6"><pre style="background-color: #DFF0D8;">-------------------------------------------------------
**Attribute** | **Type** | **Format**
=======================================================================
imapdb.mailboxes | dict | ``{&lt;tablename&gt;: &lt;server native name&gt;, ...}``
imapdb.&lt;table&gt;.mailbox | string | ``&quot;server native name&quot;``
=======================================================================
-------------------------------------------------------


The second can be useful to retrieve imap query sets by the native email service mailbox
``
# mailbox is a string containing the actual mailbox name
tablename = imapdb.mailboxes[mailbox]
myset = imapdb(imapdb[tablename])
``:code

#### Fetching mail and updating flags

Here&#x27;s a list of imap commands you could use in the controller. For the examples, it&#x27;s assumed that your imap service has a mailbox named ``INBOX``, which is the case for Gmail(r) accounts.


To count today&#x27;s unseen messages smaller than 6000 octets from the inbox mailbox do
``
q = imapdb.INBOX.seen == False
q &amp;= imapdb.INBOX.created == datetime.date.today()
q &amp;= imapdb.INBOX.size &lt; 6000
unread = imapdb(q).count()
``:code


You can fetch the previous query messages with
``
rows = imapdb(q).select()
``:code


Usual query operators are implemented, including belongs

``
messages = imapdb(imapdb.INBOX.uid.belongs(&lt;uid sequence&gt;)).select()
``:code

**Note**: It&#x27;s strongly adviced that you keep the query results below a given data size threshold to avoid jamming the server with large select commands. As of now, the messages are retrieved entirely by the adapter before any filter by field can be applied.
deleted | boolean | Flag
draft | boolean | Flag
flagged | boolean | Flag
sender | string |
recent | boolean | Flag
seen | boolean  | Flag
subject | string|
mime | string | The mime header declaration
email | string | The complete RFC822 message**
attachments | list:string | Each non text decoded part as string
================================================================
----------------------------------------------------------------

*At the application side it is measured as the length of the RFC822
message string

**WARNING**: As row id&#x27;s are mapped to email sequence numbers, make sure your imap client web2py app does not delete messages
during select or update actions, to prevent updating or deleting different messages.


Standard ``CRUD`` database operations are not supported. There&#x27;s no way of defining custom fields or tables and make inserts with different data types because updating mailboxes with IMAP services is usually reduced to posting flag updates to the server. Still, it&#x27;s possible to access those flag commands trough DAL IMAP inteface

To mark last query messages as seen
``
seen = imapdb(q).update(seen=True)
``:code


Here we delete messages in the imap database that have mails from mr. Gumby
``
deleted = 0
for tablename in imapdb.tables():
    deleted += imapdb(imapdb[tablename].sender.contains(&quot;gumby&quot;)).delete()
``:code
</pre></div>
    <div class="span6"><pre style="background-color: #F2DEDE;">-------------------------------------------------------
**Attribute** | **Type** | **Format**
=======================================================================
imapdb.mailboxes | list | ``[&lt;tablename&gt;, ...]``
imapdb.mailbox_names | dict | ``{&lt;tablename&gt;: &lt;server native name&gt;, ...}``
=======================================================================
-------------------------------------------------------


The second can be useful to retrieve imap query sets by the native email service mailbox
``
# mailbox is a string containing the actual mailbox name
tablename = imapdb.mailbox_names[mailbox]
myset = imapdb(imapdb[tablename])
``:code

#### Fetching mail and updating flags

Here&#x27;s a list of imap commands you could use in the controller. For the examples, it&#x27;s assumed that your imap service has a mailbox named ``INBOX``, which is the case for Gmail(r) accounts.


To count today&#x27;s unseen messages smaller than 6000 octets from the inbox mailbox do
``
q = imapdb.INBOX.seen == False
q &amp;= imapdb.INBOX.created == datetime.date.today()
q &amp;= imapdb.INBOX.size &lt; 6000
unread = imapdb(q).count()
``:code


You can fetch the previous query messages with
``
rows = imapdb(q).select()
``:code


Usual query operators are implemented, including belongs

``
messages = imapdb(imapdb.INBOX.uid.belongs(&lt;uid sequence&gt;)).select()
``:code

**Note**: It&#x27;s strongly adviced that you keep the query results below a given data size threshold to avoid jamming the server with large select commands. As of now, the messages are retrieved entirely by the adapter before any filter by field can be applied.
deleted | boolean | Flag
draft | boolean | Flag
flagged | boolean | Flag
sender | string |
recent | boolean | Flag
seen | boolean  | Flag
subject | string|
mime | string | The mime header declaration
email | string | The complete RFC822 message**
attachments | list:string | Each non text decoded part as string
================================================================
----------------------------------------------------------------

*At the application side it is measured as the length of the RFC822
message string

**WARNING**: As row id&#x27;s are mapped to email sequence numbers, make sure your imap client web2py app does not delete messages
during select or update actions, to prevent updating or deleting different messages.


Standard ``CRUD`` database operations are not supported. There&#x27;s no way of defining custom fields or tables and make inserts with different data types because updating mailboxes with IMAP services is usually reduced to posting flag updates to the server. Still, it&#x27;s possible to access those flag commands trough DAL IMAP inteface

To mark last query messages as seen
``
seen = imapdb(q).update(seen=True)
``:code


Here we delete messages in the imap database that have mails from mr. Gumby
``
deleted = 0
for tablename in imapdb.tables
    deleted += imapdb(imapdb[tablename].sender.contains(&quot;gumby&quot;)).delete()
``:code
</pre></div>
</div>
<hr />

<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/e234f6edf67361b3ba718ea10184ba8e7c2f773d">e234f6e</a><ul><li>Date : 2012-12-20</li><li>lots of improvements</li></ul></li></ul>
<div class="row-fluid" id="com_e234f6edf67361b3ba718ea10184ba8e7c2f773d">
    <div class="span6"><pre style="background-color: #DFF0D8;">``
send(self, to, subject=&#x27;None&#x27;, message=&#x27;None&#x27;, attachments=1,
     cc=1, bcc=1, reply_to=1, encoding=&#x27;utf-8&#x27;,headers={},
     sender=None)
``:code

Note, ``to``, ``cc``, and ``bcc`` each take a list of email addresses.

``headers`` is dictionary of headers to refine the headers just before sending the email. For example:

``
headers = {&#x27;Return-Path&#x27; : &#x27;bounces@example.org&#x27;}
``:code

``sender`` defaults to ``None`` and in this case the sender will be set to ``mail.settings.sender``.

Following are some additional examples demonstrating the use of ``mail.send()``.
</pre></div>
    <div class="span6"><pre style="background-color: #F2DEDE;">``
send(self, to, subject=&#x27;None&#x27;, message=&#x27;None&#x27;, attachments=1,
     cc=1, bcc=1, reply_to=1, encoding=&#x27;utf-8&#x27;,headers={})
``:code

Note, ``to``, ``cc``, and ``bcc`` each take a list of email addresses.

``headers`` is dictionary of headers to refine the headers just before sending the email. For example:

``
headers = {&#x27;Return-Path&#x27; : &#x27;bounces@example.org&#x27;}
``:code

Following are some additional examples demonstrating the use of ``mail.send()``.
</pre></div>
</div>
<hr />

<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/eaaa0e14bf17cdc4d0edd2ea9daa9af5f3484c09">eaaa0e1</a><ul><li>Date : 2012-12-25</li><li>changes to style</li></ul></li></ul>
<div class="row-fluid" id="com_eaaa0e14bf17cdc4d0edd2ea9daa9af5f3484c09">
    <div class="span6"><pre style="background-color: #DFF0D8;">-------------------------------------
**Attribute** | **Type** | **Format**
imapdb.mailboxes | dict | ``{&lt;tablename&gt;: &lt;server native name&gt;, ...}``
imapdb.&lt;table&gt;.mailbox | string | ``&quot;server native name&quot;``
-------------------------------------

The first can be useful to retrieve imap query sets by the native email service mailbox
``
# mailbox is a string containing the actual mailbox name
tablenames = dict([(v,k) for k,v in imapdb.mailboxes.items()])
myset = imapdb(imapdb[tablenames[mailbox]])
``:code

#### Fetching mail and updating flags

Here&#x27;s a list of imap commands you could use in the controller. For the examples, it&#x27;s assumed that your imap service has a mailbox named ``INBOX``, which is the case for Gmail(r) accounts.


To count today&#x27;s unseen messages smaller than 6000 octets from the inbox mailbox do
``
q = imapdb.INBOX.seen == False
q &amp;= imapdb.INBOX.created == datetime.date.today()
q &amp;= imapdb.INBOX.size &lt; 6000
unread = imapdb(q).count()
``:code


You can fetch the previous query messages with
``
rows = imapdb(q).select()
``:code


Usual query operators are implemented, including belongs

mymessage = imapdb.INBOX[&lt;id&gt;]
Note that using the message&#x27;s id as reference is not recommended, because sequence numbers can change with mailbox mantainance operations as message deletions. If you still want to record references to messages (i.e. in another database&#x27;s record field), the solution is to use the uid field as reference whenever supported, and retrieve each message with the recorded value.

Finally, add something like the following to show the message content in a view

``
{{=P(T(&quot;Message from&quot;), &quot; &quot;, mymessage.sender)}}
{{=P(T(&quot;Received on&quot;), &quot; &quot;, mymessage.created)}}
{{=H5(mymessage.subject)}}
{{for text in mymessage.content:}}
  {{=DIV(text)}}
  {{=TR()}}
{{pass}}
``:code

As expected, we can take advantage of the ``SQLTABLE`` helper to build message lists in views

``
{{=SQLTABLE(myset.select(), linkto=URL(...))}}
``:code

And of course, it&#x27;s possible to feed a form helper with the appropiate sequence id value

``
{{=SQLFORM(imapdb.INBOX, &lt;message id&gt;, fields=[...])}}
``:code

The current adapter supported fields available are the following:

---------------------------------------
**Field** | **Type** | **Description**
uid | string |
answered | boolean | Flag
created | date |
content | list:string | A list of text or html parts
to | string |
cc | string |
bcc | string |
size | integer | the amount of octets of the message*
deleted | boolean | Flag
draft | boolean | Flag
flagged | boolean | Flag
sender | string |
recent | boolean | Flag
seen | boolean  | Flag
subject | string|
mime | string | The mime header declaration
email | string | The complete RFC822 message**
attachments | list:string | Each non text decoded part as string
---------------------------------------------------
</pre></div>
    <div class="span6"><pre style="background-color: #F2DEDE;">**Attribute** | **Type** | **Format**
=======================================================================
imapdb.mailboxes | dict | ``{&lt;tablename&gt;: &lt;server native name&gt;, ...}``
imapdb.&lt;table&gt;.mailbox | string | ``&quot;server native name&quot;``
=======================================================================

The first can be useful to retrieve imap query sets by the native email service mailbox
``
# mailbox is a string containing the actual mailbox name
tablenames = dict([(v,k) for k,v in imapdb.mailboxes.items()])
myset = imapdb(imapdb[tablenames[mailbox]])
``:code

#### Fetching mail and updating flags

Here&#x27;s a list of imap commands you could use in the controller. For the examples, it&#x27;s assumed that your imap service has a mailbox named ``INBOX``, which is the case for Gmail(r) accounts.


To count today&#x27;s unseen messages smaller than 6000 octets from the inbox mailbox do
``
q = imapdb.INBOX.seen == False
q &amp;= imapdb.INBOX.created == datetime.date.today()
q &amp;= imapdb.INBOX.size &lt; 6000
unread = imapdb(q).count()
``:code


You can fetch the previous query messages with
``
rows = imapdb(q).select()
``:code


Usual query operators are implemented, including belongs

mymessage = imapdb.INBOX[&lt;id&gt;]
Note that using the message&#x27;s id as reference is not recommended, because sequence numbers can change with mailbox mantainance operations as message deletions. If you still want to record references to messages (i.e. in another database&#x27;s record field), the solution is to use the uid field as reference whenever supported, and retrieve each message with the recorded value.

Finally, add something like the following to show the message content in a view

``
{{=P(T(&quot;Message from&quot;), &quot; &quot;, mymessage.sender)}}
{{=P(T(&quot;Received on&quot;), &quot; &quot;, mymessage.created)}}
{{=H5(mymessage.subject)}}
{{for text in mymessage.content:}}
  {{=DIV(text)}}
  {{=TR()}}
{{pass}}
``:code

As expected, we can take advantage of the ``SQLTABLE`` helper to build message lists in views

``
{{=SQLTABLE(myset.select(), linkto=URL(...))}}
``:code

And of course, it&#x27;s possible to feed a form helper with the appropiate sequence id value

``
{{=SQLFORM(imapdb.INBOX, &lt;message id&gt;, fields=[...])}}
``:code

The current adapter supported fields available are the following:

---------------------------------------
**Field** | **Type** | **Description**
=======================================
uid | string |
answered | boolean | Flag
created | date |
content | list:string | A list of text or html parts
to | string |
cc | string |
bcc | string |
size | integer | the amount of octets of the message*
deleted | boolean | Flag
draft | boolean | Flag
flagged | boolean | Flag
sender | string |
recent | boolean | Flag
seen | boolean  | Flag
subject | string|
mime | string | The mime header declaration
email | string | The complete RFC822 message**
attachments | list:string | Each non text decoded part as string
================================================================
</pre></div>
</div>
<hr />

<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/e8428580c4f1c39b457a9b9614f3ccd14f6b3fb5">e842858</a><ul><li>Date : 2012-12-18</li><li>fixed Mail.Attachment-&gt;mail.Attachment, thanks Nick</li></ul></li></ul>
<div class="row-fluid" id="com_e8428580c4f1c39b457a9b9614f3ccd14f6b3fb5">
    <div class="span6"><pre style="background-color: #DFF0D8;">``
mail.send(&#x27;you@example.com&#x27;,
  &#x27;Message subject&#x27;,
  &#x27;&lt;html&gt;&lt;img src=&quot;cid:photo&quot; /&gt;&lt;/html&gt;&#x27;,
  attachments = mail.Attachment(&#x27;/path/to/photo.jpg&#x27;, content_id=&#x27;photo&#x27;))
``:code

#### Multiple attachments

``
mail.send(&#x27;you@example.com&#x27;,
  &#x27;Message subject&#x27;,
  &#x27;Message body&#x27;,
  attachments = [mail.Attachment(&#x27;/path/to/fist.file&#x27;),
                 mail.Attachment(&#x27;/path/to/second.file&#x27;)])
``:code
</pre></div>
    <div class="span6"><pre style="background-color: #F2DEDE;">``
mail.send(&#x27;you@example.com&#x27;,
  &#x27;Message subject&#x27;,
  &#x27;&lt;html&gt;&lt;img src=&quot;cid:photo&quot; /&gt;&lt;/html&gt;&#x27;,
  attachments = Mail.Attachment(&#x27;/path/to/photo.jpg&#x27;, content_id=&#x27;photo&#x27;))
``:code

#### Multiple attachments

``
mail.send(&#x27;you@example.com&#x27;,
  &#x27;Message subject&#x27;,
  &#x27;Message body&#x27;,
  attachments = [Mail.Attachment(&#x27;/path/to/fist.file&#x27;),
                 Mail.Attachment(&#x27;/path/to/second.file&#x27;)])
``:code
</pre></div>
</div>
<hr />

<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/097d699dc16179206ccb7e4aee863d6523cd471c">097d699</a><ul><li>Date : 2012-12-27</li><li>fixed typo, thanks Andrew</li></ul></li></ul>
<div class="row-fluid" id="com_097d699dc16179206ccb7e4aee863d6523cd471c">
    <div class="span6"><pre style="background-color: #DFF0D8;">## Emails and SMS

``Mail``:inxx

### Setting up email

Web2py provides the ``gluon.tools.Mail`` class to make it easy to send emails using web2py. One can define a mailer with
``
from gluon.tools import Mail
mail = Mail()
mail.settings.server = &#x27;smtp.example.com:25&#x27;
mail.settings.sender = &#x27;you@example.com&#x27;
mail.settings.login = &#x27;username:password&#x27;
``:code

Note, if your application uses ``Auth`` (discussed in the next chapter), the ``auth`` object will include its own mailer in ``auth.settings.mailer``, so you can use that instead as follows:
``
mail = auth.settings.mailer
mail.settings.server = &#x27;smtp.example.com:25&#x27;
mail.settings.sender = &#x27;you@example.com&#x27;
mail.settings.login = &#x27;username:password&#x27;
``:code

You need to replace the mail.settings with the proper parameters for your SMTP server. Set ``mail.settings.login = None`` if the SMTP server does not require authentication.

``email logging``:inxx

--------
For debugging purposes you can set
``
mail.settings.server = &#x27;logging&#x27;
``:code
and emails will not be sent but logged to the console instead.
-------

#### Configuring email for Google App Engine
``email from GAE``:inxx
For sending emails from Google App Engine account:

``
mail.settings.server = &#x27;gae&#x27;
``:code

At the time of writing web2py does not support attachments and encrypted emails on Google App Engine. Notice cron and scheduler do not work on GAE.

#### x509 and PGP Encryption
``PGP``:inxx ``x509``:inxx

It is possible to send x509 (SMIME) encrypted emails using the following settings:
``
mail.settings.cipher_type = &#x27;x509&#x27;
mail.settings.sign = True
mail.settings.sign_passphrase = &#x27;your passphrase&#x27;
mail.settings.encrypt = True
mail.settings.x509_sign_keyfile = &#x27;filename.key&#x27;
mail.settings.x509_sign_certfile = &#x27;filename.cert&#x27;
mail.settings.x509_crypt_certfiles = &#x27;filename.cert&#x27;
``:code

It is possible to send PGP encrypted emails using the following settings:
``
from gpgme import pgp
mail.settings.cipher_type = &#x27;gpg&#x27;
mail.settings.sign = True
mail.settings.sign_passphrase = &#x27;your passphrase&#x27;
mail.settings.encrypt = True
``:code

The latter requires the python-pyme package.

### Sending emails
``mail.send``:inxx ``email html``:inxx ``email attachments``:inxx

Once ``mail`` is defined, it can be used to send email via:
``
mail.send(to=[&#x27;somebody@example.com&#x27;],
          subject=&#x27;hello&#x27;,
          # If reply_to is omitted, then mail.settings.sender is used
          reply_to=&#x27;us@example.com&#x27;,
          message=&#x27;hi there&#x27;)
``:code

Mail returns ``True`` if it succeeds in sending the email and ``False`` otherwise.  A complete argument list for ``mail.send()`` is as follows:

``
send(self, to, subject=&#x27;None&#x27;, message=&#x27;None&#x27;, attachments=1,
     cc=1, bcc=1, reply_to=1, encoding=&#x27;utf-8&#x27;,headers={},
     sender=None)
``:code

Note, ``to``, ``cc``, and ``bcc`` each take a list of email addresses.

``headers`` is dictionary of headers to refine the headers just before sending the email. For example:

``
headers = {&#x27;Return-Path&#x27; : &#x27;bounces@example.org&#x27;}
``:code

``sender`` defaults to ``None`` and in this case the sender will be set to ``mail.settings.sender``.

Following are some additional examples demonstrating the use of ``mail.send()``.

#### Simple text email

``
mail.send(&#x27;you@example.com&#x27;,
  &#x27;Message subject&#x27;,
  &#x27;Plain text body of the message&#x27;)
``:code

#### HTML emails

``
mail.send(&#x27;you@example.com&#x27;,
  &#x27;Message subject&#x27;,
  &#x27;&lt;html&gt;html body&lt;/html&gt;&#x27;)
``:code

If the email body starts with ``&lt;html&gt;`` and ends with ``&lt;/html&gt;``, it will be sent as a HTML email.

#### Combining text and HTML emails

The email message can be a tuple (text, html):

``
mail.send(&#x27;you@example.com&#x27;,
  &#x27;Message subject&#x27;,
  (&#x27;Plain text body&#x27;, &#x27;&lt;html&gt;html body&lt;/html&gt;&#x27;))
``:code

#### ``cc`` and ``bcc`` emails

``
mail.send(&#x27;you@example.com&#x27;,
  &#x27;Message subject&#x27;,
  &#x27;Plain text body&#x27;,
  cc=[&#x27;other1@example.com&#x27;, &#x27;other2@example.com&#x27;],
  bcc=[&#x27;other3@example.com&#x27;, &#x27;other4@example.com&#x27;])
``:code

#### Attachments

``
mail.send(&#x27;you@example.com&#x27;,
  &#x27;Message subject&#x27;,
  &#x27;&lt;html&gt;&lt;img src=&quot;cid:photo&quot; /&gt;&lt;/html&gt;&#x27;,
  attachments = mail.Attachment(&#x27;/path/to/photo.jpg&#x27;, content_id=&#x27;photo&#x27;))
``:code

#### Multiple attachments

``
mail.send(&#x27;you@example.com&#x27;,
  &#x27;Message subject&#x27;,
  &#x27;Message body&#x27;,
  attachments = [mail.Attachment(&#x27;/path/to/fist.file&#x27;),
                 mail.Attachment(&#x27;/path/to/second.file&#x27;)])
``:code

### Sending SMS messages
``SMS``:inxx
Sending SMS messages from a web2py application requires a third party service that can relay the messages to the receiver. Usually this is not a free service, but it differs from country to country. We have tried a few of these services with little success. Phone companies block emails originating from these services since they are eventually used as a source of spam.

A better way is to use the phone companies themselves to relay the SMS. Each phone company has an email address uniquely associated with every cell-phone number, so SMS messages can be sent as emails to the phone number.

web2py comes with a module to help in this process:
``
from gluon.contrib.sms_utils import SMSCODES, sms_email
email = sms_email(&#x27;1 (111) 111-1111&#x27;,&#x27;T-Mobile USA (tmail)&#x27;)
mail.sent(to=email, subject=&#x27;test&#x27;, message=&#x27;test&#x27;)
``:code

SMSCODES is a dictionary that maps names of major phone companies to the email address postfix. The ``sms_email`` function takes a phone number (as a string) and the name of a phone company and returns the email address of the phone.

### Using the template system to generate messages
``emails``:inxx

It is possible to use the template system to generate emails. For example, consider the database table
``
db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;))
``:code

where you want to send to every person in the database the following message,
stored in a view file &quot;message.html&quot;:
``
Dear {{=person.name}},
You have won the second prize, a set of steak knives.
``:code

You can achieve this in the following way
``
for person in db(db.person).select():
    context = dict(person=person)
    message = response.render(&#x27;message.html&#x27;, context)
    mail.send(to=[&#x27;who@example.com&#x27;],
              subject=&#x27;None&#x27;,
              message=message)
``:code

Most of the work is done in the statement
``
response.render(&#x27;message.html&#x27;, context)
``:code

It renders the view &quot;message.html&quot; with the variables defined in the dictionary &quot;context&quot;, and it returns a string with the rendered email text. The context is a dictionary that contains variables that will be visible to the template file.

If the message starts with ``&lt;html&gt;`` and ends with ``&lt;/html&gt;``, the email will be an HTML email.

Note, if you want to include a link back to your website in an HTML email, you can use the ``URL`` function. However, by default, the ``URL`` function generates a relative URL, which will not work from an email. To generate an absolute URL, you need to specify the ``scheme`` and ``host`` arguments to the URL function. For example:
``
&lt;a href=&quot;{{=URL(..., scheme=True, host=True)}}&quot;&gt;Click here&lt;/a&gt;
``:code

or

``
&lt;a href=&quot;{{=URL(..., scheme=&#x27;http&#x27;, host=&#x27;www.site.com&#x27;)}}&quot;&gt;Click here&lt;/a&gt;
``:code

The same mechanism that is used to generate email text can also be used to generate SMS messages or any other type of message based on a template.

### Sending messages using a background task

The operation of sending an email message can take up to several seconds because of the need to log into and communicate with a potentially remote SMTP server. To keep the user from having to wait for the send operation to complete, it is sometimes desirable to queue the email to be sent at a later time via a background task. As described in Chapter 4, this can be done by setting up a homemade task queue or using the web2py scheduler. Here we provide an example using a homemade task queue.

First, in a model file within our application, we set up a database model to store our email queue:
``
db.define_table(&#x27;queue&#x27;,
    Field(&#x27;status&#x27;),
    Field(&#x27;email&#x27;),
    Field(&#x27;subject&#x27;),
    Field(&#x27;message&#x27;))
``:code

From a controller, we can then enqueue messages to be sent by:
``
db.queue.insert(status=&#x27;pending&#x27;,
                email=&#x27;you@example.com&#x27;,
                subject=&#x27;test&#x27;,
                message=&#x27;test&#x27;)
``:code

Next, we need a background processing script that reads the queue and sends the emails:
``
## in file /app/private/mail_queue.py
import time
while True:
    rows = db(db.queue.status==&#x27;pending&#x27;).select()
    for row in rows:
        if mail.send(to=row.email,
            subject=row.subject,
            message=row.message):
            row.update_record(status=&#x27;sent&#x27;)
        else:
            row.update_record(status=&#x27;failed&#x27;)
        db.commit()
    time.sleep(60) # check every minute
``:code

Finally, as described in Chapter 4, we need to run the mail_queue.py script as if it were inside a controller in our app:
``
python web2py.py -S app -M -N -R applications/app/private/mail_queue.py
``:code

where ``-S app`` tells web2py to run &quot;mail_queue.py&quot; as &quot;app&quot;, ``-M`` tells web2py to execute models, and ``-N`` tells web2py not to run cron.

Here we assume that the ``mail`` object referenced in &quot;mail_queue.py&quot; is defined in a model file in our app and is therefore available in the &quot;mail_queue.py&quot; script because of the ``-M`` option. Also notice that it is important to commit any change as soon as possible in order not to lock the database to other concurrent processes.

As noted in Chapter 4, this type of background process should not be executed via cron (except perhaps for cron @reboot) because you need to be sure that no more than one instance is running at the same time.

Note, one drawback to sending email via a background process is that it makes it difficult to provide feedback to the user in case the email fails. If email is sent directly from the controller action, you can catch any errors and immediately return an error message to the user. With a background process, however, the email is sent asynchronously, after the controller action has already returned its response, so it becomes more complex to notify the user of a failure.


### Reading and managing email boxes (Experimental)

The ``IMAP`` adapter is intended as an interface with email IMAP servers to perform simple queries in the web2py ``DAL`` query syntax, so email read, search and other related IMAP mail services (as those implemented by brands like Google(r), and Yahoo(r) can be managed from web2py applications.

It creates its table and field names &quot;statically&quot;, meaning that the developer should leave the table and field definitions to the DAL instance by calling the adapter ``.define_tables()`` method. The tables are defined with the IMAP server mailbox list information.


#### Connection

For a single mail account, this is the code recommended to start imap support at the app&#x27;s model

``
# Replace user, password, server and port in the connection string
# Set port as 993 for ssl support
imapdb = DAL(&quot;imap://user:password@server:port&quot;, pool_size=1)
imapdb.define_tables()
``:code

Note that ``&lt;imapdb&gt;.define_tables()`` returns a dictionary of strings mapping dal tablenames to the server mailbox names with the structure ``{&lt;tablename&gt;: &lt;server mailbox name&gt;, ...}``, so you can get the actual mailbox name in the IMAP server.


To handle the different native mailbox names for the user interface,  the following attributes give access to the adapter auto mailbox mapped names (which native mailbox has what table name and vice versa):

-------------------------------------
**Attribute** | **Type** | **Format**
imapdb.mailboxes | dict | ``{&lt;tablename&gt;: &lt;server native name&gt;, ...}``
imapdb.&lt;table&gt;.mailbox | string | ``&quot;server native name&quot;``
-------------------------------------

The first can be useful to retrieve imap query sets by the native email service mailbox
``
# mailbox is a string containing the actual mailbox name
tablenames = dict([(v,k) for k,v in imapdb.mailboxes.items()])
myset = imapdb(imapdb[tablenames[mailbox]])
``:code

#### Fetching mail and updating flags

Here&#x27;s a list of imap commands you could use in the controller. For the examples, it&#x27;s assumed that your imap service has a mailbox named ``INBOX``, which is the case for Gmail(r) accounts.


To count today&#x27;s unseen messages smaller than 6000 octets from the inbox mailbox do
``
q = imapdb.INBOX.seen == False
q &amp;= imapdb.INBOX.created == datetime.date.today()
q &amp;= imapdb.INBOX.size &lt; 6000
unread = imapdb(q).count()
``:code


You can fetch the previous query messages with
``
rows = imapdb(q).select()
``:code


Usual query operators are implemented, including belongs

``
messages = imapdb(imapdb.INBOX.uid.belongs(&lt;uid sequence&gt;)).select()
``:code

**Note**: It&#x27;s strongly adviced that you keep the query results below a given data size threshold to avoid jamming the server with large select commands. As of now, the messages are retrieved entirely by the adapter before any filter by field can be applied.

It is possible to filter query select results with limitby and sequences of mailbox fields
``
# Replace the arguments with actual values
myset.select(&lt;fields sequence&gt;, limitby=(&lt;int&gt;, &lt;int&gt;))
``:code

Say you want to have an app action show a mailbox message. First we retrieve the message (If your IMAP service supports it, fetch messages by ``uid`` field to avoid using old sequence references).

``
mymessage = imapdb(imapdb.INBOX.uid == &lt;uid&gt;).select().first()
``:code

Otherwise, you can use the message&#x27;s ``id``.

``
mymessage = imapdb.INBOX[&lt;id&gt;]
``:code

Note that using the message&#x27;s id as reference is not recommended, because sequence numbers can change with mailbox mantainance operations as message deletions. If you still want to record references to messages (i.e. in another database&#x27;s record field), the solution is to use the uid field as reference whenever supported, and retrieve each message with the recorded value.

Finally, add something like the following to show the message content in a view

``
{{=P(T(&quot;Message from&quot;), &quot; &quot;, mymessage.sender)}}
{{=P(T(&quot;Received on&quot;), &quot; &quot;, mymessage.created)}}
{{=H5(mymessage.subject)}}
{{for text in mymessage.content:}}
  {{=DIV(text)}}
  {{=TR()}}
{{pass}}
``:code

As expected, we can take advantage of the ``SQLTABLE`` helper to build message lists in views

``
{{=SQLTABLE(myset.select(), linkto=URL(...))}}
``:code

And of course, it&#x27;s possible to feed a form helper with the appropiate sequence id value

``
{{=SQLFORM(imapdb.INBOX, &lt;message id&gt;, fields=[...])}}
``:code

The current adapter supported fields available are the following:

---------------------------------------
**Field** | **Type** | **Description**
uid | string | ````
answered | boolean | Flag
created | date | ````
content | list:string | A list of text or html parts
to | string | ````
cc | string | ````
bcc | string | ````
size | integer | the amount of octets of the message*
deleted | boolean | Flag
draft | boolean | Flag
flagged | boolean | Flag
sender | string | ````
recent | boolean | Flag
seen | boolean  | Flag
subject | string| ````
mime | string | The mime header declaration
email | string | The complete RFC822 message**
attachments | list:string | Each non text decoded part as string
---------------------------------------------------

*At the application side it is measured as the length of the RFC822
message string

**WARNING**: As row id&#x27;s are mapped to email sequence numbers, make sure your imap client web2py app does not delete messages
during select or update actions, to prevent updating or deleting different messages.


Standard ``CRUD`` database operations are not supported. There&#x27;s no way of defining custom fields or tables and make inserts with different data types because updating mailboxes with IMAP services is usually reduced to posting flag updates to the server. Still, it&#x27;s possible to access those flag commands trough DAL IMAP inteface

To mark last query messages as seen
``
seen = imapdb(q).update(seen=True)
``:code


Here we delete messages in the imap database that have mails from mr. Gumby
``
deleted = 0
for tablename in imapdb.tables():
    deleted += imapdb(imapdb[tablename].sender.contains(&quot;gumby&quot;)).delete()
``:code


It is possible also to mark messages for deletion instead of ereasing them
directly with
``
myset.update(deleted=True)
``:code

``IMAP``:inxx
</pre></div>
    <div class="span6"><pre style="background-color: #F2DEDE;">## Emails and SMS

``Mail``:inxx

### Setting up email

Web2py provides the ``gluon.tools.Mail`` class to make it easy to send emails using web2py. One can define a mailer with
``
from gluon.tools import Mail
mail = Mail()
mail.settings.server = &#x27;smtp.example.com:25&#x27;
mail.settings.sender = &#x27;you@example.com&#x27;
mail.settings.login = &#x27;username:password&#x27;
``:code

Note, if your application uses ``Auth`` (discussed in the next chapter), the ``auth`` object will include its own mailer in ``auth.settings.mailer``, so you can use that instead as follows:
``
mail = auth.settings.mailer
mail.settings.server = &#x27;smtp.example.com:25&#x27;
mail.settings.sender = &#x27;you@example.com&#x27;
mail.settings.login = &#x27;username:password&#x27;
``:code

You need to replace the mail.settings with the proper parameters for your SMTP server. Set ``mail.settings.login = None`` if the SMTP server does not require authentication.

``email logging``:inxx

For debugging purposes you can set
``
mail.settings.server = &#x27;logging&#x27;
``:code
and emails will not be sent but logged to the console instead.

#### Configuring email for Google App Engine
``email from GAE``:inxx
For sending emails from Google App Engine account:

``
mail.settings.server = &#x27;gae&#x27;
``:code

At the time of writing web2py does not support attachments and encrypted emails on Google App Engine. Notice cron and scheduler do not work on GAE.

#### x509 and PGP Encryption
``PGP``:inxx ``x509``:inxx

It is possible to send x509 (SMIME) encrypted emails using the following settings:
``
mail.settings.cipher_type = &#x27;x509&#x27;
mail.settings.sign = True
mail.settings.sign_passphrase = &#x27;your passphrase&#x27;
mail.settings.encrypt = True
mail.settings.x509_sign_keyfile = &#x27;filename.key&#x27;
mail.settings.x509_sign_certfile = &#x27;filename.cert&#x27;
mail.settings.x509_crypt_certfiles = &#x27;filename.cert&#x27;
``:code

It is possible to send PGP encrypted emails using the following settings:
``
from gpgme import pgp
mail.settings.cipher_type = &#x27;gpg&#x27;
mail.settings.sign = True
mail.settings.sign_passphrase = &#x27;your passphrase&#x27;
mail.settings.encrypt = True
``:code

The latter requires the python-pyme package.

### Sending emails
``mail.send``:inxx ``email html``:inxx ``email attachments``:inxx

Once ``mail`` is defined, it can be used to send email via:
``
mail.send(to=[&#x27;somebody@example.com&#x27;],
          subject=&#x27;hello&#x27;,
          # If reply_to is omitted, then mail.settings.sender is used
          reply_to=&#x27;us@example.com&#x27;,
          message=&#x27;hi there&#x27;)
``:code

Mail returns ``True`` if it succeeds in sending the email and ``False`` otherwise.  A complete argument list for ``mail.send()`` is as follows:

``
send(self, to, subject=&#x27;None&#x27;, message=&#x27;None&#x27;, attachments=1,
     cc=1, bcc=1, reply_to=1, encoding=&#x27;utf-8&#x27;,headers={},
     sender=None)
``:code

Note, ``to``, ``cc``, and ``bcc`` each take a list of email addresses.

``headers`` is dictionary of headers to refine the headers just before sending the email. For example:

``
headers = {&#x27;Return-Path&#x27; : &#x27;bounces@example.org&#x27;}
``:code

``sender`` defaults to ``None`` and in this case the sender will be set to ``mail.settings.sender``.

Following are some additional examples demonstrating the use of ``mail.send()``.

#### Simple text email

``
mail.send(&#x27;you@example.com&#x27;,
  &#x27;Message subject&#x27;,
  &#x27;Plain text body of the message&#x27;)
``:code

#### HTML emails

``
mail.send(&#x27;you@example.com&#x27;,
  &#x27;Message subject&#x27;,
  &#x27;&lt;html&gt;html body&lt;/html&gt;&#x27;)
``:code

If the email body starts with ``&lt;html&gt;`` and ends with ``&lt;/html&gt;``, it will be sent as a HTML email.

#### Combining text and HTML emails

The email message can be a tuple (text, html):

``
mail.send(&#x27;you@example.com&#x27;,
  &#x27;Message subject&#x27;,
  (&#x27;Plain text body&#x27;, &#x27;&lt;html&gt;html body&lt;/html&gt;&#x27;))
``:code

#### ``cc`` and ``bcc`` emails

``
mail.send(&#x27;you@example.com&#x27;,
  &#x27;Message subject&#x27;,
  &#x27;Plain text body&#x27;,
  cc=[&#x27;other1@example.com&#x27;, &#x27;other2@example.com&#x27;],
  bcc=[&#x27;other3@example.com&#x27;, &#x27;other4@example.com&#x27;])
``:code

#### Attachments

``
mail.send(&#x27;you@example.com&#x27;,
  &#x27;Message subject&#x27;,
  &#x27;&lt;html&gt;&lt;img src=&quot;cid:photo&quot; /&gt;&lt;/html&gt;&#x27;,
  attachments = mail.Attachment(&#x27;/path/to/photo.jpg&#x27;, content_id=&#x27;photo&#x27;))
``:code

#### Multiple attachments

``
mail.send(&#x27;you@example.com&#x27;,
  &#x27;Message subject&#x27;,
  &#x27;Message body&#x27;,
  attachments = [mail.Attachment(&#x27;/path/to/fist.file&#x27;),
                 mail.Attachment(&#x27;/path/to/second.file&#x27;)])
``:code

### Sending SMS messages
``SMS``:inxx
Sending SMS messages from a web2py application requires a third party service that can relay the messages to the receiver. Usually this is not a free service, but it differs from country to country. We have tried a few of these services with little success. Phone companies block emails originating from these services since they are eventually used as a source of spam.

A better way is to use the phone companies themselves to relay the SMS. Each phone company has an email address uniquely associated with every cell-phone number, so SMS messages can be sent as emails to the phone number.

web2py comes with a module to help in this process:
``
from gluon.contrib.sms_utils import SMSCODES, sms_email
email = sms_email(&#x27;1 (111) 111-1111&#x27;,&#x27;T-Mobile USA (tmail)&#x27;)
mail.sent(to=email, subject=&#x27;test&#x27;, message=&#x27;test&#x27;)
``:code

SMSCODES is a dictionary that maps names of major phone companies to the email address postfix. The ``sms_email`` function takes a phone number (as a string) and the name of a phone company and returns the email address of the phone.

### Using the template system to generate messages
``emails``:inxx

It is possible to use the template system to generate emails. For example, consider the database table
``
db.define_table(&#x27;person&#x27;, Field(&#x27;name&#x27;))
``:code

where you want to send to every person in the database the following message,
stored in a view file &quot;message.html&quot;:
``
Dear {{=person.name}},
You have won the second prize, a set of steak knives.
``:code

You can achieve this in the following way
``
for person in db(db.person).select():
    context = dict(person=person)
    message = response.render(&#x27;message.html&#x27;, context)
    mail.send(to=[&#x27;who@example.com&#x27;],
              subject=&#x27;None&#x27;,
              message=message)
``:code

Most of the work is done in the statement
``
response.render(&#x27;message.html&#x27;, context)
``:code

It renders the view &quot;message.html&quot; with the variables defined in the dictionary &quot;context&quot;, and it returns a string with the rendered email text. The context is a dictionary that contains variables that will be visible to the template file.

If the message starts with ``&lt;html&gt;`` and ends with ``&lt;/html&gt;``, the email will be an HTML email.

Note, if you want to include a link back to your website in an HTML email, you can use the ``URL`` function. However, by default, the ``URL`` function generates a relative URL, which will not work from an email. To generate an absolute URL, you need to specify the ``scheme`` and ``host`` arguments to the URL function. For example:
``
&lt;a href=&quot;{{=URL(..., scheme=True, host=True)}}&quot;&gt;Click here&lt;/a&gt;
``:code

or

``
&lt;a href=&quot;{{=URL(..., scheme=&#x27;http&#x27;, host=&#x27;www.site.com&#x27;)}}&quot;&gt;Click here&lt;/a&gt;
``:code

The same mechanism that is used to generate email text can also be used to generate SMS messages or any other type of message based on a template.

### Sending messages using a background task

The operation of sending an email message can take up to several seconds because of the need to log into and communicate with a potentially remote SMTP server. To keep the user from having to wait for the send operation to complete, it is sometimes desirable to queue the email to be sent at a later time via a background task. As described in Chapter 4, this can be done by setting up a homemade task queue or using the web2py scheduler. Here we provide an example using a homemade task queue.

First, in a model file within our application, we set up a database model to store our email queue:
``
db.define_table(&#x27;queue&#x27;,
    Field(&#x27;status&#x27;),
    Field(&#x27;email&#x27;),
    Field(&#x27;subject&#x27;),
    Field(&#x27;message&#x27;))
``:code

From a controller, we can then enqueue messages to be sent by:
``
db.queue.insert(status=&#x27;pending&#x27;,
                email=&#x27;you@example.com&#x27;,
                subject=&#x27;test&#x27;,
                message=&#x27;test&#x27;)
``:code

Next, we need a background processing script that reads the queue and sends the emails:
``
## in file /app/private/mail_queue.py
import time
while True:
    rows = db(db.queue.status==&#x27;pending&#x27;).select()
    for row in rows:
        if mail.send(to=row.email,
            subject=row.subject,
            message=row.message):
            row.update_record(status=&#x27;sent&#x27;)
        else:
            row.update_record(status=&#x27;failed&#x27;)
        db.commit()
    time.sleep(60) # check every minute
``:code

Finally, as described in Chapter 4, we need to run the mail_queue.py script as if it were inside a controller in our app:
``
python web2py.py -S app -M -N -R applications/app/private/mail_queue.py
``:code

where ``-S app`` tells web2py to run &quot;mail_queue.py&quot; as &quot;app&quot;, ``-M`` tells web2py to execute models, and ``-N`` tells web2py not to run cron.

Here we assume that the ``mail`` object referenced in &quot;mail_queue.py&quot; is defined in a model file in our app and is therefore available in the &quot;mail_queue.py&quot; script because of the ``-M`` option. Also notice that it is important to commit any change as soon as possible in order not to lock the database to other concurrent processes.

As noted in Chapter 4, this type of background process should not be executed via cron (except perhaps for cron @reboot) because you need to be sure that no more than one instance is running at the same time.

Note, one drawback to sending email via a background process is that it makes it difficult to provide feedback to the user in case the email fails. If email is sent directly from the controller action, you can catch any errors and immediately return an error message to the user. With a background process, however, the email is sent asynchronously, after the controller action has already returned its response, so it becomes more complex to notify the user of a failure.


### Reading and managing email boxes (Experimental)

The ``IMAP`` adapter is intended as an interface with email IMAP servers to perform simple queries in the web2py ``DAL`` query syntax, so email read, search and other related IMAP mail services (as those implemented by brands like Google(r), and Yahoo(r) can be managed from web2py applications.

It creates its table and field names &quot;statically&quot;, meaning that the developer should leave the table and field definitions to the DAL instance by calling the adapter ``.define_tables()`` method. The tables are defined with the IMAP server mailbox list information.


#### Connection

For a single mail account, this is the code recommended to start imap support at the app&#x27;s model

``
# Replace user, password, server and port in the connection string
# Set port as 993 for ssl support
imapdb = DAL(&quot;imap://user:password@server:port&quot;, pool_size=1)
imapdb.define_tables()
``:code

Note that ``&lt;imapdb&gt;.define_tables()`` returns a dictionary of strings mapping dal tablenames to the server mailbox names with the structure ``{&lt;tablename&gt;: &lt;server mailbox name&gt;, ...}``, so you can get the actual mailbox name in the IMAP server.


To handle the different native mailbox names for the user interface,  the following attributes give access to the adapter auto mailbox mapped names (which native mailbox has what table name and vice versa):

**Attribute** | **Type** | **Format**
imapdb.mailboxes | dict | ``{&lt;tablename&gt;: &lt;server native name&gt;, ...}``
imapdb.&lt;table&gt;.mailbox | string | ``&quot;server native name&quot;``

The first can be useful to retrieve imap query sets by the native email service mailbox
``
# mailbox is a string containing the actual mailbox name
tablenames = dict([(v,k) for k,v in imapdb.mailboxes.items()])
myset = imapdb(imapdb[tablenames[mailbox]])
``:code

#### Fetching mail and updating flags

Here&#x27;s a list of imap commands you could use in the controller. For the examples, it&#x27;s assumed that your imap service has a mailbox named ``INBOX``, which is the case for Gmail(r) accounts.


To count today&#x27;s unseen messages smaller than 6000 octets from the inbox mailbox do
``
q = imapdb.INBOX.seen == False
q &amp;= imapdb.INBOX.created == datetime.date.today()
q &amp;= imapdb.INBOX.size &lt; 6000
unread = imapdb(q).count()
``:code


You can fetch the previous query messages with
``
rows = imapdb(q).select()
``:code


Usual query operators are implemented, including belongs

``
messages = imapdb(imapdb.INBOX.uid.belongs(&lt;uid sequence&gt;)).select()
``:code

**Note**: It&#x27;s strongly adviced that you keep the query results below a given data size threshold to avoid jamming the server with large select commands. As of now, the messages are retrieved entirely by the adapter before any filter by field can be applied.

It is possible to filter query select results with limitby and sequences of mailbox fields
``
# Replace the arguments with actual values
myset.select(&lt;fields sequence&gt;, limitby=(&lt;int&gt;, &lt;int&gt;))
``:code

Say you want to have an app action show a mailbox message. First we retrieve the message (If your IMAP service supports it, fetch messages by ``uid`` field to avoid using old sequence references).

``
mymessage = imapdb(imapdb.INBOX.uid == &lt;uid&gt;).select().first()
``:code

Otherwise, you can use the message&#x27;s ``id``.

``
mymessage = imapdb.INBOX[&lt;id&gt;]
``:code

Note that using the message&#x27;s id as reference is not recommended, because sequence numbers can change with mailbox mantainance operations as message deletions. If you still want to record references to messages (i.e. in another database&#x27;s record field), the solution is to use the uid field as reference whenever supported, and retrieve each message with the recorded value.

Finally, add something like the following to show the message content in a view

``
{{=P(T(&quot;Message from&quot;), &quot; &quot;, mymessage.sender)}}
{{=P(T(&quot;Received on&quot;), &quot; &quot;, mymessage.created)}}
{{=H5(mymessage.subject)}}
{{for text in mymessage.content:}}
  {{=DIV(text)}}
  {{=TR()}}
{{pass}}
``:code

As expected, we can take advantage of the ``SQLTABLE`` helper to build message lists in views

``
{{=SQLTABLE(myset.select(), linkto=URL(...))}}
``:code

And of course, it&#x27;s possible to feed a form helper with the appropiate sequence id value

``
{{=SQLFORM(imapdb.INBOX, &lt;message id&gt;, fields=[...])}}
``:code

The current adapter supported fields available are the following:

**Field** | **Type** | **Description**
uid | string | ````
answered | boolean | Flag
created | date | ````
content | list:string | A list of text or html parts
to | string | ````
cc | string | ````
bcc | string | ````
size | integer | the amount of octets of the message*
deleted | boolean | Flag
draft | boolean | Flag
flagged | boolean | Flag
sender | string | ````
recent | boolean | Flag
seen | boolean  | Flag
subject | string| ````
mime | string | The mime header declaration
email | string | The complete RFC822 message**
attachments | list:string | Each non text decoded part as string

*At the application side it is measured as the length of the RFC822
message string

**WARNING**: As row id&#x27;s are mapped to email sequence numbers, make sure your imap client web2py app does not delete messages
during select or update actions, to prevent updating or deleting different messages.


Standard ``CRUD`` database operations are not supported. There&#x27;s no way of defining custom fields or tables and make inserts with different data types because updating mailboxes with IMAP services is usually reduced to posting flag updates to the server. Still, it&#x27;s possible to access those flag commands trough DAL IMAP inteface

To mark last query messages as seen
``
seen = imapdb(q).update(seen=True)
``:code


Here we delete messages in the imap database that have mails from mr. Gumby
``
deleted = 0
for tablename in imapdb.tables():
    deleted += imapdb(imapdb[tablename].sender.contains(&quot;gumby&quot;)).delete()
``:code


It is possible also to mark messages for deletion instead of ereasing them
directly with
``
myset.update(deleted=True)
``:code

``IMAP``:inxx
</pre></div>
</div>
<hr />

<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/bb5fb21852c40f3b628510ef0be7a07d53cf4f9d">bb5fb21</a><ul><li>Date : 2012-09-16</li><li>Update sources/29-web2py-english/08.markmin</li></ul></li></ul>
<div class="row-fluid" id="com_bb5fb21852c40f3b628510ef0be7a07d53cf4f9d">
    <div class="span6"><pre style="background-color: #DFF0D8;">The current adapter supported fields available are the following:
</pre></div>
    <div class="span6"><pre style="background-color: #F2DEDE;">The current adapter supported fields available are the as follows:
</pre></div>
</div>
<hr />

<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/885e6c33d6165e8cccf89b33130de7a03534b119">885e6c3</a><ul><li>Date : 2012-09-16</li><li>Update sources/29-web2py-english/08.markmin</li></ul></li></ul>
<div class="row-fluid" id="com_885e6c33d6165e8cccf89b33130de7a03534b119">
    <div class="span6"><pre style="background-color: #DFF0D8;">### Reading and managing email boxes (Experimental)

The ``IMAP`` adapter is intended as an interface with email IMAP servers to perform simple queries in the web2py ``DAL`` query syntax, so email read, search and other related IMAP mail services (as those implemented by brands like Google(r), and Yahoo(r) can be managed from web2py applications.

It creates its table and field names &quot;statically&quot;, meaning that the developer should leave the table and field definitions to the DAL instance by calling the adapter ``.define_tables()`` method. The tables are defined with the IMAP server mailbox list information.


#### Connection

For a single mail account, this is the code recommended to start imap support at the app&#x27;s model

``
# Replace user, password, server and port in the connection string
# Set port as 993 for ssl support
imapdb = DAL(&quot;imap://user:password@server:port&quot;, pool_size=1)
imapdb.define_tables()
``:code

Note that ``&lt;imapdb&gt;.define_tables()`` returns a dictionary of strings mapping dal tablenames to the server mailbox names with the structure ``{&lt;tablename&gt;: &lt;server mailbox name&gt;, ...}``, so you can get the actual mailbox name in the IMAP server.


To handle the different native mailbox names for the user interface,  the following attributes give access to the adapter auto mailbox mapped names (which native mailbox has what table name and vice versa):

-------------------------------------------------------
**Attribute** | **Type** | **Format**
=======================================================================
imapdb.mailboxes | dict | {&lt;tablename&gt;: &lt;server native name&gt;, ...}
imapdb.mailbox_names | dict | {&lt;server native name&gt;: &lt;tablename&gt;, ...}
=======================================================================
-------------------------------------------------------

You can fetch the previous query messages with
rows = imapdb(q).select()
``:code


Usual query operators are implemented, including belongs

``
messages = imapdb(imapdb.INBOX.uid.belongs(&lt;uid sequence&gt;)).select()
``:code

**Note**: It&#x27;s strongly adviced that you keep the query results below a given data size threshold to avoid jamming the server with large select commands. As of now, the messages are retrieved entirely by the adapter before any filter by field can be applied.

It is possible to filter query select results with limitby and sequences of mailbox fields
``
# Replace the arguments with actual values
myset.select(&lt;fields sequence&gt;, limitby=(&lt;int&gt;, &lt;int&gt;))
``:code

Say you want to have an app action show a mailbox message. First we retrieve the message (If your IMAP service supports it, fetch messages by ``uid`` field to avoid using old sequence references).

``
mymessage = imapdb(imapdb.INBOX.uid == &lt;uid&gt;).select().first()
``:code

Otherwise, you can use the message&#x27;s ``id``.

``
mymessage = imapdb.INBOX[&lt;id&gt;]
``:code

Note that using the message&#x27;s id as reference is not recommended, because sequence numbers can change with mailbox mantainance operations as message deletions. If you still want to record references to messages (i.e. in another database&#x27;s record field), the solution is to use the uid field as reference whenever supported, and retrieve each message with the recorded value.

Finally, add something like the following to show the message content in a view

``
{{=P(T(&quot;Message from&quot;), &quot; &quot;, mymessage.sender)}}
{{=P(T(&quot;Received on&quot;), &quot; &quot;, mymessage.created)}}
{{=H5(mymessage.subject)}}
{{for text in mymessage.content:}}
  {{=DIV(text)}}
  {{=TR()}}
{{pass}}
``:code

As expected, we can take advantage of the ``SQLTABLE`` helper to build message lists in views

``
{{=SQLTABLE(myset.select(), linkto=URL(...))}}
``:code

And of course, it&#x27;s possible to feed a form helper with the appropiate sequence id value

``
{{=SQLFORM(imapdb.INBOX, &lt;message id&gt;, fields=[...])}}
``:code

The current adapter supported fields available are the as follows:

---------------------------------------
**Field** | **Type** | **Description**
=======================================
uid | string |
answered | boolean | Flag
created | date |
content | list:string | A list of text or html parts
to | string |
cc | string |
bcc | string |
size | integer | the amount of octets of the message*
deleted | boolean | Flag
draft | boolean | Flag
flagged | boolean | Flag
sender | string |
recent | boolean | Flag
seen | boolean  | Flag
subject | string|
mime | string | The mime header declaration
email | string | The complete RFC822 message**
attachments | list:string | Each non text decoded part as string
================================================================
----------------------------------------------------------------

*At the application side it is measured as the length of the RFC822
message string

**WARNING**: As row id&#x27;s are mapped to email sequence numbers, make sure your imap client web2py app does not delete messages
during select or update actions, to prevent updating or deleting different messages.


Standard ``CRUD`` database operations are not supported. There&#x27;s no way of defining custom fields or tables and make inserts with different data types because updating mailboxes with IMAP services is usually reduced to posting flag updates to the server. Still, it&#x27;s possible to access those flag commands trough DAL IMAP inteface
</pre></div>
    <div class="span6"><pre style="background-color: #F2DEDE;">### Reading email boxes (Experimental)

The ``IMAP`` adapter is intended as an interface with email IMAP servers to perform simple queries in the web2py ``DAL`` query syntax, so email read, search and other related IMAP mail services (as those implemented by brands like Google(r), and Yahoo(r) can be managed from web2py applications.

It creates its table and field names &quot;statically&quot;, meaning that the developer should leave the table and field definitions to the DAL instance by calling the adapter ``.define_tables()`` method. The tables are defined with the IMAP server mailbox list information.


#### Connection

For a single mail account, this is the code recommended to start imap support at the app&#x27;s model

``
# Replace user, password, server and port in the connection string
# Set port as 993 for ssl support
imapdb = DAL(&quot;imap://user:password@server:port&quot;, pool_size=1)
imapdb.define_tables()
``:code

Note that ``&lt;imapdb&gt;.define_tables()`` returns a dictionary of strings mapping dal tablenames to the server mailbox names with the structure ``{&lt;tablename&gt;: &lt;server mailbox name&gt;, ...}``, so you can get the actual mailbox name in the IMAP server.


To handle the different native mailbox names for the user interface,  the following attributes give access to the adapter auto mailbox mapped names (which native mailbox has what table name and vice versa):

-------------------------------------------------------
**Attribute** | **Type** | **Format**
=======================================================================
imapdb.mailboxes | dict | {&lt;tablename&gt;: &lt;server native name&gt;, ...}
imapdb.mailbox_names | dict | {&lt;server native name&gt;: &lt;tablename&gt;, ...}
=======================================================================
-------------------------------------------------------

You can fetch the previous query messages with
rows = imapdb(q).select()
``:code


Usual query operators are implemented, including belongs

``
messages = imapdb(imapdb.INBOX.uid.belongs(&lt;uid sequence&gt;)).select()
``:code

**Note**: It&#x27;s strongly adviced that you keep the query results below a given data size threshold to avoid jamming the server with large select commands. As of now, the messages are retrieved entirely by the adapter before any filter by field can be applied.

It is possible to filter query select results with limitby and sequences of mailbox fields
``
# Replace the arguments with actual values
myset.select(&lt;fields sequence&gt;, limitby=(&lt;int&gt;, &lt;int&gt;))
``:code

Say you want to have an app action show a mailbox message. First we retrieve the message (If your IMAP service supports it, fetch messages by ``uid`` field to avoid using old sequence references).

``
mymessage = imapdb(imapdb.INBOX.uid == &lt;uid&gt;).select().first()
``:code

Otherwise, you can use the message&#x27;s ``id``.

``
mymessage = imapdb.INBOX[&lt;id&gt;]
``:code

Note that using the id in a reference field is not supported, because there&#x27;s no way of writing to the tables the same way as in other standard database adapters. If you still want to record references to messages in another database, the solution is to use the uid field as reference whenever supported, and retrieve each message with the recorded value.


Finally, add something like the following to show the message content in a view

``
{{=P(T(&quot;Message from&quot;), &quot; &quot;, mymessage.sender)}}
{{=P(T(&quot;Received on&quot;), &quot; &quot;, mymessage.created)}}
{{=H5(mymessage.subject)}}
{{for text in mymessage.content:}}
  {{=DIV(text)}}
  {{=TR()}}
{{pass}}
``:code

As expected, we can take advantage of the ``SQLTABLE`` helper to build message lists in views

``
{{=SQLTABLE(myset.select(), linkto=URL(...))}}
``:code

And of course, it&#x27;s possible to feed a form helper with the appropiate sequence id value

``
{{=SQLFORM(imapdb.INBOX, &lt;message id&gt;, fields=[...])}}
``:code

The current adapter supported fields available are the as follows:

---------------------------------------
**Field** | **Type** | **Description**
=======================================
uid | string |
answered | boolean | Flag
created | date |
content | list:string | A list of text or html parts
to | string |
cc | string |
bcc | string |
size | integer | the amount of octets of the message*
deleted | boolean | Flag
draft | boolean | Flag
flagged | boolean | Flag
sender | string |
recent | boolean | Flag
seen | boolean  | Flag
subject | string|
mime | string | The mime header declaration
email | string | The complete RFC822 message**
attachments | list:string | Each non text decoded part as string
================================================================
----------------------------------------------------------------

*At the application side it is measured as the length of the RFC822
message string

**WARNING**: As row id&#x27;s are mapped to email sequence numbers, make sure your imap client web2py app does not delete messages
during select or update actions, to prevent updating or deleting different messages.

Sequence numbers change whenever the mailbox is updated. To avoid this sequence numbers issues, it is recommended the use
of uid fields in query references (although the update and delete in separate actions rule still applies).

</pre></div>
</div>
<hr />

<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/ec3132989d6a44efafb59155ad3a3f06df599ec7">ec31329</a><ul><li>Date : 2012-10-05</li><li>Switch tablename and actual name in example</li></ul></li></ul>
<div class="row-fluid" id="com_ec3132989d6a44efafb59155ad3a3f06df599ec7">
    <div class="span6"><pre style="background-color: #DFF0D8;">The second can be useful to retrieve imap query sets by the native email service mailbox
``
# mailbox is a string containing the actual mailbox name
tablenames = dict([(v,k) for k,v in imapdb.mailboxes.items()])
tablename = tablenames[mailbox]
myset = imapdb(imapdb[tablename])
``:code
</pre></div>
    <div class="span6"><pre style="background-color: #F2DEDE;">The second can be useful to retrieve imap query sets by the native email service mailbox
``
# mailbox is a string containing the actual mailbox name
tablename = imapdb.mailboxes[mailbox]
myset = imapdb(imapdb[tablename])
``:code
</pre></div>
</div>
<hr />

<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/716473666742d68f3ed66204eb0682e076e90b99">7164736</a><ul><li>Date : 2012-09-16</li><li>Update sources/29-web2py-english/08.markmin</li></ul></li></ul>
<div class="row-fluid" id="com_716473666742d68f3ed66204eb0682e076e90b99">
    <div class="span6"><pre style="background-color: #DFF0D8;">``
# Replace user, password, server and port in the connection string
# Set port as 993 for ssl support
imapdb = DAL(&quot;imap://user:password@server:port&quot;)
imapdb.define_tables()
``:code

Note that ``&lt;imapdb&gt;.define_tables()`` returns a dictionary of strings mapping dal tablenames to the server mailbox names with the structure ``{&lt;tablename&gt;: &lt;server mailbox name&gt;, ...}``, so you can get the actual mailbox name in the IMAP server.


To handle the different native mailbox names for the user interface,  the following attributes give access to the adapter auto mailbox mapped names (which native mailbox has what table name and vice versa):

-------------------------------------------------------
**Attribute** | **Type** | **Format**
=======================================================================
imapdb.mailboxes | list | ``[&lt;tablename&gt;, ...]``
imapdb.mailbox_names | dict | ``{&lt;tablename&gt;: &lt;server native name&gt;, ...}``
=======================================================================
-------------------------------------------------------
</pre></div>
    <div class="span6"><pre style="background-color: #F2DEDE;">``
# Replace user, password, server and port in the connection string
# Set port as 993 for ssl support
imapdb = DAL(&quot;imap://user:password@server:port&quot;, pool_size=1)
imapdb.define_tables()
``:code

Note that ``&lt;imapdb&gt;.define_tables()`` returns a dictionary of strings mapping dal tablenames to the server mailbox names with the structure ``{&lt;tablename&gt;: &lt;server mailbox name&gt;, ...}``, so you can get the actual mailbox name in the IMAP server.


To handle the different native mailbox names for the user interface,  the following attributes give access to the adapter auto mailbox mapped names (which native mailbox has what table name and vice versa):

-------------------------------------------------------
**Attribute** | **Type** | **Format**
=======================================================================
imapdb.mailboxes | dict | {&lt;tablename&gt;: &lt;server native name&gt;, ...}
imapdb.mailbox_names | dict | {&lt;server native name&gt;: &lt;tablename&gt;, ...}
=======================================================================
-------------------------------------------------------
</pre></div>
</div>
<hr />

<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/49f38ab7ef56de1eb4ef48f68427ebf8a46b505d">49f38ab</a><ul><li>Date : 2012-12-26</li><li>more small edits</li></ul></li></ul>
<div class="row-fluid" id="com_49f38ab7ef56de1eb4ef48f68427ebf8a46b505d">
    <div class="span6"><pre style="background-color: #DFF0D8;">---------------------------------------
**Field** | **Type** | **Description**
uid | string | ````
answered | boolean | Flag
created | date | ````
content | list:string | A list of text or html parts
to | string | ````
cc | string | ````
bcc | string | ````
size | integer | the amount of octets of the message*
deleted | boolean | Flag
draft | boolean | Flag
flagged | boolean | Flag
sender | string | ````
recent | boolean | Flag
seen | boolean  | Flag
subject | string| ````
mime | string | The mime header declaration
email | string | The complete RFC822 message**
attachments | list:string | Each non text decoded part as string
---------------------------------------------------
</pre></div>
    <div class="span6"><pre style="background-color: #F2DEDE;">---------------------------------------
**Field** | **Type** | **Description**
uid | string |
answered | boolean | Flag
created | date |
content | list:string | A list of text or html parts
to | string |
cc | string |
bcc | string |
size | integer | the amount of octets of the message*
deleted | boolean | Flag
draft | boolean | Flag
flagged | boolean | Flag
sender | string |
recent | boolean | Flag
seen | boolean  | Flag
subject | string|
mime | string | The mime header declaration
email | string | The complete RFC822 message**
attachments | list:string | Each non text decoded part as string
---------------------------------------------------
</pre></div>
</div>
<hr />


        
      </div>

      <div id="push"></div>
    </div>

    <div id="footer">
      <div class="container-fluid">
          <div class="copyright pull-left">Copyright &#169; 2013</div>
          <div id="poweredBy" class="pull-right">
              Powered by
              <a href="http://www.web2py.com/">web2py</a>
          </div>
      </div>
    </div>
<script src="static/js/bootstrap.min.js"></script>
<script src="static/js/web2py_bootstrap.js"></script>
</body>
</html>
