<!DOCTYPE html>
<!-- paulirish.com/2008/conditional-stylesheets-vs-css-hacks-answer-neither/ -->
<!--[if lt IE 7]><html class="ie ie6 ie-lte9 ie-lte8 ie-lte7 no-js" lang="en-us"> <![endif]-->
<!--[if IE 7]><html class="ie ie7 ie-lte9 ie-lte8 ie-lte7 no-js" lang="en-us"> <![endif]-->
<!--[if IE 8]><html class="ie ie8 ie-lte9 ie-lte8 no-js" lang="en-us"> <![endif]-->
<!--[if IE 9]><html class="ie9 ie-lte9 no-js" lang="en-us"> <![endif]-->
<!--[if (gt IE 9)|!(IE)]><!--> <html class="no-js" lang="en-us"> <!--<![endif]-->
<head>
  <meta charset="utf-8" />
  <!-- www.phpied.com/conditional-comments-block-downloads/ -->
  <!-- Always force latest IE rendering engine
       (even in intranet) & Chrome Frame
       Remove this if you use the .htaccess -->
  <!--[if IE]>
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <![endif]-->

  <title>Diffbook</title>

  <!-- http://dev.w3.org/html5/markup/meta.name.html -->
  <meta name="application-name" content="diffbook" />

  <!-- Speaking of Google, don't forget to set your site up:
       http://google.com/webmasters -->
  <meta name="google-site-verification" content="" />

  <!--  Mobile Viewport Fix
        j.mp/mobileviewport & davidbcalhoun.com/2010/viewport-metatag
        device-width: Occupy full width of the screen in its current orientation
        initial-scale = 1.0 retains dimensions instead of zooming out if page height > device height
        user-scalable = yes allows the user to zoom in -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <link rel="shortcut icon" href="static/images/favicon.ico" type="image/x-icon">
  <link rel="apple-touch-icon" href="static/images/favicon.png">

  <!-- All JavaScript at the bottom, except for Modernizr which enables
       HTML5 elements & feature detects -->
  <script src="static/js/modernizr.custom.js"></script>

  <!-- include stylesheets -->
  

  <script type="text/javascript"><!--
    // These variables are used by the web2py_ajax_init function in web2py_ajax.js (which is loaded below).
    var w2p_ajax_confirm_message = "Are you sure you want to delete this object?";
    var w2p_ajax_date_format = "%Y-%m-%d";
    var w2p_ajax_datetime_format = "%Y-%m-%d %H:%M:%S";
    //--></script>
<meta name="keywords" content="web2py, python, framework" />

<meta name="description" content="a cool new app" />

<meta name="generator" content="Web2py Web Framework" />

<meta name="author" content="Your Name &lt;you@example.com&gt;" />
<script src="static/js/jquery.js" type="text/javascript"></script><link href="static/css/calendar.css" rel="stylesheet" type="text/css" /><script src="static/js/calendar.js" type="text/javascript"></script><script src="static/js/web2py.js" type="text/javascript"></script><link href="static/css/web2py.css" rel="stylesheet" type="text/css" /><link href="static/css/bootstrap.min.css" rel="stylesheet" type="text/css" /><link href="static/css/bootstrap-responsive.min.css" rel="stylesheet" type="text/css" /><link href="static/css/web2py_bootstrap.css" rel="stylesheet" type="text/css" />


  

  <!-- uncomment here to load jquery-ui
       <link rel="stylesheet" href="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8.16/themes/base/jquery-ui.css" type="text/css" media="all" />
       <script src="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8.16/jquery-ui.min.js" type="text/javascript"></script>
       uncomment to load jquery-ui //-->
  <noscript><link href="static/css/web2py_bootstrap_nojs.css" rel="stylesheet" type="text/css" /></noscript>
  
  <style type="text/css">

      /* Sticky footer styles
      -------------------------------------------------- */

      html,
      body {
        height: 100%;
        /* The html and body elements cannot have any padding or margin. */
      }

      /* Wrapper for page content to push down footer */
      #wrap {
        min-height: 100%;
        height: auto !important;
        height: 100%;
        /* Negative indent footer by it's height */
        margin: 0 auto -60px;
      }

      /* Set the fixed height of the footer here */
      #push,
      #footer {
        height: 60px;
      }
      #footer {
        background-color: #f5f5f5;
      }

      /* Lastly, apply responsive CSS fixes as necessary */
      @media (max-width: 767px) {
        #footer {
          margin-left: -20px;
          margin-right: -20px;
          padding-left: 20px;
          padding-right: 20px;
        }
      }



      /* Custom page CSS
      -------------------------------------------------- */
      /* Not required for template or sticky footer method. */

      .container {
        width: auto;
        max-width: 680px;
      }
      .container .credit {
        margin: 20px 0;
      }

    </style>
</head>

<body>
  
  <body>


    <!-- Part 1: Wrap all page content here -->
    <div id="wrap">

      <!-- Begin page content -->
      <div class="container-fluid">
        <div class="page-header">
          	<h1>
              Diffbook
              <small>easy? diffbook</small>
            </h1>
        </div>
        
        


<div class="pagination">
  <ul>

      <li><a href="/diffbook/0.html">Chapter 0</a></li>

      <li><a href="/diffbook/1.html">Chapter 1</a></li>

      <li><a href="/diffbook/2.html">Chapter 2</a></li>

      <li><a href="/diffbook/3.html">Chapter 3</a></li>

      <li><a href="/diffbook/4.html">Chapter 4</a></li>

      <li><a href="/diffbook/5.html">Chapter 5</a></li>

      <li><a href="/diffbook/6.html">Chapter 6</a></li>

      <li><a href="/diffbook/7.html">Chapter 7</a></li>

      <li><a href="/diffbook/8.html">Chapter 8</a></li>

      <li><a href="/diffbook/9.html">Chapter 9</a></li>

      <li><a href="/diffbook/10.html">Chapter 10</a></li>

      <li><a href="/diffbook/11.html">Chapter 11</a></li>

      <li><a href="/diffbook/12.html">Chapter 12</a></li>

  </ul>
</div>

<div class="pagination">
  <ul>

      
      <li><a href="#com_2a5d5aef457787d2963b6984fe8548b9970018b8">2a5d5ae</a></li>
      

      
      <li><a href="#com_739a4c66c06a1aa5de5f4bd07b49e2f04ec30290">739a4c6</a></li>
      

      
      <li><a href="#com_08ea49aa89ef98c086c6affa5a2a8f52caac070d">08ea49a</a></li>
      

      
      <li><a href="#com_097d699dc16179206ccb7e4aee863d6523cd471c">097d699</a></li>
      

      
      <li><a href="#com_730243d39a6e2e29d00947ac3ae5c74c188a7bf4">730243d</a></li>
      

      
      <li><a href="#com_e592e03bad4f2611839574a894a9046fed5d8358">e592e03</a></li>
      

      
      <li><a href="#com_2ac6ed57e8011e0c6032d851d303ba7c00ca6cd4">2ac6ed5</a></li>
      

      

  </ul>
</div>




<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/2a5d5aef457787d2963b6984fe8548b9970018b8">2a5d5ae</a><ul><li>Date : 2013-07-20</li><li>fixed minor typos</li></ul></li></ul>
<div class="row-fluid" id="com_2a5d5aef457787d2963b6984fe8548b9970018b8">
    <div class="span6"><div class="diff"><div class=""> - A first part that identify the location of the service, i.e. the action that exposes the service:</div><div class=""> ``</div><div class=""> http://127.0.0.1/myapp/default/api/</div><div class=""> ``</div><div class=""> - The name of the resource (``person``, ``persons``, ``person/1``, etc.)</div><div class="insert">- The communication protocol specified <span class="highlight">b</span>y the extension.</div><div class=""> </div><div class=""> Notice that we can always use the router to eliminate any unwanted prefix in the URL and for example simplify this:</div><div class=""> </div><div class=""> ``</div><div class=""> http://127.0.0.1/myapp/default/api/person/1.json</div><div class=""> ``</div><div class=""> </div><div class=""> into this:</div><div class=""> </div><div class=""> ``</div><div class=""> http://127.0.0.1/api/person/1.json</div><div class=""> ``</div><div class=""> </div><div class="insert">yet this is a matter of t<span class="highlight">a</span>st<span class="highlight">e</span> and we have already discussed it at length in chapter 4.</div><div class=""> </div><div class=""> In our example we used an action called ``api`` but this is not a requirement. We can in fact name the action that exposes the RESTful service any way we like and we can in fact even create more than one. For the sake of argument we will continue to assume that our RESTful action is called ``api``.</div><div class=""> </div><div class=""> We will also assume we have defined the following two tables:</div><div class=""> </div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;,Field(&#x27;name&#x27;),Field(&#x27;info&#x27;))</div><div class=""> db.define_table(&#x27;pet&#x27;,Field(&#x27;owner&#x27;,db.person),Field(&#x27;name&#x27;),Field(&#x27;info&#x27;))</div><div class=""> ``</div><div class=""> </div><div class=""> and they are the resources we want to expose.</div><div class=""> </div><div class=""> The first thing we do is create the RESTful action:</div><div class=""> </div><div class=""> ``</div><div class=""> def api():</div><div class="">     return locals()</div><div class=""> ``</div><div class=""> </div><div class=""> Now we modify it so that the extension is filtered out of the request args (so that ``request.args`` can be used to identify the resource) and so that it can handle the different methods separately:</div><div class=""> Notice that:</div><div class=""> - GET perform a select and returns the record, ``db.person(id)``. The output is automatically converted to JSON because the generic view is called.</div><div class=""> - POST performs a ``validate_and_insert(..)`` and returns the ``id`` of the new record or, alternatively, validation errors. The POST variables, ``**fields``, are the post variables.</div><div class=""> </div><div class=""> #### ``parse_as_rest`` (experimental)</div><div class=""> </div><div class=""> The logic explained so far is sufficient to create any type of RESTful web service yet web2py helps us even more.</div><div class=""> </div><div class=""> In fact, web2py provides a syntax to describe which database tables we want to expose and how to map resource into URLs and vice versa.</div><div class=""> </div><div class=""> ``parse_as_rest``:inxx</div><div class=""> </div><div class=""> This is done using URL patterns.</div><div class=""> A pattern is a string that maps the request args from a URL into a database query.</div><div class=""> There 4 types of atomic patterns:</div><div class=""> </div><div class=""> - String constants for example &quot;friend&quot;</div><div class=""> - String constant corresponding to a table. For example &quot;friend[person]&quot; will match &quot;friends&quot; in the URL to the &quot;person&quot; table.</div><div class=""> - Variables to be used to filter. For example &quot;{person.id}&quot; will apply a ``db.person.name=={person.id}`` filter.</div><div class=""> - Names of fields, represented by &quot;:field&quot;</div><div class=""> </div><div class="insert">Atomic patter<span class="highlight">n</span>s can be combined into complex URL patter<span class="highlight">n</span>s using &quot;/&quot; such as in</div><div class=""> </div><div class=""> ``</div><div class=""> &quot;/friend[person]/{person.id}/:field&quot;</div><div class=""> ``</div><div class=""> </div><div class=""> which gives a url of the form</div><div class=""> </div><div class=""> ``</div><div class=""> http://..../friend/1/name</div><div class=""> ``</div><div class=""> </div><div class=""> Into a query for a person.id that returns the name of the person. Here &quot;friend[person]&quot; matches &quot;friend&quot; and filters the table &quot;person&quot;. &quot;{person.id}&quot; matches &quot;1&quot; and filters &quot;person.id==1&quot;. &quot;:field&quot; matches &quot;name&quot; and returns:</div><div class=""> </div><div class=""> ``</div><div class=""> db(db.person.id==1).select().first().name</div><div class=""> ``</div><div class=""> </div><div class=""> Multiple URL patters can be combined into a list so that one single RESTful action can serve different types of requests.</div><div class=""> </div><div class=""> The DAL has a method ``parse_as_rest(pattern,args,vars)`` that given a list of patterns, the ``request.args`` and the ``request.vars`` matches the pattern and returns a response (GET only).</div><div class=""> def api():</div><div class="">             &quot;/friend/{person.name}/:field&quot;,</div><div class="">             &quot;/friend/{person.name}/pets[pet.owner]&quot;,</div><div class="">             &quot;/friend/{person.name}/pet[pet.owner]/{pet.name}&quot;,</div><div class="">             &quot;/friend/{person.name}/pet[pet.owner]/{pet.name}/:field&quot;</div><div class="">             ]</div><div class="">         parser = db.parse_as_rest(patterns,args,vars)</div><div class="">         if parser.status == 200:</div><div class="">             return dict(content=parser.response)</div><div class="">         else:</div><div class="">             raise HTTP(parser.status,parser.error)</div><div class="">     def POST(table_name,**vars):</div><div class="">         if table_name == &#x27;person&#x27;:</div><div class="">             return db.person.validate_and_insert(**vars)</div><div class="">         elif table_name == &#x27;pet&#x27;:</div><div class="">             return db.pet.validate_and_insert(**vars)</div><div class="">         else:</div><div class="">             raise HTTP(400)</div><div class="">     return locals()</div><div class=""> ``:code</div><div class=""> </div><div class="insert">Which understands the following URLs that correspond to the listed patter<span class="highlight">n</span>s:</div><div class=""> </div><div class=""> - GET all persons</div><div class=""> ``</div><div class=""> http://.../api/friends</div><div class=""> ``</div><div class=""> - GET one person with name starting with &quot;t&quot;</div><div class=""> ``</div><div class=""> http://.../api/friend/t</div><div class=""> ``</div><div class=""> - GET the &quot;info&quot; field value of the first person with name equal to &quot;Tim&quot;</div><div class=""> ``</div><div class=""> http://.../api/friend/Tim/info</div><div class=""> ``</div><div class=""> - GET a list of pets of the person (friend) above</div><div class=""> ``</div><div class=""> http://.../api/friend/Tim/pets</div><div class=""> ``</div><div class=""> - GET the pet with name &quot;Snoopy of person with name &quot;Tim&quot;</div><div class=""> ``</div><div class=""> http://.../api/friend/Tim/pet/Snoopy</div><div class=""> access granted, you said hello</div><div class=""> ### Services and Authentication</div><div class=""> ``Authentication``:inxx</div><div class=""> </div><div class=""> In the previous chapter we have discussed the use of the following decorators:</div><div class=""> ``</div><div class=""> @auth.requires_login()</div><div class=""> @auth.requires_membership(...)</div><div class=""> @auth.requires_permission(...)</div><div class=""> ``:code</div><div class=""> </div><div class=""> For normal actions (not decorated as services), these decorators can be used even if the output is rendered in a format other than HTML.</div><div class=""> </div><div class=""> For functions defined as services and decorated using the ``@service...`` decorators, the ``@auth...`` decorators should not be used. The two types of decorators cannot be mixed. If authentication is to be performed, it is the ``call`` actions that needs to be decorated:</div><div class=""> ``</div><div class=""> @auth.requires_login()</div><div class=""> def call(): return service()</div><div class=""> ``:code</div><div class=""> </div><div class=""> Notice that it also possible to instantiate multiple service objects, register the same different functions with them, and expose some of them with authentication and some not:</div><div class=""> ``</div><div class="insert">+public_service=Service()</div><div class="insert">+private_service=Service()</div></div></div>
    <div class="span6"><div class="diff"><div class=""> - A first part that identify the location of the service, i.e. the action that exposes the service:</div><div class=""> ``</div><div class=""> http://127.0.0.1/myapp/default/api/</div><div class=""> ``</div><div class=""> - The name of the resource (``person``, ``persons``, ``person/1``, etc.)</div><div class="delete">- The communication protocol specified <span class="highlight"></span>y the extension.</div><div class=""> </div><div class=""> Notice that we can always use the router to eliminate any unwanted prefix in the URL and for example simplify this:</div><div class=""> </div><div class=""> ``</div><div class=""> http://127.0.0.1/myapp/default/api/person/1.json</div><div class=""> ``</div><div class=""> </div><div class=""> into this:</div><div class=""> </div><div class=""> ``</div><div class=""> http://127.0.0.1/api/person/1.json</div><div class=""> ``</div><div class=""> </div><div class="delete">yet this is a matter of t<span class="highlight">e</span>st<span class="highlight"></span> and we have already discussed it at length in chapter 4.</div><div class=""> </div><div class=""> In our example we used an action called ``api`` but this is not a requirement. We can in fact name the action that exposes the RESTful service any way we like and we can in fact even create more than one. For the sake of argument we will continue to assume that our RESTful action is called ``api``.</div><div class=""> </div><div class=""> We will also assume we have defined the following two tables:</div><div class=""> </div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;,Field(&#x27;name&#x27;),Field(&#x27;info&#x27;))</div><div class=""> db.define_table(&#x27;pet&#x27;,Field(&#x27;owner&#x27;,db.person),Field(&#x27;name&#x27;),Field(&#x27;info&#x27;))</div><div class=""> ``</div><div class=""> </div><div class=""> and they are the resources we want to expose.</div><div class=""> </div><div class=""> The first thing we do is create the RESTful action:</div><div class=""> </div><div class=""> ``</div><div class=""> def api():</div><div class="">     return locals()</div><div class=""> ``</div><div class=""> </div><div class=""> Now we modify it so that the extension is filtered out of the request args (so that ``request.args`` can be used to identify the resource) and so that it can handle the different methods separately:</div><div class=""> Notice that:</div><div class=""> - GET perform a select and returns the record, ``db.person(id)``. The output is automatically converted to JSON because the generic view is called.</div><div class=""> - POST performs a ``validate_and_insert(..)`` and returns the ``id`` of the new record or, alternatively, validation errors. The POST variables, ``**fields``, are the post variables.</div><div class=""> </div><div class=""> #### ``parse_as_rest`` (experimental)</div><div class=""> </div><div class=""> The logic explained so far is sufficient to create any type of RESTful web service yet web2py helps us even more.</div><div class=""> </div><div class=""> In fact, web2py provides a syntax to describe which database tables we want to expose and how to map resource into URLs and vice versa.</div><div class=""> </div><div class=""> ``parse_as_rest``:inxx</div><div class=""> </div><div class=""> This is done using URL patterns.</div><div class=""> A pattern is a string that maps the request args from a URL into a database query.</div><div class=""> There 4 types of atomic patterns:</div><div class=""> </div><div class=""> - String constants for example &quot;friend&quot;</div><div class=""> - String constant corresponding to a table. For example &quot;friend[person]&quot; will match &quot;friends&quot; in the URL to the &quot;person&quot; table.</div><div class=""> - Variables to be used to filter. For example &quot;{person.id}&quot; will apply a ``db.person.name=={person.id}`` filter.</div><div class=""> - Names of fields, represented by &quot;:field&quot;</div><div class=""> </div><div class="delete">Atomic patter<span class="highlight"></span>s can be combined into complex URL patter<span class="highlight"></span>s using &quot;/&quot; such as in</div><div class=""> </div><div class=""> ``</div><div class=""> &quot;/friend[person]/{person.id}/:field&quot;</div><div class=""> ``</div><div class=""> </div><div class=""> which gives a url of the form</div><div class=""> </div><div class=""> ``</div><div class=""> http://..../friend/1/name</div><div class=""> ``</div><div class=""> </div><div class=""> Into a query for a person.id that returns the name of the person. Here &quot;friend[person]&quot; matches &quot;friend&quot; and filters the table &quot;person&quot;. &quot;{person.id}&quot; matches &quot;1&quot; and filters &quot;person.id==1&quot;. &quot;:field&quot; matches &quot;name&quot; and returns:</div><div class=""> </div><div class=""> ``</div><div class=""> db(db.person.id==1).select().first().name</div><div class=""> ``</div><div class=""> </div><div class=""> Multiple URL patters can be combined into a list so that one single RESTful action can serve different types of requests.</div><div class=""> </div><div class=""> The DAL has a method ``parse_as_rest(pattern,args,vars)`` that given a list of patterns, the ``request.args`` and the ``request.vars`` matches the pattern and returns a response (GET only).</div><div class=""> def api():</div><div class="">             &quot;/friend/{person.name}/:field&quot;,</div><div class="">             &quot;/friend/{person.name}/pets[pet.owner]&quot;,</div><div class="">             &quot;/friend/{person.name}/pet[pet.owner]/{pet.name}&quot;,</div><div class="">             &quot;/friend/{person.name}/pet[pet.owner]/{pet.name}/:field&quot;</div><div class="">             ]</div><div class="">         parser = db.parse_as_rest(patterns,args,vars)</div><div class="">         if parser.status == 200:</div><div class="">             return dict(content=parser.response)</div><div class="">         else:</div><div class="">             raise HTTP(parser.status,parser.error)</div><div class="">     def POST(table_name,**vars):</div><div class="">         if table_name == &#x27;person&#x27;:</div><div class="">             return db.person.validate_and_insert(**vars)</div><div class="">         elif table_name == &#x27;pet&#x27;:</div><div class="">             return db.pet.validate_and_insert(**vars)</div><div class="">         else:</div><div class="">             raise HTTP(400)</div><div class="">     return locals()</div><div class=""> ``:code</div><div class=""> </div><div class="delete">Which understands the following URLs that correspond to the listed patter<span class="highlight"></span>s:</div><div class=""> </div><div class=""> - GET all persons</div><div class=""> ``</div><div class=""> http://.../api/friends</div><div class=""> ``</div><div class=""> - GET one person with name starting with &quot;t&quot;</div><div class=""> ``</div><div class=""> http://.../api/friend/t</div><div class=""> ``</div><div class=""> - GET the &quot;info&quot; field value of the first person with name equal to &quot;Tim&quot;</div><div class=""> ``</div><div class=""> http://.../api/friend/Tim/info</div><div class=""> ``</div><div class=""> - GET a list of pets of the person (friend) above</div><div class=""> ``</div><div class=""> http://.../api/friend/Tim/pets</div><div class=""> ``</div><div class=""> - GET the pet with name &quot;Snoopy of person with name &quot;Tim&quot;</div><div class=""> ``</div><div class=""> http://.../api/friend/Tim/pet/Snoopy</div><div class=""> access granted, you said hello</div><div class=""> ### Services and Authentication</div><div class=""> ``Authentication``:inxx</div><div class=""> </div><div class=""> In the previous chapter we have discussed the use of the following decorators:</div><div class=""> ``</div><div class=""> @auth.requires_login()</div><div class=""> @auth.requires_membership(...)</div><div class=""> @auth.requires_permission(...)</div><div class=""> ``:code</div><div class=""> </div><div class=""> For normal actions (not decorated as services), these decorators can be used even if the output is rendered in a format other than HTML.</div><div class=""> </div><div class=""> For functions defined as services and decorated using the ``@service...`` decorators, the ``@auth...`` decorators should not be used. The two types of decorators cannot be mixed. If authentication is to be performed, it is the ``call`` actions that needs to be decorated:</div><div class=""> ``</div><div class=""> @auth.requires_login()</div><div class=""> def call(): return service()</div><div class=""> ``:code</div><div class=""> </div><div class=""> Notice that it also possible to instantiate multiple service objects, register the same different functions with them, and expose some of them with authentication and some not:</div><div class=""> ``</div><div class="delete">-public_services=Service()</div><div class="delete">-private_services=Service()</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/739a4c66c06a1aa5de5f4bd07b49e2f04ec30290">739a4c6</a><ul><li>Date : 2013-04-04</li><li>English 5th: Various text corrections</li></ul></li></ul>
<div class="row-fluid" id="com_739a4c66c06a1aa5de5f4bd07b49e2f04ec30290">
    <div class="span6"><div class="diff"><div class="insert"><span class="highlight">As an example of application here, we discuss the usage of </span>JSON<span class="highlight"> </span>R<span class="highlight">emote Procedure </span>C<span class="highlight">alls</span> with Pyjamas. Pyjamas is a Python port of the Google Web Toolkit (originally written in Java). Pyjamas allows writing a client application in Python. Pyjamas translates this code into JavaScript. web2py serves the JavaScript and communicates with it via AJAX requests originating from the client and triggered by user actions.</div><div class=""> </div><div class=""> Here we describe how to make Pyjamas work with web2py. It does not require any additional libraries other than web2py and Pyjamas.</div><div class=""> </div><div class=""> We are going to build a simple &quot;todo&quot; application with a Pyjamas client (all JavaScript) that talks to the server exclusively via JSONRPC.</div><div class=""> </div><div class=""> First, create a new application called &quot;todo&quot;.</div><div class=""> </div><div class=""> Second, in &quot;models/db.py&quot;, enter the following code:</div><div class=""> ``</div><div class=""> db=DAL(&#x27;sqlite://storage.sqlite&#x27;)</div><div class=""> db.define_table(&#x27;todo&#x27;, Field(&#x27;task&#x27;))</div><div class=""> service = Service()</div><div class=""> ``:code</div><div class=""> </div><div class=""> &#x27;&#x27;(Note: Service class is from gluon.tools).&#x27;&#x27;</div><div class=""> </div><div class=""> Third, in &quot;controllers/default.py&quot;, enter the following code:</div><div class=""> ``</div><div class="">     def index():</div><div class="">     redirect(URL(&#x27;todoApp&#x27;))</div><div class=""> You can obtain the WSDL for the service at</div><div class=""> </div><div class=""> ``</div><div class=""> http://127.0.0.1:8000/app/default/call/soap?WSDL</div><div class=""> ``:code</div><div class=""> </div><div class=""> And you can obtain documentation for any of the exposed methods:</div><div class=""> </div><div class=""> ``</div><div class=""> http://127.0.0.1:8000/app/default/call/soap</div><div class=""> ``:code</div><div class=""> </div><div class=""> ### Low level API and other recipes</div><div class=""> </div><div class=""> #### simplejson</div><div class=""> ``JSON``:inxx ``simplejson``:inxx</div><div class=""> </div><div class=""> web2py includes gluon.contrib.simplejson, developed by Bob Ippolito. This module provides the most standard Python-JSON encoder-decoder.</div><div class=""> </div><div class=""> SimpleJSON consists of two functions:</div><div class=""> - ``gluon.contrib.simplesjson.dumps(a)`` encodes a Python object ``a`` into JSON.</div><div class="insert">- ``gluon.contrib.simplejson.loads(b)`` decodes <span class="highlight">the JSON dat</span>a <span class="highlight"></span>i<span class="highlight">n</span> ``b`` into a Python object.</div></div></div>
    <div class="span6"><div class="diff"><div class="delete"><span class="highlight"></span>JSON<span class="highlight"></span>R<span class="highlight">P</span>C<span class="highlight"> is very similar to XMLRPC, but uses the JSON-based protocol instead of XML to encode the data. As an example of application here, we discuss its usage</span> with Pyjamas. Pyjamas is a Python port of the Google Web Toolkit (originally written in Java). Pyjamas allows writing a client application in Python. Pyjamas translates this code into JavaScript. web2py serves the JavaScript and communicates with it via AJAX requests originating from the client and triggered by user actions.</div><div class=""> </div><div class=""> Here we describe how to make Pyjamas work with web2py. It does not require any additional libraries other than web2py and Pyjamas.</div><div class=""> </div><div class=""> We are going to build a simple &quot;todo&quot; application with a Pyjamas client (all JavaScript) that talks to the server exclusively via JSONRPC.</div><div class=""> </div><div class=""> First, create a new application called &quot;todo&quot;.</div><div class=""> </div><div class=""> Second, in &quot;models/db.py&quot;, enter the following code:</div><div class=""> ``</div><div class=""> db=DAL(&#x27;sqlite://storage.sqlite&#x27;)</div><div class=""> db.define_table(&#x27;todo&#x27;, Field(&#x27;task&#x27;))</div><div class=""> service = Service()</div><div class=""> ``:code</div><div class=""> </div><div class=""> &#x27;&#x27;(Note: Service class is from gluon.tools).&#x27;&#x27;</div><div class=""> </div><div class=""> Third, in &quot;controllers/default.py&quot;, enter the following code:</div><div class=""> ``</div><div class="">     def index():</div><div class="">     redirect(URL(&#x27;todoApp&#x27;))</div><div class=""> You can obtain the WSDL for the service at</div><div class=""> </div><div class=""> ``</div><div class=""> http://127.0.0.1:8000/app/default/call/soap?WSDL</div><div class=""> ``:code</div><div class=""> </div><div class=""> And you can obtain documentation for any of the exposed methods:</div><div class=""> </div><div class=""> ``</div><div class=""> http://127.0.0.1:8000/app/default/call/soap</div><div class=""> ``:code</div><div class=""> </div><div class=""> ### Low level API and other recipes</div><div class=""> </div><div class=""> #### simplejson</div><div class=""> ``JSON``:inxx ``simplejson``:inxx</div><div class=""> </div><div class=""> web2py includes gluon.contrib.simplejson, developed by Bob Ippolito. This module provides the most standard Python-JSON encoder-decoder.</div><div class=""> </div><div class=""> SimpleJSON consists of two functions:</div><div class=""> - ``gluon.contrib.simplesjson.dumps(a)`` encodes a Python object ``a`` into JSON.</div><div class="delete">- ``gluon.contrib.simplejson.loads(b)`` decodes <span class="highlight"></span>a <span class="highlight">JavaScr</span>i<span class="highlight">pt object</span> ``b`` into a Python object.</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/08ea49aa89ef98c086c6affa5a2a8f52caac070d">08ea49a</a><ul><li>Date : 2013-01-21</li><li>jsonrpc2</li></ul></li></ul>
<div class="row-fluid" id="com_08ea49aa89ef98c086c6affa5a2a8f52caac070d">
    <div class="span6"><div class="diff"><div class=""> Third, you must decorate those functions you want to expose as a service. Here is a list of currently supported decorators:</div><div class=""> ``</div><div class=""> @service.run</div><div class=""> @service.xml</div><div class=""> @service.json</div><div class=""> @service.rss</div><div class=""> @service.csv</div><div class=""> @service.xmlrpc</div><div class=""> @service.jsonrpc</div><div class="insert">+@service.jsonrpc2</div><div class=""> @service.amfrpc3(&#x27;domain&#x27;)</div><div class=""> @service.soap(&#x27;FunctionName&#x27;,returns={&#x27;result&#x27;:type},args={&#x27;param1&#x27;:type,})</div><div class=""> ``:code</div><div class=""> </div><div class=""> As an example, consider the following decorated function:</div><div class=""> ``</div><div class=""> @service.run</div><div class=""> def concat(a,b):</div><div class="">     return a+b</div><div class=""> ``:code</div><div class=""> </div><div class=""> This function can be defined in a model or in the controller where the ``call`` action is defined. This function can now be called remotely in two ways:</div><div class=""> </div><div class=""> ``</div><div class=""> http://127.0.0.1:8000/app/default/call/run/concat?a=hello&amp;b=world</div><div class=""> http://127.0.0.1:8000/app/default/call/run/concat/hello/world</div><div class=""> ``:code</div><div class=""> </div><div class=""> In both cases the http request returns:</div><div class=""> ``</div><div class=""> ZeroDivisionError: integer division or modulo by zero</div><div class=""> </div><div class=""> The Python xmlrpclib module provides a client for the XMLRPC protocol. web2py acts as the server.</div><div class=""> </div><div class=""> The client connects to the server via ServerProxy and can remotely call decorated functions in the server. The data (a,b) is passed to the function(s), not via GET/POST variables, but properly encoded in the request body using the XMLPRC protocol, and thus it carries with itself type information (int or string or other). The same is true for the return value(s). Moreover, any exception raised on the server propagates back to the client.</div><div class=""> </div><div class=""> There are XMLRPC libraries for many programming languages (including C, C++, Java, C#, Ruby, and Perl), and they can interoperate with each other. This is one the best methods to create applications that talk to each other independent of the programming language.</div><div class=""> </div><div class=""> The XMLRPC client can also be implemented inside a web2py action, so that one action can talk to another web2py application (even within the same installation) using XMLRPC. Beware of session deadlocks in this case. If an action calls via XMLRPC a function in the same app, the caller must release the session lock before the call:</div><div class=""> ``</div><div class=""> session.forget(response)</div><div class=""> ``:code</div><div class=""> </div><div class=""> #### JSONRPC</div><div class=""> </div><div class=""> ``JSONRPC``:inxx</div><div class=""> </div><div class=""> In this section we are going to use the same code example as for XMLRPC but we will expose the service using JSONRPC instead:</div><div class=""> </div><div class=""> ``</div><div class=""> @service.jsonrpc</div><div class="insert">+@service.jsonrpc2</div><div class=""> def add(a,b):</div><div class="">     return a+b</div><div class=""> </div><div class=""> def call():</div><div class="">     return service()</div><div class=""> ``:code</div><div class=""> </div><div class=""> JSONRPC is very similar to XMLRPC but uses JSON instead of XML as data serialization protocol.</div><div class=""> </div><div class=""> Of course we can call the service from any program in any language but here we will do it in Python. web2py ships with a module &quot;gluon/contrib/simplejsonrpc.py&quot; created by Mariano Reingart. Here is an example of how to use to call the above service:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; from gluon.contrib.simplejsonrpc import ServerProxy</div><div class=""> &gt;&gt;&gt; URL = &quot;http://127.0.0.1:8000/app/default/call/jsonrpc&quot;</div><div class=""> &gt;&gt;&gt; service = ServerProxy(URL, verbose=True)</div><div class=""> &gt;&gt;&gt; print service.add(1, 2)</div><div class=""> ``:code</div><div class=""> </div><div class="insert">+Use &quot;http://127.0.0.1:8000/app/default/call/jsonrpc2&quot; for jsonrpc2.</div><div class="insert">+</div><div class=""> #### JSONRPC and Pyjamas</div><div class=""> ``JSONRPC``:inxx ``Pyjamas``:inxx</div></div></div>
    <div class="span6"><div class="diff"><div class=""> Third, you must decorate those functions you want to expose as a service. Here is a list of currently supported decorators:</div><div class=""> ``</div><div class=""> @service.run</div><div class=""> @service.xml</div><div class=""> @service.json</div><div class=""> @service.rss</div><div class=""> @service.csv</div><div class=""> @service.xmlrpc</div><div class=""> @service.jsonrpc</div><div class=""> @service.amfrpc3(&#x27;domain&#x27;)</div><div class=""> @service.soap(&#x27;FunctionName&#x27;,returns={&#x27;result&#x27;:type},args={&#x27;param1&#x27;:type,})</div><div class=""> ``:code</div><div class=""> </div><div class=""> As an example, consider the following decorated function:</div><div class=""> ``</div><div class=""> @service.run</div><div class=""> def concat(a,b):</div><div class="">     return a+b</div><div class=""> ``:code</div><div class=""> </div><div class=""> This function can be defined in a model or in the controller where the ``call`` action is defined. This function can now be called remotely in two ways:</div><div class=""> </div><div class=""> ``</div><div class=""> http://127.0.0.1:8000/app/default/call/run/concat?a=hello&amp;b=world</div><div class=""> http://127.0.0.1:8000/app/default/call/run/concat/hello/world</div><div class=""> ``:code</div><div class=""> </div><div class=""> In both cases the http request returns:</div><div class=""> ``</div><div class=""> ZeroDivisionError: integer division or modulo by zero</div><div class=""> </div><div class=""> The Python xmlrpclib module provides a client for the XMLRPC protocol. web2py acts as the server.</div><div class=""> </div><div class=""> The client connects to the server via ServerProxy and can remotely call decorated functions in the server. The data (a,b) is passed to the function(s), not via GET/POST variables, but properly encoded in the request body using the XMLPRC protocol, and thus it carries with itself type information (int or string or other). The same is true for the return value(s). Moreover, any exception raised on the server propagates back to the client.</div><div class=""> </div><div class=""> There are XMLRPC libraries for many programming languages (including C, C++, Java, C#, Ruby, and Perl), and they can interoperate with each other. This is one the best methods to create applications that talk to each other independent of the programming language.</div><div class=""> </div><div class=""> The XMLRPC client can also be implemented inside a web2py action, so that one action can talk to another web2py application (even within the same installation) using XMLRPC. Beware of session deadlocks in this case. If an action calls via XMLRPC a function in the same app, the caller must release the session lock before the call:</div><div class=""> ``</div><div class=""> session.forget(response)</div><div class=""> ``:code</div><div class=""> </div><div class=""> #### JSONRPC</div><div class=""> </div><div class=""> ``JSONRPC``:inxx</div><div class=""> </div><div class=""> In this section we are going to use the same code example as for XMLRPC but we will expose the service using JSONRPC instead:</div><div class=""> </div><div class=""> ``</div><div class=""> @service.jsonrpc</div><div class=""> def add(a,b):</div><div class="">     return a+b</div><div class=""> </div><div class=""> def call():</div><div class="">     return service()</div><div class=""> ``:code</div><div class=""> </div><div class=""> JSONRPC is very similar to XMLRPC but uses JSON instead of XML as data serialization protocol.</div><div class=""> </div><div class=""> Of course we can call the service from any program in any language but here we will do it in Python. web2py ships with a module &quot;gluon/contrib/simplejsonrpc.py&quot; created by Mariano Reingart. Here is an example of how to use to call the above service:</div><div class=""> </div><div class=""> ``</div><div class=""> &gt;&gt;&gt; from gluon.contrib.simplejsonrpc import ServerProxy</div><div class=""> &gt;&gt;&gt; URL = &quot;http://127.0.0.1:8000/app/default/call/jsonrpc&quot;</div><div class=""> &gt;&gt;&gt; service = ServerProxy(URL, verbose=True)</div><div class=""> &gt;&gt;&gt; print service.add(1, 2)</div><div class=""> ``:code</div><div class=""> </div><div class=""> #### JSONRPC and Pyjamas</div><div class=""> ``JSONRPC``:inxx ``Pyjamas``:inxx</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/097d699dc16179206ccb7e4aee863d6523cd471c">097d699</a><ul><li>Date : 2012-12-27</li><li>fixed typo, thanks Andrew</li></ul></li></ul>
<div class="row-fluid" id="com_097d699dc16179206ccb7e4aee863d6523cd471c">
    <div class="span6"><div class="diff"><div class=""> ``</div><div class=""> @request.restful()</div><div class=""> def api():</div><div class="">     response.view = &#x27;generic.json&#x27;</div><div class="">     def GET(tablename,id):</div><div class="">         if not tablename==&#x27;person&#x27;: raise HTTP(400)</div><div class="insert"><span class="highlight">        </span>return dict(person = db.person(id))</div><div class="">     def POST(tablename,**fields):</div><div class="">         if not tablename==&#x27;person&#x27;: raise HTTP(400)</div><div class="">         return db.person.validate_and_insert(**fields)</div><div class="">     return locals()</div><div class=""> ``</div><div class=""> </div><div class=""> Notice that:</div><div class=""> - the GET and POST are dealt with by different functions</div><div class=""> - the function expect the correct arguments (un-named arguments parsed by ``request.args`` and named arguments are from ``request.vars``)</div><div class=""> - they check the input is correct and eventually raise an exception</div><div class=""> - GET perform a select and returns the record, ``db.person(id)``. The output is automatically converted to JSON because the generic view is called.</div><div class=""> - POST performs a ``validate_and_insert(..)`` and returns the ``id`` of the new record or, alternatively, validation errors. The POST variables, ``**fields``, are the post variables.</div><div class=""> </div><div class=""> #### ``parse_as_rest`` (experimental)</div><div class=""> </div><div class=""> The logic explained so far is sufficient to create any type of RESTful web service yet web2py helps us even more.</div><div class=""> </div><div class=""> In fact, web2py provides a syntax to describe which database tables we want to expose and how to map resource into URLs and vice versa.</div><div class=""> </div><div class=""> ``parse_as_rest``:inxx</div><div class=""> patterns = [&#x27;:auto[person]&#x27;,&#x27;:auto[pet]&#x27;]</div><div class=""> </div><div class=""> #### ``smart_query`` (experimental)</div><div class=""> </div><div class=""> ``smart_query``:inxx</div><div class=""> </div><div class=""> There are times when you need more flexibility and you want to be able to pass to a RESTful service an arbitrary query like</div><div class=""> </div><div class=""> ``</div><div class=""> http://.../api.json?search=person.name starts with &#x27;T&#x27; and person.name contains &#x27;m&#x27;</div><div class=""> ``</div><div class=""> </div><div class=""> You can do this using</div><div class=""> </div><div class=""> ``</div><div class=""> @request.restful()</div><div class=""> def api():</div><div class="">     response.view = &#x27;generic.&#x27;+request.extension</div><div class="">     def GET(search):</div><div class="">         try:</div><div class="">             rows = db.smart_query([db.person,db.pet],search).select()</div><div class="insert"><span class="highlight">        </span>    return dict(result=rows)</div><div class="">         except RuntimeError:</div><div class="">             raise HTTP(400,&quot;Invalid search string&quot;)</div><div class="">     def POST(table_name,**vars):</div><div class="">         return db[table_name].validate_and_insert(**vars)</div><div class="">     return locals()</div><div class=""> ``</div><div class=""> </div><div class=""> The method ``db.smart_query`` takes two arguments:</div><div class=""> - a list of field or table that should be allowed in the query</div><div class=""> - a string containing the query expressed in natural language</div><div class=""> and it returns a ``db.set`` object with the records that have been found.</div><div class=""> </div><div class=""> Notice that the search string is parsed, not evaluated or executed and therefore it provides no security risk.</div><div class=""> </div><div class=""> </div><div class=""> #### Access Control</div><div class=""> </div><div class=""> Access to the API can be restricted as usual by using decorators. So, for example</div><div class=""> </div><div class=""> ``</div><div class=""> def call(): return service()</div><div class=""> </div><div class=""> Notice that it also possible to instantiate multiple service objects, register the same different functions with them, and expose some of them with authentication and some not:</div><div class=""> ``</div><div class=""> public_services=Service()</div><div class=""> private_services=Service()</div><div class=""> </div><div class=""> @public_service.jsonrpc</div><div class=""> @private_service.jsonrpc</div><div class=""> def f(): return &#x27;public&#x27;</div><div class=""> </div><div class=""> @private_service.jsonrpc</div><div class=""> def g(): return &#x27;private&#x27;</div><div class=""> </div><div class=""> def public_call(): return public_service()</div><div class=""> </div><div class=""> @auth.requires_login()</div><div class=""> def private_call(): return private_service()</div><div class=""> ``:code</div><div class=""> </div><div class=""> This assumes that the caller is passing credentials in the HTTP header (a valid session cookie or using basic authentication, as discussed in the previous section). The client must support it; not all clients do.</div></div></div>
    <div class="span6"><div class="diff"><div class=""> ``</div><div class=""> @request.restful()</div><div class=""> def api():</div><div class="">     response.view = &#x27;generic.json&#x27;</div><div class="">     def GET(tablename,id):</div><div class="">         if not tablename==&#x27;person&#x27;: raise HTTP(400)</div><div class="delete"><span class="highlight">	</span>return dict(person = db.person(id))</div><div class="">     def POST(tablename,**fields):</div><div class="">         if not tablename==&#x27;person&#x27;: raise HTTP(400)</div><div class="">         return db.person.validate_and_insert(**fields)</div><div class="">     return locals()</div><div class=""> ``</div><div class=""> </div><div class=""> Notice that:</div><div class=""> - the GET and POST are dealt with by different functions</div><div class=""> - the function expect the correct arguments (un-named arguments parsed by ``request.args`` and named arguments are from ``request.vars``)</div><div class=""> - they check the input is correct and eventually raise an exception</div><div class=""> - GET perform a select and returns the record, ``db.person(id)``. The output is automatically converted to JSON because the generic view is called.</div><div class=""> - POST performs a ``validate_and_insert(..)`` and returns the ``id`` of the new record or, alternatively, validation errors. The POST variables, ``**fields``, are the post variables.</div><div class=""> </div><div class=""> #### ``parse_as_rest`` (experimental)</div><div class=""> </div><div class=""> The logic explained so far is sufficient to create any type of RESTful web service yet web2py helps us even more.</div><div class=""> </div><div class=""> In fact, web2py provides a syntax to describe which database tables we want to expose and how to map resource into URLs and vice versa.</div><div class=""> </div><div class=""> ``parse_as_rest``:inxx</div><div class=""> patterns = [&#x27;:auto[person]&#x27;,&#x27;:auto[pet]&#x27;]</div><div class=""> </div><div class=""> #### ``smart_query`` (experimental)</div><div class=""> </div><div class=""> ``smart_query``:inxx</div><div class=""> </div><div class=""> There are times when you need more flexibility and you want to be able to pass to a RESTful service an arbitrary query like</div><div class=""> </div><div class=""> ``</div><div class=""> http://.../api.json?search=person.name starts with &#x27;T&#x27; and person.name contains &#x27;m&#x27;</div><div class=""> ``</div><div class=""> </div><div class=""> You can do this using</div><div class=""> </div><div class=""> ``</div><div class=""> @request.restful()</div><div class=""> def api():</div><div class="">     response.view = &#x27;generic.&#x27;+request.extension</div><div class="">     def GET(search):</div><div class="">         try:</div><div class="">             rows = db.smart_query([db.person,db.pet],search).select()</div><div class="delete"><span class="highlight">	</span>    return dict(result=rows)</div><div class="">         except RuntimeError:</div><div class="">             raise HTTP(400,&quot;Invalid search string&quot;)</div><div class="">     def POST(table_name,**vars):</div><div class="">         return db[table_name].validate_and_insert(**vars)</div><div class="">     return locals()</div><div class=""> ``</div><div class=""> </div><div class=""> The method ``db.smart_query`` takes two arguments:</div><div class=""> - a list of field or table that should be allowed in the query</div><div class=""> - a string containing the query expressed in natural language</div><div class=""> and it returns a ``db.set`` object with the records that have been found.</div><div class=""> </div><div class=""> Notice that the search string is parsed, not evaluated or executed and therefore it provides no security risk.</div><div class=""> </div><div class=""> </div><div class=""> #### Access Control</div><div class=""> </div><div class=""> Access to the API can be restricted as usual by using decorators. So, for example</div><div class=""> </div><div class=""> ``</div><div class=""> def call(): return service()</div><div class=""> </div><div class=""> Notice that it also possible to instantiate multiple service objects, register the same different functions with them, and expose some of them with authentication and some not:</div><div class=""> ``</div><div class=""> public_services=Service()</div><div class=""> private_services=Service()</div><div class=""> </div><div class=""> @public_service.jsonrpc</div><div class=""> @private_service.jsonrpc</div><div class=""> def f(): return &#x27;public&#x27;</div><div class=""> </div><div class=""> @private_service.jsonrpc</div><div class=""> def g(): return &#x27;private&#x27;</div><div class=""> </div><div class=""> def public_call(): return public_service()</div><div class=""> </div><div class=""> @auth.requires_login()</div><div class=""> def private_call(): return private_service()</div><div class=""> ``:code</div><div class=""> </div><div class=""> This assumes that the caller is passing credentials in the HTTP header (a valid session cookie or using basic authentication, as discussed in the previous section). The client must support it; not all clients do.</div><div class="delete">-</div><div class="delete">-</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/730243d39a6e2e29d00947ac3ae5c74c188a7bf4">730243d</a><ul><li>Date : 2012-11-27</li><li>fix typo</li></ul></li></ul>
<div class="row-fluid" id="com_730243d39a6e2e29d00947ac3ae5c74c188a7bf4">
    <div class="span6"><div class="diff"><div class=""> ``</div><div class="insert">&gt;&gt;&gt; from gluon.contrib.simplejsonrpc import<span class="highlight"> ServerProxy</span></div><div class=""> &gt;&gt;&gt; URL = &quot;http://127.0.0.1:8000/app/default/call/jsonrpc&quot;</div><div class=""> &gt;&gt;&gt; service = ServerProxy(URL, verbose=True)</div><div class=""> &gt;&gt;&gt; print service.add(1, 2)</div><div class=""> ``:code</div><div class=""> </div><div class=""> #### JSONRPC and Pyjamas</div><div class=""> ``JSONRPC``:inxx ``Pyjamas``:inxx</div><div class=""> </div><div class=""> JSONRPC is very similar to XMLRPC, but uses the JSON-based protocol instead of XML to encode the data. As an example of application here, we discuss its usage with Pyjamas. Pyjamas is a Python port of the Google Web Toolkit (originally written in Java). Pyjamas allows writing a client application in Python. Pyjamas translates this code into JavaScript. web2py serves the JavaScript and communicates with it via AJAX requests originating from the client and triggered by user actions.</div><div class=""> </div><div class=""> Here we describe how to make Pyjamas work with web2py. It does not require any additional libraries other than web2py and Pyjamas.</div><div class=""> </div><div class=""> We are going to build a simple &quot;todo&quot; application with a Pyjamas client (all JavaScript) that talks to the server exclusively via JSONRPC.</div><div class=""> </div><div class=""> First, create a new application called &quot;todo&quot;.</div><div class=""> </div><div class=""> Second, in &quot;models/db.py&quot;, enter the following code:</div><div class=""> ``</div><div class=""> db=DAL(&#x27;sqlite://storage.sqlite&#x27;)</div><div class=""> db.define_table(&#x27;todo&#x27;, Field(&#x27;task&#x27;))</div><div class=""> if __name__ == &#x27;__main__&#x27;:</div><div class="">     app = TodoApp()</div><div class="">     app.onModuleLoad()</div><div class=""> ``:code</div><div class=""> </div><div class=""> Sixth, run Pyjamas before serving the application:</div><div class=""> ``</div><div class=""> cd /path/to/todo/static/</div><div class=""> python /python/pyjamas-0.5p1/bin/pyjsbuild TodoApp.py</div><div class=""> ``:code</div><div class=""> </div><div class=""> This will translate the Python code into JavaScript so that it can be executed in the browser.</div><div class=""> </div><div class=""> To access this application, visit the URL:</div><div class=""> </div><div class=""> ``</div><div class=""> http://127.0.0.1:8000/todo/default/todoApp</div><div class=""> ``:code</div><div class=""> </div><div class=""> This subsection was created by Chris Prinos with help from Luke Kenneth Casson Leighton (creators of Pyjamas), updated by Alexei Vinidiktov. It has been tested with Pyjamas 0.5p1. The example was inspired by this Django page in ref.``blogspot1``:cite.</div><div class=""> </div><div class="insert">#### A<span class="highlight">MFRPC</span></div><div class=""> ``PyAMF``:inxx ``Adobe Flash``:inxx</div></div></div>
    <div class="span6"><div class="diff"><div class=""> ``</div><div class="delete">&gt;&gt;&gt; from gluon.contrib.simplejsonrpc import<span class="highlight"></span></div><div class=""> &gt;&gt;&gt; URL = &quot;http://127.0.0.1:8000/app/default/call/jsonrpc&quot;</div><div class=""> &gt;&gt;&gt; service = ServerProxy(URL, verbose=True)</div><div class=""> &gt;&gt;&gt; print service.add(1, 2)</div><div class=""> ``:code</div><div class=""> </div><div class=""> #### JSONRPC and Pyjamas</div><div class=""> ``JSONRPC``:inxx ``Pyjamas``:inxx</div><div class=""> </div><div class=""> JSONRPC is very similar to XMLRPC, but uses the JSON-based protocol instead of XML to encode the data. As an example of application here, we discuss its usage with Pyjamas. Pyjamas is a Python port of the Google Web Toolkit (originally written in Java). Pyjamas allows writing a client application in Python. Pyjamas translates this code into JavaScript. web2py serves the JavaScript and communicates with it via AJAX requests originating from the client and triggered by user actions.</div><div class=""> </div><div class=""> Here we describe how to make Pyjamas work with web2py. It does not require any additional libraries other than web2py and Pyjamas.</div><div class=""> </div><div class=""> We are going to build a simple &quot;todo&quot; application with a Pyjamas client (all JavaScript) that talks to the server exclusively via JSONRPC.</div><div class=""> </div><div class=""> First, create a new application called &quot;todo&quot;.</div><div class=""> </div><div class=""> Second, in &quot;models/db.py&quot;, enter the following code:</div><div class=""> ``</div><div class=""> db=DAL(&#x27;sqlite://storage.sqlite&#x27;)</div><div class=""> db.define_table(&#x27;todo&#x27;, Field(&#x27;task&#x27;))</div><div class=""> if __name__ == &#x27;__main__&#x27;:</div><div class="">     app = TodoApp()</div><div class="">     app.onModuleLoad()</div><div class=""> ``:code</div><div class=""> </div><div class=""> Sixth, run Pyjamas before serving the application:</div><div class=""> ``</div><div class=""> cd /path/to/todo/static/</div><div class=""> python /python/pyjamas-0.5p1/bin/pyjsbuild TodoApp.py</div><div class=""> ``:code</div><div class=""> </div><div class=""> This will translate the Python code into JavaScript so that it can be executed in the browser.</div><div class=""> </div><div class=""> To access this application, visit the URL:</div><div class=""> </div><div class=""> ``</div><div class=""> http://127.0.0.1:8000/todo/default/todoApp</div><div class=""> ``:code</div><div class=""> </div><div class=""> This subsection was created by Chris Prinos with help from Luke Kenneth Casson Leighton (creators of Pyjamas), updated by Alexei Vinidiktov. It has been tested with Pyjamas 0.5p1. The example was inspired by this Django page in ref.``blogspot1``:cite.</div><div class=""> </div><div class="delete">#### A<span class="highlight">mfrpc</span></div><div class=""> ``PyAMF``:inxx ``Adobe Flash``:inxx</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/e592e03bad4f2611839574a894a9046fed5d8358">e592e03</a><ul><li>Date : 2012-09-14</li><li>fixed typo in animal example</li></ul></li></ul>
<div class="row-fluid" id="com_e592e03bad4f2611839574a894a9046fed5d8358">
    <div class="span6"><div class="diff"><div class=""> Consider the following model:</div><div class=""> ``</div><div class="insert">db.define_<span class="highlight">tabl</span>e<span class="highlight"></span>(&#x27;animal&#x27;,</div><div class="">     Field(&#x27;species&#x27;),</div><div class="">     Field(&#x27;genus&#x27;),</div><div class="">     Field(&#x27;family&#x27;))</div><div class=""> ``:code</div></div></div>
    <div class="span6"><div class="diff"><div class=""> Consider the following model:</div><div class=""> ``</div><div class="delete">db.define_<span class="highlight">mod</span>e<span class="highlight">l</span>(&#x27;animal&#x27;,</div><div class="">     Field(&#x27;species&#x27;),</div><div class="">     Field(&#x27;genus&#x27;),</div><div class="">     Field(&#x27;family&#x27;))</div><div class=""> ``:code</div></div></div>
</div>
<hr />



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/2ac6ed57e8011e0c6032d851d303ba7c00ca6cd4">2ac6ed5</a><ul><li>Date : 2012-09-11</li><li>Update sources/29-web2py-english/10.markmin</li></ul></li></ul>
<div class="row-fluid" id="com_2ac6ed57e8011e0c6032d851d303ba7c00ca6cd4">
    <div class="span6"><div class="diff"><div class=""> ## Services</div><div class=""> ``Web Services``:inxx ``API``:inxx</div><div class=""> </div><div class=""> The W3C defines a web service as &quot;a software system designed to support interoperable machine-to-machine interaction over a network&quot;. This is a broad definition, and it encompasses a large number of protocols designed not for machine-to-human communication, but for machine-to-machine communication such as XML, JSON, RSS, etc.</div><div class=""> </div><div class=""> In this chapter we discuss how to expose web services using web2py. If you are interested in examples of consuming third party services (Twitter, Dropbox, etc.) you should look into Chapter 9 and Chapter 14.</div><div class=""> </div><div class=""> web2py provides, out of the box, support for many protocols, including XML, JSON, RSS, CSV, XMLRPC, JSONRPC, AMFRPC, and SOAP. web2py can also be extended to support additional protocols.</div><div class=""> </div><div class="insert">Each of those protocols <span class="highlight">are</span> supported in multiple ways, and we make a distinction between:</div><div class=""> - Rendering the output of a function in a given format (for example XML, JSON, RSS, CSV)</div><div class=""> - Remote Procedure Calls (for example XMLRPC, JSONRPC, AMFRPC)</div><div class=""> </div><div class=""> ### Rendering a dictionary</div><div class=""> </div><div class=""> #### HTML, XML, and JSON</div><div class=""> ``HTML``:inxx ``XML``:inxx ``JSON``:inxx</div><div class=""> </div><div class=""> Consider the following action:</div><div class=""> ``</div><div class=""> def count():</div><div class="">     session.counter = (session.counter or 0) + 1</div><div class="">     return dict(counter=session.counter, now=request.now)</div><div class=""> ``:code</div><div class=""> </div><div class=""> This action returns a counter that is increased by one when a visitor reloads the page, and the timestamp of the current page request.</div><div class=""> </div><div class=""> Normally this page would be requested via:</div><div class=""> </div><div class=""> ``</div><div class=""> and rendered in HTML. Without writing one line of code, we can ask web2py to ren</div><div class=""> http://127.0.0.1:8000/app/default/count.html</div><div class=""> http://127.0.0.1:8000/app/default/count.xml</div><div class=""> http://127.0.0.1:8000/app/default/count.json</div><div class=""> ``:code</div><div class=""> </div><div class=""> The dictionary returned by the action will be rendered in HTML, XML and JSON, respectively.</div><div class=""> </div><div class=""> Here is the XML output:</div><div class=""> ``</div><div class=""> &lt;document&gt;</div><div class="">    &lt;counter&gt;3&lt;/counter&gt;</div><div class="">    &lt;now&gt;2009-08-01 13:00:00&lt;/now&gt;</div><div class=""> &lt;/document&gt;</div><div class=""> ``:code</div><div class=""> </div><div class=""> Here is the JSON output:</div><div class=""> ``</div><div class=""> { &#x27;counter&#x27;:3, &#x27;now&#x27;:&#x27;2009-08-01 13:00:00&#x27; }</div><div class=""> ``:code</div><div class=""> </div><div class="insert">Notice that date, time<span class="highlight"></span> and datetime objects are rendered as strings in ISO format. This is not part of the JSON standard, but rather a web2py convention.</div><div class=""> </div><div class=""> #### Generic views</div><div class=""> </div><div class=""> When, for example, the &quot;.xml&quot; extension is called, web2py looks for a template file called &quot;default/count.xml&quot;, and if it does not find it, looks for a template called &quot;generic.xml&quot;.  The files &quot;generic.html&quot;, &quot;generic.xml&quot;, &quot;generic.json&quot; are provided with the current scaffolding application. Other extensions can be easily defined by the user.</div><div class=""> </div><div class=""> ------</div><div class=""> For security reasons the generic views are only allowed to be accessed on localhost. In order to enable the access from remote clients you may need to set the response.generic_patterns.</div><div class=""> ------</div><div class="insert">Assuming you are using a copy of scaffold app<span class="highlight">,</span> edit the following line in models/db.py</div><div class=""> </div><div class=""> - restrict access only to localhost</div><div class=""> ``</div><div class=""> response.generic_patterns = [&#x27;*&#x27;] if request.is_local else []</div><div class=""> ``:code</div><div class=""> </div><div class=""> - to allow all generic views</div><div class=""> ``</div><div class=""> response.generic_patterns = [&#x27;*&#x27;]</div><div class=""> ``:code</div><div class=""> </div><div class=""> - to allow only .json</div><div class=""> </div><div class=""> ``</div><div class=""> response.generic_patterns = [&#x27;*.json&#x27;]</div><div class=""> ``:code</div><div class=""> </div><div class=""> The generic_patterns is a glob pattern, it means you can use any patterns that matches with your app actions or pass a list of patterns.</div><div class=""> </div><div class=""> ``</div><div class=""> animals.export_to_csv_file(stream)</div><div class=""> response.headers[&#x27;Content-Type&#x27;]=&#x27;application/vnd.ms-excel&#x27;</div><div class=""> response.write(stream.getvalue(), escape=False)</div><div class=""> }}</div><div class=""> ``:code</div><div class=""> </div><div class=""> Notice that one could also define a &quot;generic.csv&quot; file, but one would have to specify the name of the object to be serialized (&quot;animals&quot; in the example). This is why we do not provide a &quot;generic.csv&quot; file.</div><div class=""> </div><div class=""> ### Remote procedure calls</div><div class=""> ``RPC``:inxx</div><div class=""> </div><div class=""> web2py provides a mechanism to turn any function into a web service.</div><div class=""> The mechanism described here differs from the mechanism described before because:</div><div class=""> - The function may take arguments</div><div class=""> - The function may be defined in a model or a module instead of controller</div><div class=""> - You may want to specify in detail which RPC method should be supported</div><div class=""> - It enforces a more strict URL naming convention</div><div class=""> - It is smarter than the previous methods because it works for a fixed set of protocols. For the same reason it is not as easily extensible.</div><div class=""> </div><div class=""> To use this feature:</div><div class=""> </div><div class="insert">First, you must import and in<span class="highlight">i</span>tiate a service object.</div><div class=""> ``</div><div class=""> from gluon.tools import Service</div><div class=""> service = Service()</div><div class=""> ``:code</div><div class=""> </div><div class=""> -------</div><div class=""> This is already done in the &quot;db.py&quot; model file in the scaffolding application.</div><div class=""> -------</div><div class=""> </div><div class=""> Second, you must expose the service handler in the controller:</div><div class=""> ``</div><div class=""> def call():</div><div class="">     session.forget()</div><div class="">     return service()</div><div class=""> ``:code</div><div class=""> </div><div class=""> -------</div><div class=""> This is already done in the &quot;default.py&quot; controller of the scaffolding application. Remove ``session.forget()`` if you plan to use session cookies with the services.</div><div class=""> -------</div><div class=""> </div><div class=""> def weekdays():</div><div class="">     import gluon.contrib.simplejson</div><div class="">     return gluon.contrib.simplejson.dumps(names)</div><div class=""> ``:code</div><div class=""> </div><div class=""> Below is a sample HTML page that sends an Ajax request to the above action, receives the JSON message and stores the list in a corresponding JavaScript variable:</div><div class=""> ``</div><div class=""> {{extend &#x27;layout.html&#x27;}}</div><div class=""> &lt;script&gt;</div><div class=""> $.getJSON(&#x27;/application/default/weekdays&#x27;,</div><div class="">           function(data){ alert(data); });</div><div class=""> &lt;/script&gt;</div><div class=""> ``:code</div><div class=""> </div><div class=""> The code uses the jQuery function ``$.getJSON``, which performs the Ajax call and, on response, stores the weekdays names in a local JavaScript variable ``data`` and passes the variable to the callback function. In the example the callback function simply alerts the visitor that the data has been received.</div><div class=""> </div><div class=""> #### PyRTF</div><div class=""> ``PyRTF``:inxx ``RTF``:inxx</div><div class=""> </div><div class=""> Another common need of web sites is that of generating Word-readable text documents. The simplest way to do so is using the Rich Text Format (RTF) document format. This format was invented by Microsoft and it has since become a standard.</div><div class=""> </div><div class="insert">web2py includes gluon.contrib.pyrtf, developed by Simon Cusack and revised by Grant Edwards. This module allows you to generate RTF documents programmatically<span class="highlight">,</span> including colored formatted text and pictures.</div><div class=""> </div><div class="insert">In the following example we in<span class="highlight">i</span>tiate two basic RTF classes, Document and Section, append the latter to the former and insert some dummy text in the latter:</div><div class=""> ``</div><div class=""> def makertf():</div><div class="">     import gluon.contrib.pyrtf as q</div><div class="">     doc=q.Document()</div><div class="">     section=q.Section()</div><div class="">     doc.Sections.append(section)</div><div class="">     section.append(&#x27;Section Title&#x27;)</div><div class="">     section.append(&#x27;web2py is great. &#x27;*100)</div><div class="">     response.headers[&#x27;Content-Type&#x27;]=&#x27;text/rtf&#x27;</div><div class="">     return q.dumps(doc)</div><div class=""> ``:code</div><div class=""> </div><div class=""> In the end the Document is serialized by ``q.dumps(doc)``. Notice that before returning an RTF document it is necessary to specify the content-type in the header else the browser does not know how to handle the file.</div><div class=""> </div><div class=""> Depending on the configuration, the browser may ask you whether to save this file or open it using a text editor.</div><div class=""> </div><div class=""> #### ReportLab and PDF</div><div class=""> ``ReportLab``:inxx ``PDF``:inxx</div><div class=""> </div><div class=""> web2py can also generate PDF documents, with an additional library called &quot;ReportLab&quot;``ReportLab``:cite .</div><div class=""> In the case of web2py each request can be split into three parts:</div><div class=""> ``</div><div class=""> http://127.0.0.1/myapp/default/api/</div><div class=""> ``</div><div class=""> - The name of the resource (``person``, ``persons``, ``person/1``, etc.)</div><div class=""> - The communication protocol specified y the extension.</div><div class=""> </div><div class=""> Notice that we can always use the router to eliminate any unwanted prefix in the URL and for example simplify this:</div><div class=""> </div><div class=""> ``</div><div class=""> http://127.0.0.1/myapp/default/api/person/1.json</div><div class=""> ``</div><div class=""> </div><div class=""> into this:</div><div class=""> </div><div class=""> ``</div><div class=""> http://127.0.0.1/api/person/1.json</div><div class=""> ``</div><div class=""> </div><div class=""> yet this is a matter of test and we have already discussed it at length in chapter 4.</div><div class=""> </div><div class="insert">In our example we used an action called ``api`` but this is not a requirement. We can in fact name the action that exposes the RESTful service any way we like and we can in fact even create more than one. For the sa<span class="highlight">ke of</span> argument we will continue to assume that our RESTful action is called ``api``.</div><div class=""> </div><div class=""> We will also assume we have defined the following two tables:</div><div class=""> </div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;,Field(&#x27;name&#x27;),Field(&#x27;info&#x27;))</div><div class=""> db.define_table(&#x27;pet&#x27;,Field(&#x27;owner&#x27;,db.person),Field(&#x27;name&#x27;),Field(&#x27;info&#x27;))</div><div class=""> ``</div><div class=""> </div><div class=""> and they are the resources we want to expose.</div><div class=""> </div><div class=""> The first thing we do is create the RESTful action:</div><div class=""> </div><div class=""> ``</div><div class=""> def api():</div><div class="">     return locals()</div><div class=""> ``</div><div class=""> </div><div class=""> Now we modify it so that the extension is filtered out of the request args (so that ``request.args`` can be used to identify the resource) and so that it can handle the different methods separately:</div><div class=""> </div><div class=""> ``</div><div class=""> which for out ``person`` and ``pet`` tables results in:</div><div class="">    &quot;/person/info/pet[pet.owner]/owner/{pet.owner}&quot;,</div><div class="">    &quot;/person/info/pet[pet.owner]/owner/{pet.owner}/:field&quot;,</div><div class="">    &quot;/pet[pet]&quot;,</div><div class="">    &quot;/pet/id/{pet.id}&quot;,</div><div class="">    &quot;/pet/id/{pet.id}/:field&quot;,</div><div class="">    &quot;/pet/owner/{pet.owner}&quot;,</div><div class="">    &quot;/pet/owner/{pet.owner}/:field&quot;</div><div class=""> ]}</div><div class=""> ``</div><div class=""> </div><div class=""> You can specify auto patterns for some tables only:</div><div class=""> </div><div class=""> ``</div><div class=""> patterns = [&#x27;:auto[person]&#x27;,&#x27;:auto[pet]&#x27;]</div><div class=""> ``</div><div class=""> </div><div class=""> #### ``smart_query`` (experimental)</div><div class=""> </div><div class=""> ``smart_query``:inxx</div><div class=""> </div><div class="insert">There are time<span class="highlight">s</span> when you need more flexibility and you want to be able to pass to a RESTful service an arbitrary query like</div></div></div>
    <div class="span6"><div class="diff"><div class="delete">-</div><div class=""> ## Services</div><div class=""> ``Web Services``:inxx ``API``:inxx</div><div class=""> </div><div class=""> The W3C defines a web service as &quot;a software system designed to support interoperable machine-to-machine interaction over a network&quot;. This is a broad definition, and it encompasses a large number of protocols designed not for machine-to-human communication, but for machine-to-machine communication such as XML, JSON, RSS, etc.</div><div class=""> </div><div class=""> In this chapter we discuss how to expose web services using web2py. If you are interested in examples of consuming third party services (Twitter, Dropbox, etc.) you should look into Chapter 9 and Chapter 14.</div><div class=""> </div><div class=""> web2py provides, out of the box, support for many protocols, including XML, JSON, RSS, CSV, XMLRPC, JSONRPC, AMFRPC, and SOAP. web2py can also be extended to support additional protocols.</div><div class=""> </div><div class="delete">Each of those protocols <span class="highlight">is</span> supported in multiple ways, and we make a distinction between:</div><div class=""> - Rendering the output of a function in a given format (for example XML, JSON, RSS, CSV)</div><div class=""> - Remote Procedure Calls (for example XMLRPC, JSONRPC, AMFRPC)</div><div class=""> </div><div class=""> ### Rendering a dictionary</div><div class=""> </div><div class=""> #### HTML, XML, and JSON</div><div class=""> ``HTML``:inxx ``XML``:inxx ``JSON``:inxx</div><div class=""> </div><div class=""> Consider the following action:</div><div class=""> ``</div><div class=""> def count():</div><div class="">     session.counter = (session.counter or 0) + 1</div><div class="">     return dict(counter=session.counter, now=request.now)</div><div class=""> ``:code</div><div class=""> </div><div class=""> This action returns a counter that is increased by one when a visitor reloads the page, and the timestamp of the current page request.</div><div class=""> </div><div class=""> Normally this page would be requested via:</div><div class=""> </div><div class=""> ``</div><div class=""> and rendered in HTML. Without writing one line of code, we can ask web2py to ren</div><div class=""> http://127.0.0.1:8000/app/default/count.html</div><div class=""> http://127.0.0.1:8000/app/default/count.xml</div><div class=""> http://127.0.0.1:8000/app/default/count.json</div><div class=""> ``:code</div><div class=""> </div><div class=""> The dictionary returned by the action will be rendered in HTML, XML and JSON, respectively.</div><div class=""> </div><div class=""> Here is the XML output:</div><div class=""> ``</div><div class=""> &lt;document&gt;</div><div class="">    &lt;counter&gt;3&lt;/counter&gt;</div><div class="">    &lt;now&gt;2009-08-01 13:00:00&lt;/now&gt;</div><div class=""> &lt;/document&gt;</div><div class=""> ``:code</div><div class=""> </div><div class=""> Here is the JSON output:</div><div class=""> ``</div><div class=""> { &#x27;counter&#x27;:3, &#x27;now&#x27;:&#x27;2009-08-01 13:00:00&#x27; }</div><div class=""> ``:code</div><div class=""> </div><div class="delete">Notice that date, time<span class="highlight">,</span> and datetime objects are rendered as strings in ISO format. This is not part of the JSON standard, but rather a web2py convention.</div><div class=""> </div><div class=""> #### Generic views</div><div class=""> </div><div class=""> When, for example, the &quot;.xml&quot; extension is called, web2py looks for a template file called &quot;default/count.xml&quot;, and if it does not find it, looks for a template called &quot;generic.xml&quot;.  The files &quot;generic.html&quot;, &quot;generic.xml&quot;, &quot;generic.json&quot; are provided with the current scaffolding application. Other extensions can be easily defined by the user.</div><div class=""> </div><div class=""> ------</div><div class=""> For security reasons the generic views are only allowed to be accessed on localhost. In order to enable the access from remote clients you may need to set the response.generic_patterns.</div><div class=""> ------</div><div class="delete">Assuming you are using a copy of scaffold app<span class="highlight"></span> edit the following line in models/db.py</div><div class=""> </div><div class=""> - restrict access only to localhost</div><div class=""> ``</div><div class=""> response.generic_patterns = [&#x27;*&#x27;] if request.is_local else []</div><div class=""> ``:code</div><div class=""> </div><div class=""> - to allow all generic views</div><div class=""> ``</div><div class=""> response.generic_patterns = [&#x27;*&#x27;]</div><div class=""> ``:code</div><div class=""> </div><div class=""> - to allow only .json</div><div class=""> </div><div class=""> ``</div><div class=""> response.generic_patterns = [&#x27;*.json&#x27;]</div><div class=""> ``:code</div><div class=""> </div><div class=""> The generic_patterns is a glob pattern, it means you can use any patterns that matches with your app actions or pass a list of patterns.</div><div class=""> </div><div class=""> ``</div><div class=""> animals.export_to_csv_file(stream)</div><div class=""> response.headers[&#x27;Content-Type&#x27;]=&#x27;application/vnd.ms-excel&#x27;</div><div class=""> response.write(stream.getvalue(), escape=False)</div><div class=""> }}</div><div class=""> ``:code</div><div class=""> </div><div class=""> Notice that one could also define a &quot;generic.csv&quot; file, but one would have to specify the name of the object to be serialized (&quot;animals&quot; in the example). This is why we do not provide a &quot;generic.csv&quot; file.</div><div class=""> </div><div class=""> ### Remote procedure calls</div><div class=""> ``RPC``:inxx</div><div class=""> </div><div class=""> web2py provides a mechanism to turn any function into a web service.</div><div class=""> The mechanism described here differs from the mechanism described before because:</div><div class=""> - The function may take arguments</div><div class=""> - The function may be defined in a model or a module instead of controller</div><div class=""> - You may want to specify in detail which RPC method should be supported</div><div class=""> - It enforces a more strict URL naming convention</div><div class=""> - It is smarter than the previous methods because it works for a fixed set of protocols. For the same reason it is not as easily extensible.</div><div class=""> </div><div class=""> To use this feature:</div><div class=""> </div><div class="delete">First, you must import and in<span class="highlight">stan</span>tiate a service object.</div><div class=""> ``</div><div class=""> from gluon.tools import Service</div><div class=""> service = Service()</div><div class=""> ``:code</div><div class=""> </div><div class=""> -------</div><div class=""> This is already done in the &quot;db.py&quot; model file in the scaffolding application.</div><div class=""> -------</div><div class=""> </div><div class=""> Second, you must expose the service handler in the controller:</div><div class=""> ``</div><div class=""> def call():</div><div class="">     session.forget()</div><div class="">     return service()</div><div class=""> ``:code</div><div class=""> </div><div class=""> -------</div><div class=""> This is already done in the &quot;default.py&quot; controller of the scaffolding application. Remove ``session.forget()`` if you plan to use session cookies with the services.</div><div class=""> -------</div><div class=""> </div><div class=""> def weekdays():</div><div class="">     import gluon.contrib.simplejson</div><div class="">     return gluon.contrib.simplejson.dumps(names)</div><div class=""> ``:code</div><div class=""> </div><div class=""> Below is a sample HTML page that sends an Ajax request to the above action, receives the JSON message and stores the list in a corresponding JavaScript variable:</div><div class=""> ``</div><div class=""> {{extend &#x27;layout.html&#x27;}}</div><div class=""> &lt;script&gt;</div><div class=""> $.getJSON(&#x27;/application/default/weekdays&#x27;,</div><div class="">           function(data){ alert(data); });</div><div class=""> &lt;/script&gt;</div><div class=""> ``:code</div><div class=""> </div><div class=""> The code uses the jQuery function ``$.getJSON``, which performs the Ajax call and, on response, stores the weekdays names in a local JavaScript variable ``data`` and passes the variable to the callback function. In the example the callback function simply alerts the visitor that the data has been received.</div><div class=""> </div><div class=""> #### PyRTF</div><div class=""> ``PyRTF``:inxx ``RTF``:inxx</div><div class=""> </div><div class=""> Another common need of web sites is that of generating Word-readable text documents. The simplest way to do so is using the Rich Text Format (RTF) document format. This format was invented by Microsoft and it has since become a standard.</div><div class=""> </div><div class="delete">web2py includes gluon.contrib.pyrtf, developed by Simon Cusack and revised by Grant Edwards. This module allows you to generate RTF documents programmatically<span class="highlight"></span> including colored formatted text and pictures.</div><div class=""> </div><div class="delete">In the following example we in<span class="highlight">stan</span>tiate two basic RTF classes, Document and Section, append the latter to the former and insert some dummy text in the latter:</div><div class=""> ``</div><div class=""> def makertf():</div><div class="">     import gluon.contrib.pyrtf as q</div><div class="">     doc=q.Document()</div><div class="">     section=q.Section()</div><div class="">     doc.Sections.append(section)</div><div class="">     section.append(&#x27;Section Title&#x27;)</div><div class="">     section.append(&#x27;web2py is great. &#x27;*100)</div><div class="">     response.headers[&#x27;Content-Type&#x27;]=&#x27;text/rtf&#x27;</div><div class="">     return q.dumps(doc)</div><div class=""> ``:code</div><div class=""> </div><div class=""> In the end the Document is serialized by ``q.dumps(doc)``. Notice that before returning an RTF document it is necessary to specify the content-type in the header else the browser does not know how to handle the file.</div><div class=""> </div><div class=""> Depending on the configuration, the browser may ask you whether to save this file or open it using a text editor.</div><div class=""> </div><div class=""> #### ReportLab and PDF</div><div class=""> ``ReportLab``:inxx ``PDF``:inxx</div><div class=""> </div><div class=""> web2py can also generate PDF documents, with an additional library called &quot;ReportLab&quot;``ReportLab``:cite .</div><div class=""> In the case of web2py each request can be split into three parts:</div><div class=""> ``</div><div class=""> http://127.0.0.1/myapp/default/api/</div><div class=""> ``</div><div class=""> - The name of the resource (``person``, ``persons``, ``person/1``, etc.)</div><div class=""> - The communication protocol specified y the extension.</div><div class=""> </div><div class=""> Notice that we can always use the router to eliminate any unwanted prefix in the URL and for example simplify this:</div><div class=""> </div><div class=""> ``</div><div class=""> http://127.0.0.1/myapp/default/api/person/1.json</div><div class=""> ``</div><div class=""> </div><div class=""> into this:</div><div class=""> </div><div class=""> ``</div><div class=""> http://127.0.0.1/api/person/1.json</div><div class=""> ``</div><div class=""> </div><div class=""> yet this is a matter of test and we have already discussed it at length in chapter 4.</div><div class=""> </div><div class="delete">In our example we used an action called ``api`` but this is not a requirement. We can in fact name the action that exposes the RESTful service any way we like and we can in fact even create more than one. For the sa<span class="highlight">me of the</span> argument we will continue to assume that our RESTful action is called ``api``.</div><div class=""> </div><div class=""> We will also assume we have defined the following two tables:</div><div class=""> </div><div class=""> ``</div><div class=""> db.define_table(&#x27;person&#x27;,Field(&#x27;name&#x27;),Field(&#x27;info&#x27;))</div><div class=""> db.define_table(&#x27;pet&#x27;,Field(&#x27;owner&#x27;,db.person),Field(&#x27;name&#x27;),Field(&#x27;info&#x27;))</div><div class=""> ``</div><div class=""> </div><div class=""> and they are the resources we want to expose.</div><div class=""> </div><div class=""> The first thing we do is create the RESTful action:</div><div class=""> </div><div class=""> ``</div><div class=""> def api():</div><div class="">     return locals()</div><div class=""> ``</div><div class=""> </div><div class=""> Now we modify it so that the extension is filtered out of the request args (so that ``request.args`` can be used to identify the resource) and so that it can handle the different methods separately:</div><div class=""> </div><div class=""> ``</div><div class=""> which for out ``person`` and ``pet`` tables results in:</div><div class="">    &quot;/person/info/pet[pet.owner]/owner/{pet.owner}&quot;,</div><div class="">    &quot;/person/info/pet[pet.owner]/owner/{pet.owner}/:field&quot;,</div><div class="">    &quot;/pet[pet]&quot;,</div><div class="">    &quot;/pet/id/{pet.id}&quot;,</div><div class="">    &quot;/pet/id/{pet.id}/:field&quot;,</div><div class="">    &quot;/pet/owner/{pet.owner}&quot;,</div><div class="">    &quot;/pet/owner/{pet.owner}/:field&quot;</div><div class=""> ]}</div><div class=""> ``</div><div class=""> </div><div class=""> You can specify auto patterns for some tables only:</div><div class=""> </div><div class=""> ``</div><div class=""> patterns = [&#x27;:auto[person]&#x27;,&#x27;:auto[pet]&#x27;]</div><div class=""> ``</div><div class=""> </div><div class=""> #### ``smart_query`` (experimental)</div><div class=""> </div><div class=""> ``smart_query``:inxx</div><div class=""> </div><div class="delete">There are time<span class="highlight"></span> when you need more flexibility and you want to be able to pass to a RESTful service an arbitrary query like</div></div></div>
</div>
<hr />





        
      </div>

      <div id="push"></div>
    </div>

    <div id="footer">
      <div class="container-fluid">
          <div class="copyright pull-left">Copyright &#169; 2014</div>
          <div id="poweredBy" class="pull-right">
              Powered by
              <a href="http://www.web2py.com/">web2py</a>
          </div>
      </div>
    </div>
<script src="static/js/bootstrap.min.js"></script>
<script src="static/js/web2py_bootstrap.js"></script>
</body>
</html>
