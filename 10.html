<!DOCTYPE html>
<!-- paulirish.com/2008/conditional-stylesheets-vs-css-hacks-answer-neither/ -->
<!--[if lt IE 7]><html class="ie ie6 ie-lte9 ie-lte8 ie-lte7 no-js" lang="en-us"> <![endif]-->
<!--[if IE 7]><html class="ie ie7 ie-lte9 ie-lte8 ie-lte7 no-js" lang="en-us"> <![endif]-->
<!--[if IE 8]><html class="ie ie8 ie-lte9 ie-lte8 no-js" lang="en-us"> <![endif]-->
<!--[if IE 9]><html class="ie9 ie-lte9 no-js" lang="en-us"> <![endif]-->
<!--[if (gt IE 9)|!(IE)]><!--> <html class="no-js" lang="en-us"> <!--<![endif]-->
<head>
  <meta charset="utf-8" />
  <!-- www.phpied.com/conditional-comments-block-downloads/ -->
  <!-- Always force latest IE rendering engine
       (even in intranet) & Chrome Frame
       Remove this if you use the .htaccess -->
  <!--[if IE]>
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <![endif]-->

  <title>Diffbook</title>

  <!-- http://dev.w3.org/html5/markup/meta.name.html -->
  <meta name="application-name" content="diffbook" />

  <!-- Speaking of Google, don't forget to set your site up:
       http://google.com/webmasters -->
  <meta name="google-site-verification" content="" />

  <!--  Mobile Viewport Fix
        j.mp/mobileviewport & davidbcalhoun.com/2010/viewport-metatag
        device-width: Occupy full width of the screen in its current orientation
        initial-scale = 1.0 retains dimensions instead of zooming out if page height > device height
        user-scalable = yes allows the user to zoom in -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <link rel="shortcut icon" href="static/images/favicon.ico" type="image/x-icon">
  <link rel="apple-touch-icon" href="static/images/favicon.png">

  <!-- All JavaScript at the bottom, except for Modernizr which enables
       HTML5 elements & feature detects -->
  <script src="static/js/modernizr.custom.js"></script>

  <!-- include stylesheets -->
  

  <script type="text/javascript"><!--
    // These variables are used by the web2py_ajax_init function in web2py_ajax.js (which is loaded below).
    var w2p_ajax_confirm_message = "Are you sure you want to delete this object?";
    var w2p_ajax_date_format = "%Y-%m-%d";
    var w2p_ajax_datetime_format = "%Y-%m-%d %H:%M:%S";
    //--></script>
<meta name="keywords" content="web2py, python, framework" />

<meta name="description" content="a cool new app" />

<meta name="generator" content="Web2py Web Framework" />

<meta name="author" content="Your Name &lt;you@example.com&gt;" />
<script src="static/js/jquery.js" type="text/javascript"></script><link href="static/css/calendar.css" rel="stylesheet" type="text/css" /><script src="static/js/calendar.js" type="text/javascript"></script><script src="static/js/web2py.js" type="text/javascript"></script><link href="static/css/web2py.css" rel="stylesheet" type="text/css" /><link href="static/css/bootstrap.min.css" rel="stylesheet" type="text/css" /><link href="static/css/bootstrap-responsive.min.css" rel="stylesheet" type="text/css" /><link href="static/css/web2py_bootstrap.css" rel="stylesheet" type="text/css" />


  

  <!-- uncomment here to load jquery-ui
       <link rel="stylesheet" href="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8.16/themes/base/jquery-ui.css" type="text/css" media="all" />
       <script src="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8.16/jquery-ui.min.js" type="text/javascript"></script>
       uncomment to load jquery-ui //-->
  <noscript><link href="static/css/web2py_bootstrap_nojs.css" rel="stylesheet" type="text/css" /></noscript>
  
  <style type="text/css">

      /* Sticky footer styles
      -------------------------------------------------- */

      html,
      body {
        height: 100%;
        /* The html and body elements cannot have any padding or margin. */
      }

      /* Wrapper for page content to push down footer */
      #wrap {
        min-height: 100%;
        height: auto !important;
        height: 100%;
        /* Negative indent footer by it's height */
        margin: 0 auto -60px;
      }

      /* Set the fixed height of the footer here */
      #push,
      #footer {
        height: 60px;
      }
      #footer {
        background-color: #f5f5f5;
      }

      /* Lastly, apply responsive CSS fixes as necessary */
      @media (max-width: 767px) {
        #footer {
          margin-left: -20px;
          margin-right: -20px;
          padding-left: 20px;
          padding-right: 20px;
        }
      }



      /* Custom page CSS
      -------------------------------------------------- */
      /* Not required for template or sticky footer method. */

      .container {
        width: auto;
        max-width: 680px;
      }
      .container .credit {
        margin: 20px 0;
      }

    </style>
</head>

<body>
  
  <body>


    <!-- Part 1: Wrap all page content here -->
    <div id="wrap">

      <!-- Begin page content -->
      <div class="container-fluid">
        <div class="page-header">
          	<h1>
              Diffbook
              <small>easy? diffbook</small>
            </h1>
        </div>
        
        

<div class="pagination">
  <ul>    

      <li><a href="/diffbook/0.html">Chapter 0</a></li>

      <li><a href="/diffbook/1.html">Chapter 1</a></li>

      <li><a href="/diffbook/2.html">Chapter 2</a></li>

      <li><a href="/diffbook/3.html">Chapter 3</a></li>

      <li><a href="/diffbook/4.html">Chapter 4</a></li>

      <li><a href="/diffbook/5.html">Chapter 5</a></li>

      <li><a href="/diffbook/6.html">Chapter 6</a></li>

      <li><a href="/diffbook/7.html">Chapter 7</a></li>

      <li><a href="/diffbook/8.html">Chapter 8</a></li>

      <li><a href="/diffbook/9.html">Chapter 9</a></li>

      <li><a href="/diffbook/10.html">Chapter 10</a></li>

      <li><a href="/diffbook/11.html">Chapter 11</a></li>

      <li><a href="/diffbook/12.html">Chapter 12</a></li>

  </ul>
</div>

<div class="pagination">
  <ul>    

      <li><a href="#com_e592e03bad4f2611839574a894a9046fed5d8358">e592e03</a></li>

      <li><a href="#com_730243d39a6e2e29d00947ac3ae5c74c188a7bf4">730243d</a></li>

      <li><a href="#com_097d699dc16179206ccb7e4aee863d6523cd471c">097d699</a></li>

      <li><a href="#com_08ea49aa89ef98c086c6affa5a2a8f52caac070d">08ea49a</a></li>

      <li><a href="#com_2ac6ed57e8011e0c6032d851d303ba7c00ca6cd4">2ac6ed5</a></li>

  </ul>
</div>



<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/e592e03bad4f2611839574a894a9046fed5d8358">e592e03</a><ul><li>Date : 2012-09-14</li><li>fixed typo in animal example</li></ul></li></ul>
<div class="row-fluid" id="com_e592e03bad4f2611839574a894a9046fed5d8358">
    <div class="span6"><pre style="background-color: #DFF0D8;">Consider the following model:
``
db.define_table(&#x27;animal&#x27;,
    Field(&#x27;species&#x27;),
    Field(&#x27;genus&#x27;),
    Field(&#x27;family&#x27;))
``:code
</pre></div>
    <div class="span6"><pre style="background-color: #F2DEDE;">Consider the following model:
``
db.define_model(&#x27;animal&#x27;,
    Field(&#x27;species&#x27;),
    Field(&#x27;genus&#x27;),
    Field(&#x27;family&#x27;))
``:code
</pre></div>
</div>
<hr />

<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/730243d39a6e2e29d00947ac3ae5c74c188a7bf4">730243d</a><ul><li>Date : 2012-11-27</li><li>fix typo</li></ul></li></ul>
<div class="row-fluid" id="com_730243d39a6e2e29d00947ac3ae5c74c188a7bf4">
    <div class="span6"><pre style="background-color: #DFF0D8;">``
&gt;&gt;&gt; from gluon.contrib.simplejsonrpc import ServerProxy
&gt;&gt;&gt; URL = &quot;http://127.0.0.1:8000/app/default/call/jsonrpc&quot;
&gt;&gt;&gt; service = ServerProxy(URL, verbose=True)
&gt;&gt;&gt; print service.add(1, 2)
``:code

#### JSONRPC and Pyjamas
``JSONRPC``:inxx ``Pyjamas``:inxx

JSONRPC is very similar to XMLRPC, but uses the JSON-based protocol instead of XML to encode the data. As an example of application here, we discuss its usage with Pyjamas. Pyjamas is a Python port of the Google Web Toolkit (originally written in Java). Pyjamas allows writing a client application in Python. Pyjamas translates this code into JavaScript. web2py serves the JavaScript and communicates with it via AJAX requests originating from the client and triggered by user actions.

Here we describe how to make Pyjamas work with web2py. It does not require any additional libraries other than web2py and Pyjamas.

We are going to build a simple &quot;todo&quot; application with a Pyjamas client (all JavaScript) that talks to the server exclusively via JSONRPC.

First, create a new application called &quot;todo&quot;.

Second, in &quot;models/db.py&quot;, enter the following code:
``
db=DAL(&#x27;sqlite://storage.sqlite&#x27;)
db.define_table(&#x27;todo&#x27;, Field(&#x27;task&#x27;))
service = Service()
``:code

&#x27;&#x27;(Note: Service class is from gluon.tools).&#x27;&#x27;

Third, in &quot;controllers/default.py&quot;, enter the following code:
``
    def index():
    redirect(URL(&#x27;todoApp&#x27;))

class TodoApp:
    def onRemoteError(self, code, message, request_info):
        self.Status.setText(&quot;Server Error or Invalid Response: &quot; \
                            + &quot;ERROR &quot; + code + &quot; - &quot; + message)

class DataService(JSONProxy):
    def __init__(self):
        JSONProxy.__init__(self, &quot;../../default/call/jsonrpc&quot;,
                           [&quot;getTasks&quot;, &quot;addTask&quot;,&quot;deleteTask&quot;])

if __name__ == &#x27;__main__&#x27;:
    app = TodoApp()
    app.onModuleLoad()
``:code

Sixth, run Pyjamas before serving the application:
``
cd /path/to/todo/static/
python /python/pyjamas-0.5p1/bin/pyjsbuild TodoApp.py
``:code

This will translate the Python code into JavaScript so that it can be executed in the browser.

To access this application, visit the URL:

``
http://127.0.0.1:8000/todo/default/todoApp
``:code

This subsection was created by Chris Prinos with help from Luke Kenneth Casson Leighton (creators of Pyjamas), updated by Alexei Vinidiktov. It has been tested with Pyjamas 0.5p1. The example was inspired by this Django page in ref.``blogspot1``:cite.

#### AMFRPC
``PyAMF``:inxx ``Adobe Flash``:inxx
</pre></div>
    <div class="span6"><pre style="background-color: #F2DEDE;">``
&gt;&gt;&gt; from gluon.contrib.simplejsonrpc import
&gt;&gt;&gt; URL = &quot;http://127.0.0.1:8000/app/default/call/jsonrpc&quot;
&gt;&gt;&gt; service = ServerProxy(URL, verbose=True)
&gt;&gt;&gt; print service.add(1, 2)
``:code

#### JSONRPC and Pyjamas
``JSONRPC``:inxx ``Pyjamas``:inxx

JSONRPC is very similar to XMLRPC, but uses the JSON-based protocol instead of XML to encode the data. As an example of application here, we discuss its usage with Pyjamas. Pyjamas is a Python port of the Google Web Toolkit (originally written in Java). Pyjamas allows writing a client application in Python. Pyjamas translates this code into JavaScript. web2py serves the JavaScript and communicates with it via AJAX requests originating from the client and triggered by user actions.

Here we describe how to make Pyjamas work with web2py. It does not require any additional libraries other than web2py and Pyjamas.

We are going to build a simple &quot;todo&quot; application with a Pyjamas client (all JavaScript) that talks to the server exclusively via JSONRPC.

First, create a new application called &quot;todo&quot;.

Second, in &quot;models/db.py&quot;, enter the following code:
``
db=DAL(&#x27;sqlite://storage.sqlite&#x27;)
db.define_table(&#x27;todo&#x27;, Field(&#x27;task&#x27;))
service = Service()
``:code

&#x27;&#x27;(Note: Service class is from gluon.tools).&#x27;&#x27;

Third, in &quot;controllers/default.py&quot;, enter the following code:
``
    def index():
    redirect(URL(&#x27;todoApp&#x27;))

class TodoApp:
    def onRemoteError(self, code, message, request_info):
        self.Status.setText(&quot;Server Error or Invalid Response: &quot; \
                            + &quot;ERROR &quot; + code + &quot; - &quot; + message)

class DataService(JSONProxy):
    def __init__(self):
        JSONProxy.__init__(self, &quot;../../default/call/jsonrpc&quot;,
                           [&quot;getTasks&quot;, &quot;addTask&quot;,&quot;deleteTask&quot;])

if __name__ == &#x27;__main__&#x27;:
    app = TodoApp()
    app.onModuleLoad()
``:code

Sixth, run Pyjamas before serving the application:
``
cd /path/to/todo/static/
python /python/pyjamas-0.5p1/bin/pyjsbuild TodoApp.py
``:code

This will translate the Python code into JavaScript so that it can be executed in the browser.

To access this application, visit the URL:

``
http://127.0.0.1:8000/todo/default/todoApp
``:code

This subsection was created by Chris Prinos with help from Luke Kenneth Casson Leighton (creators of Pyjamas), updated by Alexei Vinidiktov. It has been tested with Pyjamas 0.5p1. The example was inspired by this Django page in ref.``blogspot1``:cite.

#### Amfrpc
``PyAMF``:inxx ``Adobe Flash``:inxx
</pre></div>
</div>
<hr />

<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/097d699dc16179206ccb7e4aee863d6523cd471c">097d699</a><ul><li>Date : 2012-12-27</li><li>fixed typo, thanks Andrew</li></ul></li></ul>
<div class="row-fluid" id="com_097d699dc16179206ccb7e4aee863d6523cd471c">
    <div class="span6"><pre style="background-color: #DFF0D8;">``
@request.restful()
def api():
    response.view = &#x27;generic.json&#x27;
    def GET(tablename,id):
        if not tablename==&#x27;person&#x27;: raise HTTP(400)
        return dict(person = db.person(id))
    def POST(tablename,**fields):
        if not tablename==&#x27;person&#x27;: raise HTTP(400)
        return db.person.validate_and_insert(**fields)
    return locals()
``

Notice that:
- the GET and POST are dealt with by different functions
- the function expect the correct arguments (un-named arguments parsed by ``request.args`` and named arguments are from ``request.vars``)
- they check the input is correct and eventually raise an exception
- GET perform a select and returns the record, ``db.person(id)``. The output is automatically converted to JSON because the generic view is called.
- POST performs a ``validate_and_insert(..)`` and returns the ``id`` of the new record or, alternatively, validation errors. The POST variables, ``**fields``, are the post variables.

#### ``parse_as_rest`` (experimental)

The logic explained so far is sufficient to create any type of RESTful web service yet web2py helps us even more.

In fact, web2py provides a syntax to describe which database tables we want to expose and how to map resource into URLs and vice versa.

``parse_as_rest``:inxx

This is done using URL patterns.
A pattern is a string that maps the request args from a URL into a database query.
There 4 types of atomic patterns:

- String constants for example &quot;friend&quot;
- String constant corresponding to a table. For example &quot;friend[person]&quot; will match &quot;friends&quot; in the URL to the &quot;person&quot; table.
- Variables to be used to filter. For example &quot;{person.id}&quot; will apply a ``db.person.name=={person.id}`` filter.
- Names of fields, represented by &quot;:field&quot;

which for out ``person`` and ``pet`` tables results in:
   &quot;/pet/owner/{pet.owner}&quot;,
   &quot;/pet/owner/{pet.owner}/:field&quot;
]}
``

You can specify auto patterns for some tables only:

``
patterns = [&#x27;:auto[person]&#x27;,&#x27;:auto[pet]&#x27;]
``

#### ``smart_query`` (experimental)

``smart_query``:inxx

There are times when you need more flexibility and you want to be able to pass to a RESTful service an arbitrary query like

``
http://.../api.json?search=person.name starts with &#x27;T&#x27; and person.name contains &#x27;m&#x27;
``

You can do this using

``
@request.restful()
def api():
    response.view = &#x27;generic.&#x27;+request.extension
    def GET(search):
        try:
            rows = db.smart_query([db.person,db.pet],search).select()
            return dict(result=rows)
        except RuntimeError:
            raise HTTP(400,&quot;Invalid search string&quot;)
    def POST(table_name,**vars):
        return db[table_name].validate_and_insert(**vars)
    return locals()
``

The method ``db.smart_query`` takes two arguments:
- a list of field or table that should be allowed in the query
- a string containing the query expressed in natural language
and it returns a ``db.set`` object with the records that have been found.

Notice that the search string is parsed, not evaluated or executed and therefore it provides no security risk.


#### Access Control

Access to the API can be restricted as usual by using decorators. So, for example

``
auth.settings.allow_basic_login = True

@auth.requires_login()
@request.restful()
def api():
   def GET(s):
       return &#x27;access granted, you said %s&#x27; % s
   return locals()
``

In the previous chapter we have discussed the use of the following decorators:
@auth.requires_permission(...)
``:code

For normal actions (not decorated as services), these decorators can be used even if the output is rendered in a format other than HTML.

For functions defined as services and decorated using the ``@service...`` decorators, the ``@auth...`` decorators should not be used. The two types of decorators cannot be mixed. If authentication is to be performed, it is the ``call`` actions that needs to be decorated:
``
@auth.requires_login()
def call(): return service()
``:code

Notice that it also possible to instantiate multiple service objects, register the same different functions with them, and expose some of them with authentication and some not:
``
public_services=Service()
private_services=Service()

@public_service.jsonrpc
@private_service.jsonrpc
def f(): return &#x27;public&#x27;

@private_service.jsonrpc
def g(): return &#x27;private&#x27;

def public_call(): return public_service()

@auth.requires_login()
def private_call(): return private_service()
``:code

This assumes that the caller is passing credentials in the HTTP header (a valid session cookie or using basic authentication, as discussed in the previous section). The client must support it; not all clients do.
</pre></div>
    <div class="span6"><pre style="background-color: #F2DEDE;">``
@request.restful()
def api():
    response.view = &#x27;generic.json&#x27;
    def GET(tablename,id):
        if not tablename==&#x27;person&#x27;: raise HTTP(400)
	return dict(person = db.person(id))
    def POST(tablename,**fields):
        if not tablename==&#x27;person&#x27;: raise HTTP(400)
        return db.person.validate_and_insert(**fields)
    return locals()
``

Notice that:
- the GET and POST are dealt with by different functions
- the function expect the correct arguments (un-named arguments parsed by ``request.args`` and named arguments are from ``request.vars``)
- they check the input is correct and eventually raise an exception
- GET perform a select and returns the record, ``db.person(id)``. The output is automatically converted to JSON because the generic view is called.
- POST performs a ``validate_and_insert(..)`` and returns the ``id`` of the new record or, alternatively, validation errors. The POST variables, ``**fields``, are the post variables.

#### ``parse_as_rest`` (experimental)

The logic explained so far is sufficient to create any type of RESTful web service yet web2py helps us even more.

In fact, web2py provides a syntax to describe which database tables we want to expose and how to map resource into URLs and vice versa.

``parse_as_rest``:inxx

This is done using URL patterns.
A pattern is a string that maps the request args from a URL into a database query.
There 4 types of atomic patterns:

- String constants for example &quot;friend&quot;
- String constant corresponding to a table. For example &quot;friend[person]&quot; will match &quot;friends&quot; in the URL to the &quot;person&quot; table.
- Variables to be used to filter. For example &quot;{person.id}&quot; will apply a ``db.person.name=={person.id}`` filter.
- Names of fields, represented by &quot;:field&quot;

which for out ``person`` and ``pet`` tables results in:
   &quot;/pet/owner/{pet.owner}&quot;,
   &quot;/pet/owner/{pet.owner}/:field&quot;
]}
``

You can specify auto patterns for some tables only:

``
patterns = [&#x27;:auto[person]&#x27;,&#x27;:auto[pet]&#x27;]
``

#### ``smart_query`` (experimental)

``smart_query``:inxx

There are times when you need more flexibility and you want to be able to pass to a RESTful service an arbitrary query like

``
http://.../api.json?search=person.name starts with &#x27;T&#x27; and person.name contains &#x27;m&#x27;
``

You can do this using

``
@request.restful()
def api():
    response.view = &#x27;generic.&#x27;+request.extension
    def GET(search):
        try:
            rows = db.smart_query([db.person,db.pet],search).select()
	    return dict(result=rows)
        except RuntimeError:
            raise HTTP(400,&quot;Invalid search string&quot;)
    def POST(table_name,**vars):
        return db[table_name].validate_and_insert(**vars)
    return locals()
``

The method ``db.smart_query`` takes two arguments:
- a list of field or table that should be allowed in the query
- a string containing the query expressed in natural language
and it returns a ``db.set`` object with the records that have been found.

Notice that the search string is parsed, not evaluated or executed and therefore it provides no security risk.


#### Access Control

Access to the API can be restricted as usual by using decorators. So, for example

``
auth.settings.allow_basic_login = True

@auth.requires_login()
@request.restful()
def api():
   def GET(s):
       return &#x27;access granted, you said %s&#x27; % s
   return locals()
``

In the previous chapter we have discussed the use of the following decorators:
@auth.requires_permission(...)
``:code

For normal actions (not decorated as services), these decorators can be used even if the output is rendered in a format other than HTML.

For functions defined as services and decorated using the ``@service...`` decorators, the ``@auth...`` decorators should not be used. The two types of decorators cannot be mixed. If authentication is to be performed, it is the ``call`` actions that needs to be decorated:
``
@auth.requires_login()
def call(): return service()
``:code

Notice that it also possible to instantiate multiple service objects, register the same different functions with them, and expose some of them with authentication and some not:
``
public_services=Service()
private_services=Service()

@public_service.jsonrpc
@private_service.jsonrpc
def f(): return &#x27;public&#x27;

@private_service.jsonrpc
def g(): return &#x27;private&#x27;

def public_call(): return public_service()

@auth.requires_login()
def private_call(): return private_service()
``:code

This assumes that the caller is passing credentials in the HTTP header (a valid session cookie or using basic authentication, as discussed in the previous section). The client must support it; not all clients do.


</pre></div>
</div>
<hr />

<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/08ea49aa89ef98c086c6affa5a2a8f52caac070d">08ea49a</a><ul><li>Date : 2013-01-21</li><li>jsonrpc2</li></ul></li></ul>
<div class="row-fluid" id="com_08ea49aa89ef98c086c6affa5a2a8f52caac070d">
    <div class="span6"><pre style="background-color: #DFF0D8;">Third, you must decorate those functions you want to expose as a service. Here is a list of currently supported decorators:
``
@service.run
@service.xml
@service.json
@service.rss
@service.csv
@service.xmlrpc
@service.jsonrpc
@service.jsonrpc2
@service.amfrpc3(&#x27;domain&#x27;)
@service.soap(&#x27;FunctionName&#x27;,returns={&#x27;result&#x27;:type},args={&#x27;param1&#x27;:type,})
``:code

As an example, consider the following decorated function:
``
@service.run
def concat(a,b):
    return a+b
``:code

This function can be defined in a model or in the controller where the ``call`` action is defined. This function can now be called remotely in two ways:

``
http://127.0.0.1:8000/app/default/call/run/concat?a=hello&amp;b=world
http://127.0.0.1:8000/app/default/call/run/concat/hello/world
``:code

In both cases the http request returns:
``
helloworld
``:code

If the ``@service.xml`` decorator is used, the function can be called via:

``
http://127.0.0.1:8000/app/default/call/xml/concat?a=hello&amp;b=world
http://127.0.0.1:8000/app/default/call/xml/concat/hello/world
``:code

Now in a python shell you can do
       &#x27;http://127.0.0.1:8000/app/default/call/xmlrpc&#x27;)
&gt;&gt;&gt; print server.add(3,4)
7
&gt;&gt;&gt; print server.add(&#x27;hello&#x27;,&#x27;world&#x27;)
&#x27;helloworld&#x27;
&gt;&gt;&gt; print server.div(12,4)
3
&gt;&gt;&gt; print server.div(1,0)
ZeroDivisionError: integer division or modulo by zero
``:code

The Python xmlrpclib module provides a client for the XMLRPC protocol. web2py acts as the server.

The client connects to the server via ServerProxy and can remotely call decorated functions in the server. The data (a,b) is passed to the function(s), not via GET/POST variables, but properly encoded in the request body using the XMLPRC protocol, and thus it carries with itself type information (int or string or other). The same is true for the return value(s). Moreover, any exception raised on the server propagates back to the client.

There are XMLRPC libraries for many programming languages (including C, C++, Java, C#, Ruby, and Perl), and they can interoperate with each other. This is one the best methods to create applications that talk to each other independent of the programming language.

The XMLRPC client can also be implemented inside a web2py action, so that one action can talk to another web2py application (even within the same installation) using XMLRPC. Beware of session deadlocks in this case. If an action calls via XMLRPC a function in the same app, the caller must release the session lock before the call:
``
session.forget(response)
``:code

#### JSONRPC

``JSONRPC``:inxx

In this section we are going to use the same code example as for XMLRPC but we will expose the service using JSONRPC instead:

``
@service.jsonrpc
@service.jsonrpc2
def add(a,b):
    return a+b

def call():
    return service()
``:code

JSONRPC is very similar to XMLRPC but uses JSON instead of XML as data serialization protocol.

Of course we can call the service from any program in any language but here we will do it in Python. web2py ships with a module &quot;gluon/contrib/simplejsonrpc.py&quot; created by Mariano Reingart. Here is an example of how to use to call the above service:

``
&gt;&gt;&gt; from gluon.contrib.simplejsonrpc import ServerProxy
&gt;&gt;&gt; URL = &quot;http://127.0.0.1:8000/app/default/call/jsonrpc&quot;
&gt;&gt;&gt; service = ServerProxy(URL, verbose=True)
&gt;&gt;&gt; print service.add(1, 2)
``:code

Use &quot;http://127.0.0.1:8000/app/default/call/jsonrpc2&quot; for jsonrpc2.

#### JSONRPC and Pyjamas
``JSONRPC``:inxx ``Pyjamas``:inxx
</pre></div>
    <div class="span6"><pre style="background-color: #F2DEDE;">Third, you must decorate those functions you want to expose as a service. Here is a list of currently supported decorators:
``
@service.run
@service.xml
@service.json
@service.rss
@service.csv
@service.xmlrpc
@service.jsonrpc
@service.amfrpc3(&#x27;domain&#x27;)
@service.soap(&#x27;FunctionName&#x27;,returns={&#x27;result&#x27;:type},args={&#x27;param1&#x27;:type,})
``:code

As an example, consider the following decorated function:
``
@service.run
def concat(a,b):
    return a+b
``:code

This function can be defined in a model or in the controller where the ``call`` action is defined. This function can now be called remotely in two ways:

``
http://127.0.0.1:8000/app/default/call/run/concat?a=hello&amp;b=world
http://127.0.0.1:8000/app/default/call/run/concat/hello/world
``:code

In both cases the http request returns:
``
helloworld
``:code

If the ``@service.xml`` decorator is used, the function can be called via:

``
http://127.0.0.1:8000/app/default/call/xml/concat?a=hello&amp;b=world
http://127.0.0.1:8000/app/default/call/xml/concat/hello/world
``:code

Now in a python shell you can do
       &#x27;http://127.0.0.1:8000/app/default/call/xmlrpc&#x27;)
&gt;&gt;&gt; print server.add(3,4)
7
&gt;&gt;&gt; print server.add(&#x27;hello&#x27;,&#x27;world&#x27;)
&#x27;helloworld&#x27;
&gt;&gt;&gt; print server.div(12,4)
3
&gt;&gt;&gt; print server.div(1,0)
ZeroDivisionError: integer division or modulo by zero
``:code

The Python xmlrpclib module provides a client for the XMLRPC protocol. web2py acts as the server.

The client connects to the server via ServerProxy and can remotely call decorated functions in the server. The data (a,b) is passed to the function(s), not via GET/POST variables, but properly encoded in the request body using the XMLPRC protocol, and thus it carries with itself type information (int or string or other). The same is true for the return value(s). Moreover, any exception raised on the server propagates back to the client.

There are XMLRPC libraries for many programming languages (including C, C++, Java, C#, Ruby, and Perl), and they can interoperate with each other. This is one the best methods to create applications that talk to each other independent of the programming language.

The XMLRPC client can also be implemented inside a web2py action, so that one action can talk to another web2py application (even within the same installation) using XMLRPC. Beware of session deadlocks in this case. If an action calls via XMLRPC a function in the same app, the caller must release the session lock before the call:
``
session.forget(response)
``:code

#### JSONRPC

``JSONRPC``:inxx

In this section we are going to use the same code example as for XMLRPC but we will expose the service using JSONRPC instead:

``
@service.jsonrpc
def add(a,b):
    return a+b

def call():
    return service()
``:code

JSONRPC is very similar to XMLRPC but uses JSON instead of XML as data serialization protocol.

Of course we can call the service from any program in any language but here we will do it in Python. web2py ships with a module &quot;gluon/contrib/simplejsonrpc.py&quot; created by Mariano Reingart. Here is an example of how to use to call the above service:

``
&gt;&gt;&gt; from gluon.contrib.simplejsonrpc import ServerProxy
&gt;&gt;&gt; URL = &quot;http://127.0.0.1:8000/app/default/call/jsonrpc&quot;
&gt;&gt;&gt; service = ServerProxy(URL, verbose=True)
&gt;&gt;&gt; print service.add(1, 2)
``:code

#### JSONRPC and Pyjamas
``JSONRPC``:inxx ``Pyjamas``:inxx
</pre></div>
</div>
<hr />

<ul><li><a href="https://github.com/mdipierro/web2py-book/commit/2ac6ed57e8011e0c6032d851d303ba7c00ca6cd4">2ac6ed5</a><ul><li>Date : 2012-09-11</li><li>Update sources/29-web2py-english/10.markmin</li></ul></li></ul>
<div class="row-fluid" id="com_2ac6ed57e8011e0c6032d851d303ba7c00ca6cd4">
    <div class="span6"><pre style="background-color: #DFF0D8;">## Services
``Web Services``:inxx ``API``:inxx

The W3C defines a web service as &quot;a software system designed to support interoperable machine-to-machine interaction over a network&quot;. This is a broad definition, and it encompasses a large number of protocols designed not for machine-to-human communication, but for machine-to-machine communication such as XML, JSON, RSS, etc.

In this chapter we discuss how to expose web services using web2py. If you are interested in examples of consuming third party services (Twitter, Dropbox, etc.) you should look into Chapter 9 and Chapter 14.

web2py provides, out of the box, support for many protocols, including XML, JSON, RSS, CSV, XMLRPC, JSONRPC, AMFRPC, and SOAP. web2py can also be extended to support additional protocols.

Each of those protocols are supported in multiple ways, and we make a distinction between:
- Rendering the output of a function in a given format (for example XML, JSON, RSS, CSV)
- Remote Procedure Calls (for example XMLRPC, JSONRPC, AMFRPC)

### Rendering a dictionary

#### HTML, XML, and JSON
``HTML``:inxx ``XML``:inxx ``JSON``:inxx

Consider the following action:
``
def count():
    session.counter = (session.counter or 0) + 1
    return dict(counter=session.counter, now=request.now)
``:code

This action returns a counter that is increased by one when a visitor reloads the page, and the timestamp of the current page request.

Normally this page would be requested via:

``
http://127.0.0.1:8000/app/default/count
``:code

and rendered in HTML. Without writing one line of code, we can ask web2py to render this page using different protocols by adding an extension to the URL:

``
http://127.0.0.1:8000/app/default/count.html
http://127.0.0.1:8000/app/default/count.xml
http://127.0.0.1:8000/app/default/count.json
``:code

The dictionary returned by the action will be rendered in HTML, XML and JSON, respectively.

Here is the XML output:
``
&lt;document&gt;
   &lt;counter&gt;3&lt;/counter&gt;
   &lt;now&gt;2009-08-01 13:00:00&lt;/now&gt;
&lt;/document&gt;
``:code

Here is the JSON output:
``
{ &#x27;counter&#x27;:3, &#x27;now&#x27;:&#x27;2009-08-01 13:00:00&#x27; }
``:code

Notice that date, time and datetime objects are rendered as strings in ISO format. This is not part of the JSON standard, but rather a web2py convention.

#### Generic views

When, for example, the &quot;.xml&quot; extension is called, web2py looks for a template file called &quot;default/count.xml&quot;, and if it does not find it, looks for a template called &quot;generic.xml&quot;.  The files &quot;generic.html&quot;, &quot;generic.xml&quot;, &quot;generic.json&quot; are provided with the current scaffolding application. Other extensions can be easily defined by the user.

------
For security reasons the generic views are only allowed to be accessed on localhost. In order to enable the access from remote clients you may need to set the response.generic_patterns.
------
Assuming you are using a copy of scaffold app, edit the following line in models/db.py

- restrict access only to localhost
``
response.generic_patterns = [&#x27;*&#x27;] if request.is_local else []
``:code

- to allow all generic views
``
response.generic_patterns = [&#x27;*&#x27;]
``:code

- to allow only .json

``
response.generic_patterns = [&#x27;*.json&#x27;]
``:code

The generic_patterns is a glob pattern, it means you can use any patterns that matches with your app actions or pass a list of patterns.

``
response.generic_patterns = [&#x27;*.json&#x27;,&#x27;*.xml&#x27;]
``:code


To use it in an older web2py app, you may need to copy the &quot;generic.*&quot; files from a later scaffolding app (after version 1.60).

Here is the code for &quot;generic.html&quot;
``
{{extend &#x27;layout.html&#x27;}}

def animals():
    return dict(animals=animals)
``:code

web2py does not provide a &quot;generic.csv&quot;; you must define a custom view &quot;default/animals.csv&quot;
that serializes the animals into CSV. Here is a possible implementation:
``
{{
import cStringIO
stream=cStringIO.StringIO()
animals.export_to_csv_file(stream)
response.headers[&#x27;Content-Type&#x27;]=&#x27;application/vnd.ms-excel&#x27;
response.write(stream.getvalue(), escape=False)
}}
``:code

Notice that one could also define a &quot;generic.csv&quot; file, but one would have to specify the name of the object to be serialized (&quot;animals&quot; in the example). This is why we do not provide a &quot;generic.csv&quot; file.

### Remote procedure calls
``RPC``:inxx

web2py provides a mechanism to turn any function into a web service.
The mechanism described here differs from the mechanism described before because:
- The function may take arguments
- The function may be defined in a model or a module instead of controller
- You may want to specify in detail which RPC method should be supported
- It enforces a more strict URL naming convention
- It is smarter than the previous methods because it works for a fixed set of protocols. For the same reason it is not as easily extensible.

To use this feature:

First, you must import and initiate a service object.
``
from gluon.tools import Service
service = Service()
``:code

-------
This is already done in the &quot;db.py&quot; model file in the scaffolding application.
-------

Second, you must expose the service handler in the controller:
``
def call():
    session.forget()
    return service()
``:code

-------
This is already done in the &quot;default.py&quot; controller of the scaffolding application. Remove ``session.forget()`` if you plan to use session cookies with the services.
-------

Third, you must decorate those functions you want to expose as a service. Here is a list of currently supported decorators:
``
@service.run
@service.xml
@service.json
@service.rss
@service.csv
@service.xmlrpc
@service.jsonrpc
@service.amfrpc3(&#x27;domain&#x27;)
SimpleJSON consists of two functions:
- ``gluon.contrib.simplesjson.dumps(a)`` encodes a Python object ``a`` into JSON.
- ``gluon.contrib.simplejson.loads(b)`` decodes a JavaScript object ``b`` into a Python object.

Object types that can be serialized include primitive types, lists, and dictionaries. Compound objects can be serialized with the exception of user defined classes.

Here is a sample action (for example in controller &quot;default.py&quot;) that serializes the Python list containing weekdays using this low level API:
``
def weekdays():
    names=[&#x27;Sunday&#x27;,&#x27;Monday&#x27;,&#x27;Tuesday&#x27;,&#x27;Wednesday&#x27;,
           &#x27;Thursday&#x27;,&#x27;Friday&#x27;,&#x27;Saturday&#x27;]
    import gluon.contrib.simplejson
    return gluon.contrib.simplejson.dumps(names)
``:code

Below is a sample HTML page that sends an Ajax request to the above action, receives the JSON message and stores the list in a corresponding JavaScript variable:
``
{{extend &#x27;layout.html&#x27;}}
&lt;script&gt;
$.getJSON(&#x27;/application/default/weekdays&#x27;,
          function(data){ alert(data); });
&lt;/script&gt;
``:code

The code uses the jQuery function ``$.getJSON``, which performs the Ajax call and, on response, stores the weekdays names in a local JavaScript variable ``data`` and passes the variable to the callback function. In the example the callback function simply alerts the visitor that the data has been received.

#### PyRTF
``PyRTF``:inxx ``RTF``:inxx

Another common need of web sites is that of generating Word-readable text documents. The simplest way to do so is using the Rich Text Format (RTF) document format. This format was invented by Microsoft and it has since become a standard.

web2py includes gluon.contrib.pyrtf, developed by Simon Cusack and revised by Grant Edwards. This module allows you to generate RTF documents programmatically, including colored formatted text and pictures.

In the following example we initiate two basic RTF classes, Document and Section, append the latter to the former and insert some dummy text in the latter:
``
def makertf():
    import gluon.contrib.pyrtf as q
    doc=q.Document()
    section=q.Section()
    doc.Sections.append(section)
    section.append(&#x27;Section Title&#x27;)
    section.append(&#x27;web2py is great. &#x27;*100)
    response.headers[&#x27;Content-Type&#x27;]=&#x27;text/rtf&#x27;
    return q.dumps(doc)
``:code

In the end the Document is serialized by ``q.dumps(doc)``. Notice that before returning an RTF document it is necessary to specify the content-type in the header else the browser does not know how to handle the file.

Depending on the configuration, the browser may ask you whether to save this file or open it using a text editor.

#### ReportLab and PDF
``ReportLab``:inxx ``PDF``:inxx

web2py can also generate PDF documents, with an additional library called &quot;ReportLab&quot;``ReportLab``:cite .

If you are running web2py from source, it is sufficient to have ReportLab installed. If you are running the Windows binary distribution, you need to unzip ReportLab in the &quot;web2py/&quot; folder. If you are running the Mac binary distribution, you need to unzip ReportLab  in the folder:
``
web2py.app/Contents/Resources/
``:code

From now on we assume ReportLab is installed and that web2py can find it.
We will create a simple action called &quot;get_me_a_pdf&quot; that generates a PDF document.
``
from reportlab.platypus import *
A GET request to

``
http://127.0.0.1/myapp/default/api/person/1.json
``

indicates a request for the information associated to ``person/1`` (the record with ``id==1``) and in json format.

In the case of web2py each request can be split into three parts:

- A first part that identify the location of the service, i.e. the action that exposes the service:
``
http://127.0.0.1/myapp/default/api/
``
- The name of the resource (``person``, ``persons``, ``person/1``, etc.)
- The communication protocol specified y the extension.

Notice that we can always use the router to eliminate any unwanted prefix in the URL and for example simplify this:

``
http://127.0.0.1/myapp/default/api/person/1.json
``

into this:

``
http://127.0.0.1/api/person/1.json
``

yet this is a matter of test and we have already discussed it at length in chapter 4.

In our example we used an action called ``api`` but this is not a requirement. We can in fact name the action that exposes the RESTful service any way we like and we can in fact even create more than one. For the sake of argument we will continue to assume that our RESTful action is called ``api``.

We will also assume we have defined the following two tables:

``
db.define_table(&#x27;person&#x27;,Field(&#x27;name&#x27;),Field(&#x27;info&#x27;))
db.define_table(&#x27;pet&#x27;,Field(&#x27;owner&#x27;,db.person),Field(&#x27;name&#x27;),Field(&#x27;info&#x27;))
``

and they are the resources we want to expose.

The first thing we do is create the RESTful action:

``
def api():
    return locals()
``

Now we modify it so that the extension is filtered out of the request args (so that ``request.args`` can be used to identify the resource) and so that it can handle the different methods separately:

``
@request.restful()
def api():
    def GET(*args,**vars):
        return dict()
    def POST(*args,**vars):
        return dict()
    def PUT(*args,**vars):
        return dict()
    def DELETE(*args,**vars):
        return dict()
which for out ``person`` and ``pet`` tables results in:
   &quot;/person/id/{person.id}/pet[pet.owner]/owner/{pet.owner}&quot;,
   &quot;/person/id/{person.id}/pet[pet.owner]/owner/{pet.owner}/:field&quot;,
   &quot;/person/name/pet[pet.owner]&quot;,
   &quot;/person/name/pet[pet.owner]/id/{pet.id}&quot;,
   &quot;/person/name/pet[pet.owner]/id/{pet.id}/:field&quot;,
   &quot;/person/name/pet[pet.owner]/owner/{pet.owner}&quot;,
   &quot;/person/name/pet[pet.owner]/owner/{pet.owner}/:field&quot;,
   &quot;/person/info/pet[pet.owner]&quot;,
   &quot;/person/info/pet[pet.owner]/id/{pet.id}&quot;,
   &quot;/person/info/pet[pet.owner]/id/{pet.id}/:field&quot;,
   &quot;/person/info/pet[pet.owner]/owner/{pet.owner}&quot;,
   &quot;/person/info/pet[pet.owner]/owner/{pet.owner}/:field&quot;,
   &quot;/pet[pet]&quot;,
   &quot;/pet/id/{pet.id}&quot;,
   &quot;/pet/id/{pet.id}/:field&quot;,
   &quot;/pet/owner/{pet.owner}&quot;,
   &quot;/pet/owner/{pet.owner}/:field&quot;
]}
``

You can specify auto patterns for some tables only:

``
patterns = [&#x27;:auto[person]&#x27;,&#x27;:auto[pet]&#x27;]
``

#### ``smart_query`` (experimental)

``smart_query``:inxx

There are times when you need more flexibility and you want to be able to pass to a RESTful service an arbitrary query like
</pre></div>
    <div class="span6"><pre style="background-color: #F2DEDE;">
## Services
``Web Services``:inxx ``API``:inxx

The W3C defines a web service as &quot;a software system designed to support interoperable machine-to-machine interaction over a network&quot;. This is a broad definition, and it encompasses a large number of protocols designed not for machine-to-human communication, but for machine-to-machine communication such as XML, JSON, RSS, etc.

In this chapter we discuss how to expose web services using web2py. If you are interested in examples of consuming third party services (Twitter, Dropbox, etc.) you should look into Chapter 9 and Chapter 14.

web2py provides, out of the box, support for many protocols, including XML, JSON, RSS, CSV, XMLRPC, JSONRPC, AMFRPC, and SOAP. web2py can also be extended to support additional protocols.

Each of those protocols is supported in multiple ways, and we make a distinction between:
- Rendering the output of a function in a given format (for example XML, JSON, RSS, CSV)
- Remote Procedure Calls (for example XMLRPC, JSONRPC, AMFRPC)

### Rendering a dictionary

#### HTML, XML, and JSON
``HTML``:inxx ``XML``:inxx ``JSON``:inxx

Consider the following action:
``
def count():
    session.counter = (session.counter or 0) + 1
    return dict(counter=session.counter, now=request.now)
``:code

This action returns a counter that is increased by one when a visitor reloads the page, and the timestamp of the current page request.

Normally this page would be requested via:

``
http://127.0.0.1:8000/app/default/count
``:code

and rendered in HTML. Without writing one line of code, we can ask web2py to render this page using different protocols by adding an extension to the URL:

``
http://127.0.0.1:8000/app/default/count.html
http://127.0.0.1:8000/app/default/count.xml
http://127.0.0.1:8000/app/default/count.json
``:code

The dictionary returned by the action will be rendered in HTML, XML and JSON, respectively.

Here is the XML output:
``
&lt;document&gt;
   &lt;counter&gt;3&lt;/counter&gt;
   &lt;now&gt;2009-08-01 13:00:00&lt;/now&gt;
&lt;/document&gt;
``:code

Here is the JSON output:
``
{ &#x27;counter&#x27;:3, &#x27;now&#x27;:&#x27;2009-08-01 13:00:00&#x27; }
``:code

Notice that date, time, and datetime objects are rendered as strings in ISO format. This is not part of the JSON standard, but rather a web2py convention.

#### Generic views

When, for example, the &quot;.xml&quot; extension is called, web2py looks for a template file called &quot;default/count.xml&quot;, and if it does not find it, looks for a template called &quot;generic.xml&quot;.  The files &quot;generic.html&quot;, &quot;generic.xml&quot;, &quot;generic.json&quot; are provided with the current scaffolding application. Other extensions can be easily defined by the user.

------
For security reasons the generic views are only allowed to be accessed on localhost. In order to enable the access from remote clients you may need to set the response.generic_patterns.
------
Assuming you are using a copy of scaffold app edit the following line in models/db.py

- restrict access only to localhost
``
response.generic_patterns = [&#x27;*&#x27;] if request.is_local else []
``:code

- to allow all generic views
``
response.generic_patterns = [&#x27;*&#x27;]
``:code

- to allow only .json

``
response.generic_patterns = [&#x27;*.json&#x27;]
``:code

The generic_patterns is a glob pattern, it means you can use any patterns that matches with your app actions or pass a list of patterns.

``
response.generic_patterns = [&#x27;*.json&#x27;,&#x27;*.xml&#x27;]
``:code


To use it in an older web2py app, you may need to copy the &quot;generic.*&quot; files from a later scaffolding app (after version 1.60).

Here is the code for &quot;generic.html&quot;
``
{{extend &#x27;layout.html&#x27;}}

def animals():
    return dict(animals=animals)
``:code

web2py does not provide a &quot;generic.csv&quot;; you must define a custom view &quot;default/animals.csv&quot;
that serializes the animals into CSV. Here is a possible implementation:
``
{{
import cStringIO
stream=cStringIO.StringIO()
animals.export_to_csv_file(stream)
response.headers[&#x27;Content-Type&#x27;]=&#x27;application/vnd.ms-excel&#x27;
response.write(stream.getvalue(), escape=False)
}}
``:code

Notice that one could also define a &quot;generic.csv&quot; file, but one would have to specify the name of the object to be serialized (&quot;animals&quot; in the example). This is why we do not provide a &quot;generic.csv&quot; file.

### Remote procedure calls
``RPC``:inxx

web2py provides a mechanism to turn any function into a web service.
The mechanism described here differs from the mechanism described before because:
- The function may take arguments
- The function may be defined in a model or a module instead of controller
- You may want to specify in detail which RPC method should be supported
- It enforces a more strict URL naming convention
- It is smarter than the previous methods because it works for a fixed set of protocols. For the same reason it is not as easily extensible.

To use this feature:

First, you must import and instantiate a service object.
``
from gluon.tools import Service
service = Service()
``:code

-------
This is already done in the &quot;db.py&quot; model file in the scaffolding application.
-------

Second, you must expose the service handler in the controller:
``
def call():
    session.forget()
    return service()
``:code

-------
This is already done in the &quot;default.py&quot; controller of the scaffolding application. Remove ``session.forget()`` if you plan to use session cookies with the services.
-------

Third, you must decorate those functions you want to expose as a service. Here is a list of currently supported decorators:
``
@service.run
@service.xml
@service.json
@service.rss
@service.csv
@service.xmlrpc
@service.jsonrpc
@service.amfrpc3(&#x27;domain&#x27;)
SimpleJSON consists of two functions:
- ``gluon.contrib.simplesjson.dumps(a)`` encodes a Python object ``a`` into JSON.
- ``gluon.contrib.simplejson.loads(b)`` decodes a JavaScript object ``b`` into a Python object.

Object types that can be serialized include primitive types, lists, and dictionaries. Compound objects can be serialized with the exception of user defined classes.

Here is a sample action (for example in controller &quot;default.py&quot;) that serializes the Python list containing weekdays using this low level API:
``
def weekdays():
    names=[&#x27;Sunday&#x27;,&#x27;Monday&#x27;,&#x27;Tuesday&#x27;,&#x27;Wednesday&#x27;,
           &#x27;Thursday&#x27;,&#x27;Friday&#x27;,&#x27;Saturday&#x27;]
    import gluon.contrib.simplejson
    return gluon.contrib.simplejson.dumps(names)
``:code

Below is a sample HTML page that sends an Ajax request to the above action, receives the JSON message and stores the list in a corresponding JavaScript variable:
``
{{extend &#x27;layout.html&#x27;}}
&lt;script&gt;
$.getJSON(&#x27;/application/default/weekdays&#x27;,
          function(data){ alert(data); });
&lt;/script&gt;
``:code

The code uses the jQuery function ``$.getJSON``, which performs the Ajax call and, on response, stores the weekdays names in a local JavaScript variable ``data`` and passes the variable to the callback function. In the example the callback function simply alerts the visitor that the data has been received.

#### PyRTF
``PyRTF``:inxx ``RTF``:inxx

Another common need of web sites is that of generating Word-readable text documents. The simplest way to do so is using the Rich Text Format (RTF) document format. This format was invented by Microsoft and it has since become a standard.

web2py includes gluon.contrib.pyrtf, developed by Simon Cusack and revised by Grant Edwards. This module allows you to generate RTF documents programmatically including colored formatted text and pictures.

In the following example we instantiate two basic RTF classes, Document and Section, append the latter to the former and insert some dummy text in the latter:
``
def makertf():
    import gluon.contrib.pyrtf as q
    doc=q.Document()
    section=q.Section()
    doc.Sections.append(section)
    section.append(&#x27;Section Title&#x27;)
    section.append(&#x27;web2py is great. &#x27;*100)
    response.headers[&#x27;Content-Type&#x27;]=&#x27;text/rtf&#x27;
    return q.dumps(doc)
``:code

In the end the Document is serialized by ``q.dumps(doc)``. Notice that before returning an RTF document it is necessary to specify the content-type in the header else the browser does not know how to handle the file.

Depending on the configuration, the browser may ask you whether to save this file or open it using a text editor.

#### ReportLab and PDF
``ReportLab``:inxx ``PDF``:inxx

web2py can also generate PDF documents, with an additional library called &quot;ReportLab&quot;``ReportLab``:cite .

If you are running web2py from source, it is sufficient to have ReportLab installed. If you are running the Windows binary distribution, you need to unzip ReportLab in the &quot;web2py/&quot; folder. If you are running the Mac binary distribution, you need to unzip ReportLab  in the folder:
``
web2py.app/Contents/Resources/
``:code

From now on we assume ReportLab is installed and that web2py can find it.
We will create a simple action called &quot;get_me_a_pdf&quot; that generates a PDF document.
``
from reportlab.platypus import *
A GET request to

``
http://127.0.0.1/myapp/default/api/person/1.json
``

indicates a request for the information associated to ``person/1`` (the record with ``id==1``) and in json format.

In the case of web2py each request can be split into three parts:

- A first part that identify the location of the service, i.e. the action that exposes the service:
``
http://127.0.0.1/myapp/default/api/
``
- The name of the resource (``person``, ``persons``, ``person/1``, etc.)
- The communication protocol specified y the extension.

Notice that we can always use the router to eliminate any unwanted prefix in the URL and for example simplify this:

``
http://127.0.0.1/myapp/default/api/person/1.json
``

into this:

``
http://127.0.0.1/api/person/1.json
``

yet this is a matter of test and we have already discussed it at length in chapter 4.

In our example we used an action called ``api`` but this is not a requirement. We can in fact name the action that exposes the RESTful service any way we like and we can in fact even create more than one. For the same of the argument we will continue to assume that our RESTful action is called ``api``.

We will also assume we have defined the following two tables:

``
db.define_table(&#x27;person&#x27;,Field(&#x27;name&#x27;),Field(&#x27;info&#x27;))
db.define_table(&#x27;pet&#x27;,Field(&#x27;owner&#x27;,db.person),Field(&#x27;name&#x27;),Field(&#x27;info&#x27;))
``

and they are the resources we want to expose.

The first thing we do is create the RESTful action:

``
def api():
    return locals()
``

Now we modify it so that the extension is filtered out of the request args (so that ``request.args`` can be used to identify the resource) and so that it can handle the different methods separately:

``
@request.restful()
def api():
    def GET(*args,**vars):
        return dict()
    def POST(*args,**vars):
        return dict()
    def PUT(*args,**vars):
        return dict()
    def DELETE(*args,**vars):
        return dict()
which for out ``person`` and ``pet`` tables results in:
   &quot;/person/id/{person.id}/pet[pet.owner]/owner/{pet.owner}&quot;,
   &quot;/person/id/{person.id}/pet[pet.owner]/owner/{pet.owner}/:field&quot;,
   &quot;/person/name/pet[pet.owner]&quot;,
   &quot;/person/name/pet[pet.owner]/id/{pet.id}&quot;,
   &quot;/person/name/pet[pet.owner]/id/{pet.id}/:field&quot;,
   &quot;/person/name/pet[pet.owner]/owner/{pet.owner}&quot;,
   &quot;/person/name/pet[pet.owner]/owner/{pet.owner}/:field&quot;,
   &quot;/person/info/pet[pet.owner]&quot;,
   &quot;/person/info/pet[pet.owner]/id/{pet.id}&quot;,
   &quot;/person/info/pet[pet.owner]/id/{pet.id}/:field&quot;,
   &quot;/person/info/pet[pet.owner]/owner/{pet.owner}&quot;,
   &quot;/person/info/pet[pet.owner]/owner/{pet.owner}/:field&quot;,
   &quot;/pet[pet]&quot;,
   &quot;/pet/id/{pet.id}&quot;,
   &quot;/pet/id/{pet.id}/:field&quot;,
   &quot;/pet/owner/{pet.owner}&quot;,
   &quot;/pet/owner/{pet.owner}/:field&quot;
]}
``

You can specify auto patterns for some tables only:

``
patterns = [&#x27;:auto[person]&#x27;,&#x27;:auto[pet]&#x27;]
``

#### ``smart_query`` (experimental)

``smart_query``:inxx

There are time when you need more flexibility and you want to be able to pass to a RESTful service an arbitrary query like
</pre></div>
</div>
<hr />


        
      </div>

      <div id="push"></div>
    </div>

    <div id="footer">
      <div class="container-fluid">
          <div class="copyright pull-left">Copyright &#169; 2013</div>
          <div id="poweredBy" class="pull-right">
              Powered by
              <a href="http://www.web2py.com/">web2py</a>
          </div>
      </div>
    </div>
<script src="static/js/bootstrap.min.js"></script>
<script src="static/js/web2py_bootstrap.js"></script>
</body>
</html>
